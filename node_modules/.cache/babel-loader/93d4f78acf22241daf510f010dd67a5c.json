{"ast":null,"code":"import { resolveEdge, namedEdges } from './edge.mjs';\nconst defaultOffset = [0, 0];\n\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n  let targetPoint = 0;\n  let containerPoint = 0;\n\n  if (typeof offset === \"number\") {\n    /**\n     * If we're provided offset: [0, 0.5, 1] then each number x should become\n     * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n     * and container etc.\n     */\n    offsetDefinition = [offset, offset];\n  } else if (typeof offset === \"string\") {\n    offset = offset.trim();\n\n    if (offset.includes(\" \")) {\n      offsetDefinition = offset.split(\" \");\n    } else {\n      /**\n       * If we're provided a definition like \"100px\" then we want to apply\n       * that only to the top of the target point, leaving the container at 0.\n       * Whereas a named offset like \"end\" should be applied to both.\n       */\n      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n    }\n  }\n\n  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n  containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n  return targetPoint - containerPoint;\n}\n\nexport { resolveOffset };","map":{"version":3,"mappings":";AAGA,MAAMA,aAAa,GAAyB,CAAC,CAAD,EAAI,CAAJ,CAA5C;;AAEM,SAAUC,aAAV,CACFC,MADE,EAEFC,eAFE,EAGFC,YAHE,EAIFC,WAJE,EAIiB;EAEnB,IAAIC,gBAAgB,GAChBC,KAAK,CAACC,OAAN,CAAcN,MAAd,IAAwBA,MAAxB,GAAiCF,aADrC;EAGA,IAAIS,WAAW,GAAG,CAAlB;EACA,IAAIC,cAAc,GAAG,CAArB;;EAEA,IAAI,OAAOR,MAAP,KAAkB,QAAtB,EAAgC;IAC5B;;;;AAIG;IACHI,gBAAgB,GAAG,CAACJ,MAAD,EAASA,MAAT,CAAnB;EACH,CAPD,MAOO,IAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;IACnCA,MAAM,GAAGA,MAAM,CAACS,IAAP,EAAT;;IAEA,IAAIT,MAAM,CAACU,QAAP,CAAgB,GAAhB,CAAJ,EAA0B;MACtBN,gBAAgB,GAAGJ,MAAM,CAACW,KAAP,CAAa,GAAb,CAAnB;IACH,CAFD,MAEO;MACH;;;;AAIG;MACHP,gBAAgB,GAAG,CAACJ,MAAD,EAASY,UAAU,CAACZ,MAAD,CAAV,GAAgDA,MAAhD,GAAyD,GAAlE,CAAnB;IACH;EACJ;;EAEDO,WAAW,GAAGM,WAAW,CAACT,gBAAgB,CAAC,CAAD,CAAjB,EAAsBF,YAAtB,EAAoCC,WAApC,CAAzB;EACAK,cAAc,GAAGK,WAAW,CAACT,gBAAgB,CAAC,CAAD,CAAjB,EAAsBH,eAAtB,CAA5B;EAEA,OAAOM,WAAW,GAAGC,cAArB;AACJ","names":["defaultOffset","resolveOffset","offset","containerLength","targetLength","targetInset","offsetDefinition","Array","isArray","targetPoint","containerPoint","trim","includes","split","namedEdges","resolveEdge"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\render\\dom\\scroll\\offsets\\offset.ts"],"sourcesContent":["import { Edge, EdgeString, Intersection, ProgressIntersection } from \"../types\"\nimport { namedEdges, resolveEdge } from \"./edge\"\n\nconst defaultOffset: ProgressIntersection = [0, 0]\n\nexport function resolveOffset(\n    offset: Edge | Intersection | ProgressIntersection,\n    containerLength: number,\n    targetLength: number,\n    targetInset: number\n) {\n    let offsetDefinition: ProgressIntersection | [EdgeString, EdgeString] =\n        Array.isArray(offset) ? offset : defaultOffset\n\n    let targetPoint = 0\n    let containerPoint = 0\n\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset]\n    } else if (typeof offset === \"string\") {\n        offset = offset.trim() as EdgeString\n\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \") as [EdgeString, EdgeString]\n        } else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset as keyof typeof namedEdges] ? offset : `0`]\n        }\n    }\n\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset)\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength)\n\n    return targetPoint - containerPoint\n}\n"]},"metadata":{},"sourceType":"module"}