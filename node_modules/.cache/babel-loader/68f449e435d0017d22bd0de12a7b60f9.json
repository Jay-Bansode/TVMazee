{"ast":null,"code":"function buildProjectionTransform(delta, treeScale, latestTransform) {\n  let transform = \"\";\n  /**\n   * The translations we use to calculate are always relative to the viewport coordinate space.\n   * But when we apply scales, we also scale the coordinate space of an element and its children.\n   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n   */\n\n  const xTranslate = delta.x.translate / treeScale.x;\n  const yTranslate = delta.y.translate / treeScale.y;\n  const zTranslate = latestTransform?.z || 0;\n\n  if (xTranslate || yTranslate || zTranslate) {\n    transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n  }\n  /**\n   * Apply scale correction for the tree transform.\n   * This will apply scale to the screen-orientated axes.\n   */\n\n\n  if (treeScale.x !== 1 || treeScale.y !== 1) {\n    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n  }\n\n  if (latestTransform) {\n    const {\n      transformPerspective,\n      rotate,\n      rotateX,\n      rotateY,\n      skewX,\n      skewY\n    } = latestTransform;\n    if (transformPerspective) transform = `perspective(${transformPerspective}px) ${transform}`;\n    if (rotate) transform += `rotate(${rotate}deg) `;\n    if (rotateX) transform += `rotateX(${rotateX}deg) `;\n    if (rotateY) transform += `rotateY(${rotateY}deg) `;\n    if (skewX) transform += `skewX(${skewX}deg) `;\n    if (skewY) transform += `skewY(${skewY}deg) `;\n  }\n  /**\n   * Apply scale to match the size of the element to the size we want it.\n   * This will apply scale to the element-orientated axes.\n   */\n\n\n  const elementScaleX = delta.x.scale * treeScale.x;\n  const elementScaleY = delta.y.scale * treeScale.y;\n\n  if (elementScaleX !== 1 || elementScaleY !== 1) {\n    transform += `scale(${elementScaleX}, ${elementScaleY})`;\n  }\n\n  return transform || \"none\";\n}\n\nexport { buildProjectionTransform };","map":{"version":3,"mappings":"SAGgBA,yBACZC,OACAC,WACAC,iBAAgC;EAEhC,IAAIC,SAAS,GAAG,EAAhB;EAEA;;;;;AAKG;;EACH,MAAMC,UAAU,GAAGJ,KAAK,CAACK,CAAN,CAAQC,SAAR,GAAoBL,SAAS,CAACI,CAAjD;EACA,MAAME,UAAU,GAAGP,KAAK,CAACQ,CAAN,CAAQF,SAAR,GAAoBL,SAAS,CAACO,CAAjD;EACA,MAAMC,UAAU,GAAGP,eAAe,EAAEQ,CAAjB,IAAsB,CAAzC;;EACA,IAAIN,UAAU,IAAIG,UAAd,IAA4BE,UAAhC,EAA4C;IACxCN,SAAS,GAAG,eAAeC,UAAU,OAAOG,UAAiB,iBAAU,MAAvE;EACH;EAED;;;AAGG;;;EACH,IAAIN,SAAS,CAACI,CAAV,KAAgB,CAAhB,IAAqBJ,SAAS,CAACO,CAAV,KAAgB,CAAzC,EAA4C;IACxCL,SAAS,IAAI,SAAS,IAAIF,SAAS,CAACI,CAAM,SAAIJ,SAAS,CAACO,CAAC,IAAzD;EACH;;EAED,IAAIN,eAAJ,EAAqB;IACjB,MAAM;MAAES,oBAAF;MAAwBC,MAAxB;MAAgCC,OAAhC;MAAyCC,OAAzC;MAAkDC,KAAlD;MAAyDC;IAAzD,IACFd,eADJ;IAEA,IAAIS,oBAAJ,EACIR,SAAS,GAAkB,mCAA2B,gBAAS,EAA/D;IACJ,IAAIS,MAAJ,EAAYT,SAAS,IAAI,UAAUS,MAAM,OAA7B;IACZ,IAAIC,OAAJ,EAAaV,SAAS,IAAI,WAAWU,OAAO,OAA/B;IACb,IAAIC,OAAJ,EAAaX,SAAS,IAAI,WAAWW,OAAO,OAA/B;IACb,IAAIC,KAAJ,EAAWZ,SAAS,IAAI,SAASY,KAAK,OAA3B;IACX,IAAIC,KAAJ,EAAWb,SAAS,IAAI,SAASa,KAAK,OAA3B;EACd;EAED;;;AAGG;;;EACH,MAAMC,aAAa,GAAGjB,KAAK,CAACK,CAAN,CAAQa,KAAR,GAAgBjB,SAAS,CAACI,CAAhD;EACA,MAAMc,aAAa,GAAGnB,KAAK,CAACQ,CAAN,CAAQU,KAAR,GAAgBjB,SAAS,CAACO,CAAhD;;EACA,IAAIS,aAAa,KAAK,CAAlB,IAAuBE,aAAa,KAAK,CAA7C,EAAgD;IAC5ChB,SAAS,IAAa,sBAAkB,kBAAa,GAArD;EACH;;EAED,OAAOA,SAAS,IAAI,MAApB;AACJ","names":["buildProjectionTransform","delta","treeScale","latestTransform","transform","xTranslate","x","translate","yTranslate","y","zTranslate","z","transformPerspective","rotate","rotateX","rotateY","skewX","skewY","elementScaleX","scale","elementScaleY"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\projection\\styles\\transform.ts"],"sourcesContent":["import type { Delta, Point } from \"motion-utils\"\nimport type { ResolvedValues } from \"../../node/types\"\n\nexport function buildProjectionTransform(\n    delta: Delta,\n    treeScale: Point,\n    latestTransform?: ResolvedValues\n): string {\n    let transform = \"\"\n\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    const xTranslate = delta.x.translate / treeScale.x\n    const yTranslate = delta.y.translate / treeScale.y\n    const zTranslate = latestTransform?.z || 0\n    if (xTranslate || yTranslate || zTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `\n    }\n\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `\n    }\n\n    if (latestTransform) {\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } =\n            latestTransform\n        if (transformPerspective)\n            transform = `perspective(${transformPerspective}px) ${transform}`\n        if (rotate) transform += `rotate(${rotate}deg) `\n        if (rotateX) transform += `rotateX(${rotateX}deg) `\n        if (rotateY) transform += `rotateY(${rotateY}deg) `\n        if (skewX) transform += `skewX(${skewX}deg) `\n        if (skewY) transform += `skewY(${skewY}deg) `\n    }\n\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    const elementScaleX = delta.x.scale * treeScale.x\n    const elementScaleY = delta.y.scale * treeScale.y\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`\n    }\n\n    return transform || \"none\"\n}\n"]},"metadata":{},"sourceType":"module"}