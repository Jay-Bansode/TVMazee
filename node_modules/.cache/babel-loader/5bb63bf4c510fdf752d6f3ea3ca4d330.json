{"ast":null,"code":"import { resize, frame, cancelFrame, frameData } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { createScrollInfo } from './info.mjs';\nimport { createOnScrollHandler } from './on-scroll-handler.mjs';\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst scrollSize = new WeakMap();\nconst dimensionCheckProcesses = new WeakMap();\n\nconst getEventTarget = element => element === document.scrollingElement ? window : element;\n\nfunction scrollInfo(onScroll) {\n  let {\n    container = document.scrollingElement,\n    trackContentSize = false,\n    ...options\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!container) return noop;\n  let containerHandlers = onScrollHandlers.get(container);\n  /**\n   * Get the onScroll handlers for this container.\n   * If one isn't found, create a new one.\n   */\n\n  if (!containerHandlers) {\n    containerHandlers = new Set();\n    onScrollHandlers.set(container, containerHandlers);\n  }\n  /**\n   * Create a new onScroll handler for the provided callback.\n   */\n\n\n  const info = createScrollInfo();\n  const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n  containerHandlers.add(containerHandler);\n  /**\n   * Check if there's a scroll event listener for this container.\n   * If not, create one.\n   */\n\n  if (!scrollListeners.has(container)) {\n    const measureAll = () => {\n      for (const handler of containerHandlers) {\n        handler.measure(frameData.timestamp);\n      }\n\n      frame.preUpdate(notifyAll);\n    };\n\n    const notifyAll = () => {\n      for (const handler of containerHandlers) {\n        handler.notify();\n      }\n    };\n\n    const listener = () => frame.read(measureAll);\n\n    scrollListeners.set(container, listener);\n    const target = getEventTarget(container);\n    window.addEventListener(\"resize\", listener);\n\n    if (container !== document.documentElement) {\n      resizeListeners.set(container, resize(container, listener));\n    }\n\n    target.addEventListener(\"scroll\", listener);\n    listener();\n  }\n  /**\n   * Enable content size tracking if requested and not already enabled.\n   */\n\n\n  if (trackContentSize && !dimensionCheckProcesses.has(container)) {\n    const listener = scrollListeners.get(container); // Store initial scroll dimensions (object is reused to avoid allocation)\n\n    const size = {\n      width: container.scrollWidth,\n      height: container.scrollHeight\n    };\n    scrollSize.set(container, size); // Add frame-based scroll dimension checking to detect content changes\n\n    const checkScrollDimensions = () => {\n      const newWidth = container.scrollWidth;\n      const newHeight = container.scrollHeight;\n\n      if (size.width !== newWidth || size.height !== newHeight) {\n        listener();\n        size.width = newWidth;\n        size.height = newHeight;\n      }\n    }; // Schedule with keepAlive=true to run every frame\n\n\n    const dimensionCheckProcess = frame.read(checkScrollDimensions, true);\n    dimensionCheckProcesses.set(container, dimensionCheckProcess);\n  }\n\n  const listener = scrollListeners.get(container);\n  frame.read(listener, false, true);\n  return () => {\n    cancelFrame(listener);\n    /**\n     * Check if we even have any handlers for this container.\n     */\n\n    const currentHandlers = onScrollHandlers.get(container);\n    if (!currentHandlers) return;\n    currentHandlers.delete(containerHandler);\n    if (currentHandlers.size) return;\n    /**\n     * If no more handlers, remove the scroll listener too.\n     */\n\n    const scrollListener = scrollListeners.get(container);\n    scrollListeners.delete(container);\n\n    if (scrollListener) {\n      getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n      resizeListeners.get(container)?.();\n      window.removeEventListener(\"resize\", scrollListener);\n    } // Clean up scroll dimension checking\n\n\n    const dimensionCheckProcess = dimensionCheckProcesses.get(container);\n\n    if (dimensionCheckProcess) {\n      cancelFrame(dimensionCheckProcess);\n      dimensionCheckProcesses.delete(container);\n    }\n\n    scrollSize.delete(container);\n  };\n}\n\nexport { scrollInfo };","map":{"version":3,"mappings":";;;;AAMA,MAAMA,eAAe,GAAG,IAAIC,OAAJ,EAAxB;AACA,MAAMC,eAAe,GAAG,IAAID,OAAJ,EAAxB;AACA,MAAME,gBAAgB,GAAG,IAAIF,OAAJ,EAAzB;AACA,MAAMG,UAAU,GAAG,IAAIH,OAAJ,EAAnB;AACA,MAAMI,uBAAuB,GAAG,IAAIJ,OAAJ,EAAhC;;AAIA,MAAMK,cAAc,GAAIC,OAAD,IACnBA,OAAO,KAAKC,QAAQ,CAACC,gBAArB,GAAwCC,MAAxC,GAAiDH,OADrD;;SAGgBI,WACZC,UAKyB;EAAA,IAJzB;IACIC,SAAS,GAAGL,QAAQ,CAACC,gBADzB;IAEIK,gBAAgB,GAAG,KAFvB;IAGI,GAAGC;EAHP,CAIyB,uEAAF,EAAE;EAEzB,IAAI,CAACF,SAAL,EAAgB,OAAOG,IAAP;EAEhB,IAAIC,iBAAiB,GAAGd,gBAAgB,CAACe,GAAjB,CAAqBL,SAArB,CAAxB;EAEA;;;AAGG;;EACH,IAAI,CAACI,iBAAL,EAAwB;IACpBA,iBAAiB,GAAG,IAAIE,GAAJ,EAApB;IACAhB,gBAAgB,CAACiB,GAAjB,CAAqBP,SAArB,EAAgCI,iBAAhC;EACH;EAED;;AAEG;;;EACH,MAAMI,IAAI,GAAGC,gBAAgB,EAA7B;EACA,MAAMC,gBAAgB,GAAGC,qBAAqB,CAC1CX,SAD0C,EAE1CD,QAF0C,EAG1CS,IAH0C,EAI1CN,OAJ0C,CAA9C;EAMAE,iBAAiB,CAACQ,GAAlB,CAAsBF,gBAAtB;EAEA;;;AAGG;;EACH,IAAI,CAACvB,eAAe,CAAC0B,GAAhB,CAAoBb,SAApB,CAAL,EAAqC;IACjC,MAAMc,UAAU,GAAG,MAAK;MACpB,KAAK,MAAMC,OAAX,IAAsBX,iBAAtB,EAAyC;QACrCW,OAAO,CAACC,OAAR,CAAgBC,SAAS,CAACC,SAA1B;MACH;;MAEDC,KAAK,CAACC,SAAN,CAAgBC,SAAhB;IACH,CAND;;IAQA,MAAMA,SAAS,GAAG,MAAK;MACnB,KAAK,MAAMN,OAAX,IAAsBX,iBAAtB,EAAyC;QACrCW,OAAO,CAACO,MAAR;MACH;IACJ,CAJD;;IAMA,MAAMC,QAAQ,GAAG,MAAMJ,KAAK,CAACK,IAAN,CAAWV,UAAX,CAAvB;;IAEA3B,eAAe,CAACoB,GAAhB,CAAoBP,SAApB,EAA+BuB,QAA/B;IAEA,MAAME,MAAM,GAAGhC,cAAc,CAACO,SAAD,CAA7B;IACAH,MAAM,CAAC6B,gBAAP,CAAwB,QAAxB,EAAkCH,QAAlC;;IACA,IAAIvB,SAAS,KAAKL,QAAQ,CAACgC,eAA3B,EAA4C;MACxCtC,eAAe,CAACkB,GAAhB,CAAoBP,SAApB,EAA+B4B,MAAM,CAAC5B,SAAD,EAAYuB,QAAZ,CAArC;IACH;;IAEDE,MAAM,CAACC,gBAAP,CAAwB,QAAxB,EAAkCH,QAAlC;IAEAA,QAAQ;EACX;EAED;;AAEG;;;EACH,IAAItB,gBAAgB,IAAI,CAACT,uBAAuB,CAACqB,GAAxB,CAA4Bb,SAA5B,CAAzB,EAAiE;IAC7D,MAAMuB,QAAQ,GAAGpC,eAAe,CAACkB,GAAhB,CAAoBL,SAApB,CAAjB,CAD6D;;IAI7D,MAAM6B,IAAI,GAAG;MACTC,KAAK,EAAE9B,SAAS,CAAC+B,WADR;MAETC,MAAM,EAAEhC,SAAS,CAACiC;IAFT,CAAb;IAIA1C,UAAU,CAACgB,GAAX,CAAeP,SAAf,EAA0B6B,IAA1B,EAR6D;;IAW7D,MAAMK,qBAAqB,GAAY,MAAK;MACxC,MAAMC,QAAQ,GAAGnC,SAAS,CAAC+B,WAA3B;MACA,MAAMK,SAAS,GAAGpC,SAAS,CAACiC,YAA5B;;MAEA,IAAIJ,IAAI,CAACC,KAAL,KAAeK,QAAf,IAA2BN,IAAI,CAACG,MAAL,KAAgBI,SAA/C,EAA0D;QACtDb,QAAQ;QACRM,IAAI,CAACC,KAAL,GAAaK,QAAb;QACAN,IAAI,CAACG,MAAL,GAAcI,SAAd;MACH;IACJ,CATD,CAX6D;;;IAuB7D,MAAMC,qBAAqB,GAAGlB,KAAK,CAACK,IAAN,CAAWU,qBAAX,EAAkC,IAAlC,CAA9B;IACA1C,uBAAuB,CAACe,GAAxB,CAA4BP,SAA5B,EAAuCqC,qBAAvC;EACH;;EAED,MAAMd,QAAQ,GAAGpC,eAAe,CAACkB,GAAhB,CAAoBL,SAApB,CAAjB;EACAmB,KAAK,CAACK,IAAN,CAAWD,QAAX,EAAqB,KAArB,EAA4B,IAA5B;EAEA,OAAO,MAAK;IACRe,WAAW,CAACf,QAAD,CAAX;IAEA;;AAEG;;IACH,MAAMgB,eAAe,GAAGjD,gBAAgB,CAACe,GAAjB,CAAqBL,SAArB,CAAxB;IACA,IAAI,CAACuC,eAAL,EAAsB;IAEtBA,eAAe,CAACC,MAAhB,CAAuB9B,gBAAvB;IAEA,IAAI6B,eAAe,CAACV,IAApB,EAA0B;IAE1B;;AAEG;;IACH,MAAMY,cAAc,GAAGtD,eAAe,CAACkB,GAAhB,CAAoBL,SAApB,CAAvB;IACAb,eAAe,CAACqD,MAAhB,CAAuBxC,SAAvB;;IAEA,IAAIyC,cAAJ,EAAoB;MAChBhD,cAAc,CAACO,SAAD,CAAd,CAA0B0C,mBAA1B,CACI,QADJ,EAEID,cAFJ;MAIApD,eAAe,CAACgB,GAAhB,CAAoBL,SAApB;MACAH,MAAM,CAAC6C,mBAAP,CAA2B,QAA3B,EAAqCD,cAArC;IACH,CA1BO;;;IA6BR,MAAMJ,qBAAqB,GAAG7C,uBAAuB,CAACa,GAAxB,CAA4BL,SAA5B,CAA9B;;IACA,IAAIqC,qBAAJ,EAA2B;MACvBC,WAAW,CAACD,qBAAD,CAAX;MACA7C,uBAAuB,CAACgD,MAAxB,CAA+BxC,SAA/B;IACH;;IACDT,UAAU,CAACiD,MAAX,CAAkBxC,SAAlB;EACH,CAnCD;AAoCJ","names":["scrollListeners","WeakMap","resizeListeners","onScrollHandlers","scrollSize","dimensionCheckProcesses","getEventTarget","element","document","scrollingElement","window","scrollInfo","onScroll","container","trackContentSize","options","noop","containerHandlers","get","Set","set","info","createScrollInfo","containerHandler","createOnScrollHandler","add","has","measureAll","handler","measure","frameData","timestamp","frame","preUpdate","notifyAll","notify","listener","read","target","addEventListener","documentElement","resize","size","width","scrollWidth","height","scrollHeight","checkScrollDimensions","newWidth","newHeight","dimensionCheckProcess","cancelFrame","currentHandlers","delete","scrollListener","removeEventListener"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\render\\dom\\scroll\\track.ts"],"sourcesContent":["import { cancelFrame, frame, frameData, resize, Process } from \"motion-dom\"\nimport { noop } from \"motion-utils\"\nimport { createScrollInfo } from \"./info\"\nimport { createOnScrollHandler } from \"./on-scroll-handler\"\nimport { OnScrollHandler, OnScrollInfo, ScrollInfoOptions } from \"./types\"\n\nconst scrollListeners = new WeakMap<Element, VoidFunction>()\nconst resizeListeners = new WeakMap<Element, VoidFunction>()\nconst onScrollHandlers = new WeakMap<Element, Set<OnScrollHandler>>()\nconst scrollSize = new WeakMap<Element, { width: number; height: number }>()\nconst dimensionCheckProcesses = new WeakMap<Element, Process>()\n\nexport type ScrollTargets = Array<HTMLElement>\n\nconst getEventTarget = (element: Element) =>\n    element === document.scrollingElement ? window : element\n\nexport function scrollInfo(\n    onScroll: OnScrollInfo,\n    {\n        container = document.scrollingElement as Element,\n        trackContentSize = false,\n        ...options\n    }: ScrollInfoOptions = {}\n) {\n    if (!container) return noop as VoidFunction\n\n    let containerHandlers = onScrollHandlers.get(container)\n\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set()\n        onScrollHandlers.set(container, containerHandlers)\n    }\n\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo()\n    const containerHandler = createOnScrollHandler(\n        container,\n        onScroll,\n        info,\n        options\n    )\n    containerHandlers.add(containerHandler)\n\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers) {\n                handler.measure(frameData.timestamp)\n            }\n\n            frame.preUpdate(notifyAll)\n        }\n\n        const notifyAll = () => {\n            for (const handler of containerHandlers) {\n                handler.notify()\n            }\n        }\n\n        const listener = () => frame.read(measureAll)\n\n        scrollListeners.set(container, listener)\n\n        const target = getEventTarget(container)\n        window.addEventListener(\"resize\", listener)\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener))\n        }\n\n        target.addEventListener(\"scroll\", listener)\n\n        listener()\n    }\n\n    /**\n     * Enable content size tracking if requested and not already enabled.\n     */\n    if (trackContentSize && !dimensionCheckProcesses.has(container)) {\n        const listener = scrollListeners.get(container)!\n\n        // Store initial scroll dimensions (object is reused to avoid allocation)\n        const size = {\n            width: container.scrollWidth,\n            height: container.scrollHeight,\n        }\n        scrollSize.set(container, size)\n\n        // Add frame-based scroll dimension checking to detect content changes\n        const checkScrollDimensions: Process = () => {\n            const newWidth = container.scrollWidth\n            const newHeight = container.scrollHeight\n\n            if (size.width !== newWidth || size.height !== newHeight) {\n                listener()\n                size.width = newWidth\n                size.height = newHeight\n            }\n        }\n\n        // Schedule with keepAlive=true to run every frame\n        const dimensionCheckProcess = frame.read(checkScrollDimensions, true)\n        dimensionCheckProcesses.set(container, dimensionCheckProcess)\n    }\n\n    const listener = scrollListeners.get(container)!\n    frame.read(listener, false, true)\n\n    return () => {\n        cancelFrame(listener)\n\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container)\n        if (!currentHandlers) return\n\n        currentHandlers.delete(containerHandler)\n\n        if (currentHandlers.size) return\n\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container)\n        scrollListeners.delete(container)\n\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\n                \"scroll\",\n                scrollListener\n            )\n            resizeListeners.get(container)?.()\n            window.removeEventListener(\"resize\", scrollListener)\n        }\n\n        // Clean up scroll dimension checking\n        const dimensionCheckProcess = dimensionCheckProcesses.get(container)\n        if (dimensionCheckProcess) {\n            cancelFrame(dimensionCheckProcess)\n            dimensionCheckProcesses.delete(container)\n        }\n        scrollSize.delete(container)\n    }\n}\n"]},"metadata":{},"sourceType":"module"}