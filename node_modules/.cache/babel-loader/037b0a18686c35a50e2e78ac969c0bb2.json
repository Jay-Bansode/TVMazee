{"ast":null,"code":"import { warnOnce, secondsToMilliseconds, isNumericalString, isZeroValueString, SubscriptionManager } from 'motion-utils';\nimport { KeyframeResolver } from '../animation/keyframes/KeyframesResolver.mjs';\nimport { NativeAnimation } from '../animation/NativeAnimation.mjs';\nimport { acceleratedValues } from '../animation/waapi/utils/accelerated-values.mjs';\nimport { microtask } from '../frameloop/microtask.mjs';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { motionValue } from '../value/index.mjs';\nimport { complex } from '../value/types/complex/index.mjs';\nimport { getAnimatableNone } from '../value/types/utils/animatable-none.mjs';\nimport { findValueType } from '../value/types/utils/find.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\nimport { visualElementStore } from './store.mjs';\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\nimport { transformProps } from './utils/keys-transform.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { initPrefersReducedMotion } from './utils/reduced-motion/index.mjs';\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from './utils/reduced-motion/state.mjs';\nimport { frame, cancelFrame } from '../frameloop/frame.mjs';\nconst propEventHandlers = [\"AnimationStart\", \"AnimationComplete\", \"Update\", \"BeforeLayoutMeasure\", \"LayoutMeasure\", \"LayoutAnimationStart\", \"LayoutAnimationComplete\"];\n/**\n * Static feature definitions - can be injected by framework layer\n */\n\nlet featureDefinitions = {};\n/**\n * Set feature definitions for all VisualElements.\n * This should be called by the framework layer (e.g., framer-motion) during initialization.\n */\n\nfunction setFeatureDefinitions(definitions) {\n  featureDefinitions = definitions;\n}\n/**\n * Get the current feature definitions\n */\n\n\nfunction getFeatureDefinitions() {\n  return featureDefinitions;\n}\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\n\n\nclass VisualElement {\n  /**\n   * This method takes React props and returns found MotionValues. For example, HTML\n   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n   *\n   * This isn't an abstract method as it needs calling in the constructor, but it is\n   * intended to be one.\n   */\n  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n    return {};\n  }\n\n  constructor(_ref) {\n    let {\n      parent,\n      props,\n      presenceContext,\n      reducedMotionConfig,\n      skipAnimations,\n      blockInitialAnimation,\n      visualState\n    } = _ref;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    this.current = null;\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n\n    this.children = new Set();\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n\n    this.shouldReduceMotion = null;\n    /**\n     * Decides whether animations should be skipped for this VisualElement.\n     * Useful for E2E tests and visual regression testing.\n     */\n\n    this.shouldSkipAnimations = false;\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n\n    this.values = new Map();\n    this.KeyframeResolver = KeyframeResolver;\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n\n    this.features = {};\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n\n    this.valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n\n    this.prevMotionValues = {};\n    /**\n     * Track whether this element has been mounted before, to detect\n     * remounts after Suspense unmount/remount cycles.\n     */\n\n    this.hasBeenMounted = false;\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n\n    this.events = {};\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n\n    this.propEventSubscriptions = {};\n\n    this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n\n    this.render = () => {\n      if (!this.current) return;\n      this.triggerBuild();\n      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n    };\n\n    this.renderScheduledAt = 0.0;\n\n    this.scheduleRender = () => {\n      const now = time.now();\n\n      if (this.renderScheduledAt < now) {\n        this.renderScheduledAt = now;\n        frame.render(this.render, false, true);\n      }\n    };\n\n    const {\n      latestValues,\n      renderState\n    } = visualState;\n    this.latestValues = latestValues;\n    this.baseTarget = { ...latestValues\n    };\n    this.initialValues = props.initial ? { ...latestValues\n    } : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.presenceContext = presenceContext;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.skipAnimationsConfig = skipAnimations;\n    this.options = options;\n    this.blockInitialAnimation = Boolean(blockInitialAnimation);\n    this.isControllingVariants = isControllingVariants(props);\n    this.isVariantNode = isVariantNode(props);\n\n    if (this.isVariantNode) {\n      this.variantChildren = new Set();\n    }\n\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't necessarily a breaking change,\n     * more a reflection of the test.\n     */\n\n    const {\n      willChange,\n      ...initialMotionValues\n    } = this.scrapeMotionValuesFromProps(props, {}, this);\n\n    for (const key in initialMotionValues) {\n      const value = initialMotionValues[key];\n\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key]);\n      }\n    }\n  }\n\n  mount(instance) {\n    /**\n     * If this element has been mounted before (e.g. after a Suspense\n     * unmount/remount), reset motion values to their initial state\n     * so animations replay correctly from initial â†’ animate.\n     */\n    if (this.hasBeenMounted) {\n      for (const key in this.initialValues) {\n        this.values.get(key)?.jump(this.initialValues[key]);\n        this.latestValues[key] = this.initialValues[key];\n      }\n    }\n\n    this.current = instance;\n    visualElementStore.set(instance, this);\n\n    if (this.projection && !this.projection.instance) {\n      this.projection.mount(instance);\n    }\n\n    if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n      this.removeFromVariantTree = this.parent.addVariantChild(this);\n    }\n\n    this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n    /**\n     * Determine reduced motion preference. Only initialize the matchMedia\n     * listener if we actually need the dynamic value (i.e., when config\n     * is neither \"never\" nor \"always\").\n     */\n\n    if (this.reducedMotionConfig === \"never\") {\n      this.shouldReduceMotion = false;\n    } else if (this.reducedMotionConfig === \"always\") {\n      this.shouldReduceMotion = true;\n    } else {\n      if (!hasReducedMotionListener.current) {\n        initPrefersReducedMotion();\n      }\n\n      this.shouldReduceMotion = prefersReducedMotion.current;\n    }\n\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\", \"reduced-motion-disabled\");\n    }\n    /**\n     * Set whether animations should be skipped based on the config.\n     */\n\n\n    this.shouldSkipAnimations = this.skipAnimationsConfig ?? false;\n    this.parent?.addChild(this);\n    this.update(this.props, this.presenceContext);\n    this.hasBeenMounted = true;\n  }\n\n  unmount() {\n    this.projection && this.projection.unmount();\n    cancelFrame(this.notifyUpdate);\n    cancelFrame(this.render);\n    this.valueSubscriptions.forEach(remove => remove());\n    this.valueSubscriptions.clear();\n    this.removeFromVariantTree && this.removeFromVariantTree();\n    this.parent?.removeChild(this);\n\n    for (const key in this.events) {\n      this.events[key].clear();\n    }\n\n    for (const key in this.features) {\n      const feature = this.features[key];\n\n      if (feature) {\n        feature.unmount();\n        feature.isMounted = false;\n      }\n    }\n\n    this.current = null;\n  }\n\n  addChild(child) {\n    this.children.add(child);\n    this.enteringChildren ?? (this.enteringChildren = new Set());\n    this.enteringChildren.add(child);\n  }\n\n  removeChild(child) {\n    this.children.delete(child);\n    this.enteringChildren && this.enteringChildren.delete(child);\n  }\n\n  bindToMotionValue(key, value) {\n    if (this.valueSubscriptions.has(key)) {\n      this.valueSubscriptions.get(key)();\n    }\n\n    if (value.accelerate && acceleratedValues.has(key) && this.current instanceof HTMLElement) {\n      const {\n        factory,\n        keyframes,\n        times,\n        ease,\n        duration\n      } = value.accelerate;\n      const animation = new NativeAnimation({\n        element: this.current,\n        name: key,\n        keyframes,\n        times,\n        ease,\n        duration: secondsToMilliseconds(duration)\n      });\n      const cleanup = factory(animation);\n      this.valueSubscriptions.set(key, () => {\n        cleanup();\n        animation.cancel();\n      });\n      return;\n    }\n\n    const valueIsTransform = transformProps.has(key);\n\n    if (valueIsTransform && this.onBindTransform) {\n      this.onBindTransform();\n    }\n\n    const removeOnChange = value.on(\"change\", latestValue => {\n      this.latestValues[key] = latestValue;\n      this.props.onUpdate && frame.preRender(this.notifyUpdate);\n\n      if (valueIsTransform && this.projection) {\n        this.projection.isTransformDirty = true;\n      }\n\n      this.scheduleRender();\n    });\n    let removeSyncCheck;\n\n    if (typeof window !== \"undefined\" && window.MotionCheckAppearSync) {\n      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n    }\n\n    this.valueSubscriptions.set(key, () => {\n      removeOnChange();\n      if (removeSyncCheck) removeSyncCheck();\n      if (value.owner) value.stop();\n    });\n  }\n\n  sortNodePosition(other) {\n    /**\n     * If these nodes aren't even of the same type we can't compare their depth.\n     */\n    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {\n      return 0;\n    }\n\n    return this.sortInstanceNodePosition(this.current, other.current);\n  }\n\n  updateFeatures() {\n    let key = \"animation\";\n\n    for (key in featureDefinitions) {\n      const featureDefinition = featureDefinitions[key];\n      if (!featureDefinition) continue;\n      const {\n        isEnabled,\n        Feature: FeatureConstructor\n      } = featureDefinition;\n      /**\n       * If this feature is enabled but not active, make a new instance.\n       */\n\n      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {\n        this.features[key] = new FeatureConstructor(this);\n      }\n      /**\n       * If we have a feature, mount or update it.\n       */\n\n\n      if (this.features[key]) {\n        const feature = this.features[key];\n\n        if (feature.isMounted) {\n          feature.update();\n        } else {\n          feature.mount();\n          feature.isMounted = true;\n        }\n      }\n    }\n  }\n\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.props);\n  }\n  /**\n   * Measure the current viewport box with or without transforms.\n   * Only measures axis-aligned boxes, rotate and skew must be manually\n   * removed with a re-render to work.\n   */\n\n\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n  }\n\n  getStaticValue(key) {\n    return this.latestValues[key];\n  }\n\n  setStaticValue(key, value) {\n    this.latestValues[key] = value;\n  }\n  /**\n   * Update the provided props. Ensure any newly-added motion values are\n   * added to our map, old ones removed, and listeners updated.\n   */\n\n\n  update(props, presenceContext) {\n    if (props.transformTemplate || this.props.transformTemplate) {\n      this.scheduleRender();\n    }\n\n    this.prevProps = this.props;\n    this.props = props;\n    this.prevPresenceContext = this.presenceContext;\n    this.presenceContext = presenceContext;\n    /**\n     * Update prop event handlers ie onAnimationStart, onAnimationComplete\n     */\n\n    for (let i = 0; i < propEventHandlers.length; i++) {\n      const key = propEventHandlers[i];\n\n      if (this.propEventSubscriptions[key]) {\n        this.propEventSubscriptions[key]();\n        delete this.propEventSubscriptions[key];\n      }\n\n      const listenerName = \"on\" + key;\n      const listener = props[listenerName];\n\n      if (listener) {\n        this.propEventSubscriptions[key] = this.on(key, listener);\n      }\n    }\n\n    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps || {}, this), this.prevMotionValues);\n\n    if (this.handleChildMotionValue) {\n      this.handleChildMotionValue();\n    }\n  }\n\n  getProps() {\n    return this.props;\n  }\n  /**\n   * Returns the variant definition with a given name.\n   */\n\n\n  getVariant(name) {\n    return this.props.variants ? this.props.variants[name] : undefined;\n  }\n  /**\n   * Returns the defined default transition on this component.\n   */\n\n\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n\n  getClosestVariantNode() {\n    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : undefined;\n  }\n  /**\n   * Add a child visual element to our set of children.\n   */\n\n\n  addVariantChild(child) {\n    const closestVariantNode = this.getClosestVariantNode();\n\n    if (closestVariantNode) {\n      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);\n      return () => closestVariantNode.variantChildren.delete(child);\n    }\n  }\n  /**\n   * Add a motion value and bind it to this visual element.\n   */\n\n\n  addValue(key, value) {\n    // Remove existing value if it exists\n    const existingValue = this.values.get(key);\n\n    if (value !== existingValue) {\n      if (existingValue) this.removeValue(key);\n      this.bindToMotionValue(key, value);\n      this.values.set(key, value);\n      this.latestValues[key] = value.get();\n    }\n  }\n  /**\n   * Remove a motion value and unbind any active subscriptions.\n   */\n\n\n  removeValue(key) {\n    this.values.delete(key);\n    const unsubscribe = this.valueSubscriptions.get(key);\n\n    if (unsubscribe) {\n      unsubscribe();\n      this.valueSubscriptions.delete(key);\n    }\n\n    delete this.latestValues[key];\n    this.removeValueFromRenderState(key, this.renderState);\n  }\n  /**\n   * Check whether we have a motion value for this key\n   */\n\n\n  hasValue(key) {\n    return this.values.has(key);\n  }\n\n  getValue(key, defaultValue) {\n    if (this.props.values && this.props.values[key]) {\n      return this.props.values[key];\n    }\n\n    let value = this.values.get(key);\n\n    if (value === undefined && defaultValue !== undefined) {\n      value = motionValue(defaultValue === null ? undefined : defaultValue, {\n        owner: this\n      });\n      this.addValue(key, value);\n    }\n\n    return value;\n  }\n  /**\n   * If we're trying to animate to a previously unencountered value,\n   * we need to check for it in our state and as a last resort read it\n   * directly from the instance (which might have performance implications).\n   */\n\n\n  readValue(key, target) {\n    let value = this.latestValues[key] !== undefined || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);\n\n    if (value !== undefined && value !== null) {\n      if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n        // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n        value = parseFloat(value);\n      } else if (!findValueType(value) && complex.test(target)) {\n        value = getAnimatableNone(key, target);\n      }\n\n      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n    }\n\n    return isMotionValue(value) ? value.get() : value;\n  }\n  /**\n   * Set the base target to later animate back to. This is currently\n   * only hydrated on creation and when we first read a value.\n   */\n\n\n  setBaseTarget(key, value) {\n    this.baseTarget[key] = value;\n  }\n  /**\n   * Find the base target for a value thats been removed from all animation\n   * props.\n   */\n\n\n  getBaseTarget(key) {\n    const {\n      initial\n    } = this.props;\n    let valueFromInitial;\n\n    if (typeof initial === \"string\" || typeof initial === \"object\") {\n      const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);\n\n      if (variant) {\n        valueFromInitial = variant[key];\n      }\n    }\n    /**\n     * If this value still exists in the current initial variant, read that.\n     */\n\n\n    if (initial && valueFromInitial !== undefined) {\n      return valueFromInitial;\n    }\n    /**\n     * Alternatively, if this VisualElement config has defined a getBaseTarget\n     * so we can read the value from an alternative source, try that.\n     */\n\n\n    const target = this.getBaseTargetFromProps(this.props, key);\n    if (target !== undefined && !isMotionValue(target)) return target;\n    /**\n     * If the value was initially defined on initial, but it doesn't any more,\n     * return undefined. Otherwise return the value as initially read from the DOM.\n     */\n\n    return this.initialValues[key] !== undefined && valueFromInitial === undefined ? undefined : this.baseTarget[key];\n  }\n\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n\n    return this.events[eventName].add(callback);\n  }\n\n  notify(eventName) {\n    if (this.events[eventName]) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      this.events[eventName].notify(...args);\n    }\n  }\n\n  scheduleRenderMicrotask() {\n    microtask.render(this.render);\n  }\n\n}\n\nexport { VisualElement, getFeatureDefinitions, setFeatureDefinitions };","map":{"version":3,"mappings":"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","names":["propEventHandlers","featureDefinitions","setFeatureDefinitions","definitions","getFeatureDefinitions","VisualElement","scrapeMotionValuesFromProps","_props","_prevProps","_visualElement","constructor","parent","props","presenceContext","reducedMotionConfig","skipAnimations","blockInitialAnimation","visualState","options","current","Set","isVariantNode","isControllingVariants","shouldReduceMotion","shouldSkipAnimations","Map","KeyframeResolver","features","prevMotionValues","hasBeenMounted","events","propEventSubscriptions","notify","latestValues","render","triggerBuild","renderInstance","renderState","style","projection","renderScheduledAt","scheduleRender","now","time","frame","baseTarget","initialValues","initial","depth","skipAnimationsConfig","Boolean","checkIsControllingVariants","checkIsVariantNode","variantChildren","manuallyAnimateOnMount","willChange","initialMotionValues","key","value","undefined","isMotionValue","set","mount","instance","values","get","jump","visualElementStore","removeFromVariantTree","addVariantChild","forEach","bindToMotionValue","hasReducedMotionListener","initPrefersReducedMotion","prefersReducedMotion","process","env","NODE_ENV","warnOnce","addChild","update","unmount","cancelFrame","notifyUpdate","valueSubscriptions","remove","clear","removeChild","feature","isMounted","child","children","add","enteringChildren","delete","has","accelerate","acceleratedValues","HTMLElement","factory","keyframes","times","ease","duration","animation","NativeAnimation","element","name","secondsToMilliseconds","cleanup","cancel","valueIsTransform","transformProps","onBindTransform","removeOnChange","on","latestValue","onUpdate","preRender","isTransformDirty","removeSyncCheck","window","MotionCheckAppearSync","owner","stop","sortNodePosition","other","sortInstanceNodePosition","type","updateFeatures","featureDefinition","isEnabled","Feature","FeatureConstructor","build","measureViewportBox","measureInstanceViewportBox","createBox","getStaticValue","setStaticValue","transformTemplate","prevProps","prevPresenceContext","i","length","listenerName","listener","updateMotionValuesFromProps","handleChildMotionValue","getProps","getVariant","variants","getDefaultTransition","transition","getTransformPagePoint","transformPagePoint","getClosestVariantNode","closestVariantNode","addValue","existingValue","removeValue","unsubscribe","removeValueFromRenderState","hasValue","getValue","defaultValue","motionValue","readValue","target","getBaseTargetFromProps","readValueFromInstance","isNumericalString","isZeroValueString","parseFloat","findValueType","complex","test","getAnimatableNone","setBaseTarget","getBaseTarget","valueFromInitial","variant","resolveVariantFromProps","custom","eventName","callback","SubscriptionManager","args","scheduleRenderMicrotask","microtask"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\render\\VisualElement.ts"],"sourcesContent":["import {\n    Box,\n    isNumericalString,\n    isZeroValueString,\n    secondsToMilliseconds,\n    SubscriptionManager,\n    warnOnce,\n} from \"motion-utils\"\nimport { KeyframeResolver } from \"../animation/keyframes/KeyframesResolver\"\nimport { NativeAnimation } from \"../animation/NativeAnimation\"\nimport type { AnyResolvedKeyframe } from \"../animation/types\"\nimport { acceleratedValues } from \"../animation/waapi/utils/accelerated-values\"\nimport { cancelFrame, frame } from \"../frameloop\"\nimport { microtask } from \"../frameloop/microtask\"\nimport { time } from \"../frameloop/sync-time\"\nimport type { MotionNodeOptions } from \"../node/types\"\nimport { createBox } from \"../projection/geometry/models\"\nimport { motionValue, MotionValue } from \"../value\"\nimport { complex } from \"../value/types/complex\"\nimport { getAnimatableNone } from \"../value/types/utils/animatable-none\"\nimport { findValueType } from \"../value/types/utils/find\"\nimport { isMotionValue } from \"../value/utils/is-motion-value\"\nimport { Feature } from \"./Feature\"\nimport { visualElementStore } from \"./store\"\nimport {\n    FeatureDefinitions,\n    MotionConfigContextProps,\n    PresenceContextProps,\n    ReducedMotionConfig,\n    ResolvedValues,\n    VisualElementEventCallbacks,\n    VisualElementOptions,\n} from \"./types\"\nimport { AnimationState } from \"./utils/animation-state\"\nimport {\n    isControllingVariants as checkIsControllingVariants,\n    isVariantNode as checkIsVariantNode,\n} from \"./utils/is-controlling-variants\"\nimport { transformProps } from \"./utils/keys-transform\"\nimport { updateMotionValuesFromProps } from \"./utils/motion-values\"\nimport {\n    hasReducedMotionListener,\n    initPrefersReducedMotion,\n    prefersReducedMotion,\n} from \"./utils/reduced-motion\"\nimport { resolveVariantFromProps } from \"./utils/resolve-variants\"\n\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n] as const\n\n/**\n * Static feature definitions - can be injected by framework layer\n */\nlet featureDefinitions: Partial<FeatureDefinitions> = {}\n\n/**\n * Set feature definitions for all VisualElements.\n * This should be called by the framework layer (e.g., framer-motion) during initialization.\n */\nexport function setFeatureDefinitions(\n    definitions: Partial<FeatureDefinitions>\n) {\n    featureDefinitions = definitions\n}\n\n/**\n * Get the current feature definitions\n */\nexport function getFeatureDefinitions(): Partial<FeatureDefinitions> {\n    return featureDefinitions\n}\n\n/**\n * Motion style type - a subset of CSS properties that can contain motion values\n */\nexport type MotionStyle = {\n    [K: string]: AnyResolvedKeyframe | MotionValue | undefined\n}\n\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nexport abstract class VisualElement<\n    Instance = unknown,\n    RenderState = unknown,\n    Options extends {} = {}\n> {\n    /**\n     * VisualElements are arranged in trees mirroring that of the React tree.\n     * Each type of VisualElement has a unique name, to detect when we're crossing\n     * type boundaries within that tree.\n     */\n    abstract type: string\n\n    /**\n     * An `Array.sort` compatible function that will compare two Instances and\n     * compare their respective positions within the tree.\n     */\n    abstract sortInstanceNodePosition(a: Instance, b: Instance): number\n\n    /**\n     * Measure the viewport-relative bounding box of the Instance.\n     */\n    abstract measureInstanceViewportBox(\n        instance: Instance,\n        props: MotionNodeOptions & Partial<MotionConfigContextProps>\n    ): Box\n\n    /**\n     * When a value has been removed from all animation props we need to\n     * pick a target to animate back to. For instance, for HTMLElements\n     * we can look in the style prop.\n     */\n    abstract getBaseTargetFromProps(\n        props: MotionNodeOptions,\n        key: string\n    ): AnyResolvedKeyframe | undefined | MotionValue\n\n    /**\n     * When we first animate to a value we need to animate it *from* a value.\n     * Often this have been specified via the initial prop but it might be\n     * that the value needs to be read from the Instance.\n     */\n    abstract readValueFromInstance(\n        instance: Instance,\n        key: string,\n        options: Options\n    ): AnyResolvedKeyframe | null | undefined\n\n    /**\n     * When a value has been removed from the VisualElement we use this to remove\n     * it from the inherting class' unique render state.\n     */\n    abstract removeValueFromRenderState(\n        key: string,\n        renderState: RenderState\n    ): void\n\n    /**\n     * Run before a React or VisualElement render, builds the latest motion\n     * values into an Instance-specific format. For example, HTMLVisualElement\n     * will use this step to build `style` and `var` values.\n     */\n    abstract build(\n        renderState: RenderState,\n        latestValues: ResolvedValues,\n        props: MotionNodeOptions\n    ): void\n\n    /**\n     * Apply the built values to the Instance. For example, HTMLElements will have\n     * styles applied via `setProperty` and the style attribute, whereas SVGElements\n     * will have values applied to attributes.\n     */\n    abstract renderInstance(\n        instance: Instance,\n        renderState: RenderState,\n        styleProp?: MotionStyle,\n        projection?: any\n    ): void\n\n    /**\n     * This method is called when a transform property is bound to a motion value.\n     * It's currently used to measure SVG elements when a new transform property is bound.\n     */\n    onBindTransform?(): void\n\n    /**\n     * If the component child is provided as a motion value, handle subscriptions\n     * with the renderer-specific VisualElement.\n     */\n    handleChildMotionValue?(): void\n\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(\n        _props: MotionNodeOptions,\n        _prevProps: MotionNodeOptions,\n        _visualElement: VisualElement\n    ): {\n        [key: string]: MotionValue | AnyResolvedKeyframe\n    } {\n        return {}\n    }\n\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    current: Instance | null = null\n\n    /**\n     * A reference to the parent VisualElement (if exists).\n     */\n    parent: VisualElement | undefined\n\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n    children = new Set<VisualElement>()\n\n    /**\n     * A set containing the latest children of this VisualElement. This is flushed\n     * at the start of every commit. We use it to calculate the stagger delay\n     * for newly-added children.\n     */\n    enteringChildren?: Set<VisualElement>\n\n    /**\n     * The depth of this VisualElement within the overall VisualElement tree.\n     */\n    depth: number\n\n    /**\n     * The current render state of this VisualElement. Defined by inherting VisualElements.\n     */\n    renderState: RenderState\n\n    /**\n     * An object containing the latest static values for each of this VisualElement's\n     * MotionValues.\n     */\n    latestValues: ResolvedValues\n\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    isVariantNode: boolean = false\n    isControllingVariants: boolean = false\n\n    /**\n     * If this component is part of the variant tree, it should track\n     * any children that are also part of the tree. This is essentially\n     * a shadow tree to simplify logic around how to stagger over children.\n     */\n    variantChildren?: Set<VisualElement>\n\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n    shouldReduceMotion: boolean | null = null\n\n    /**\n     * Decides whether animations should be skipped for this VisualElement.\n     * Useful for E2E tests and visual regression testing.\n     */\n    shouldSkipAnimations: boolean = false\n\n    /**\n     * Normally, if a component is controlled by a parent's variants, it can\n     * rely on that ancestor to trigger animations further down the tree.\n     * However, if a component is created after its parent is mounted, the parent\n     * won't trigger that mount animation so the child needs to.\n     *\n     * TODO: This might be better replaced with a method isParentMounted\n     */\n    manuallyAnimateOnMount: boolean\n\n    /**\n     * This can be set by AnimatePresence to force components that mount\n     * at the same time as it to mount as if they have initial={false} set.\n     */\n    blockInitialAnimation: boolean\n\n    /**\n     * A reference to this VisualElement's projection node, used in layout animations.\n     */\n    projection?: any\n\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    values = new Map<string, MotionValue>()\n\n    /**\n     * The AnimationState, this is hydrated by the animation Feature.\n     */\n    animationState?: AnimationState\n\n    KeyframeResolver = KeyframeResolver\n\n    /**\n     * The options used to create this VisualElement. The Options type is defined\n     * by the inheriting VisualElement and is passed straight through to the render functions.\n     */\n    readonly options: Options\n\n    /**\n     * A reference to the latest props provided to the VisualElement's host React component.\n     */\n    props: MotionNodeOptions\n    prevProps?: MotionNodeOptions\n\n    presenceContext: PresenceContextProps | null\n    prevPresenceContext?: PresenceContextProps | null\n\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n    private features: {\n        [K in keyof FeatureDefinitions]?: Feature<Instance>\n    } = {}\n\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    private valueSubscriptions = new Map<string, VoidFunction>()\n\n    /**\n     * A reference to the ReducedMotionConfig passed to the VisualElement's host React component.\n     */\n    private reducedMotionConfig: ReducedMotionConfig | undefined\n\n    /**\n     * A reference to the skipAnimations config passed to the VisualElement's host React component.\n     */\n    private skipAnimationsConfig: boolean | undefined\n\n    /**\n     * On mount, this will be hydrated with a callback to disconnect\n     * this visual element from its parent on unmount.\n     */\n    private removeFromVariantTree: undefined | VoidFunction\n\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    private prevMotionValues: MotionStyle = {}\n\n    /**\n     * When values are removed from all animation props we need to search\n     * for a fallback value to animate to. These values are tracked in baseTarget.\n     */\n    private baseTarget: ResolvedValues\n\n    /**\n     * Create an object of the values we initially animated from (if initial prop present).\n     */\n    private initialValues: ResolvedValues\n\n    /**\n     * Track whether this element has been mounted before, to detect\n     * remounts after Suspense unmount/remount cycles.\n     */\n    private hasBeenMounted = false\n\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    private events: {\n        [key: string]: SubscriptionManager<any>\n    } = {}\n\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n    private propEventSubscriptions: {\n        [key: string]: VoidFunction\n    } = {}\n\n    constructor(\n        {\n            parent,\n            props,\n            presenceContext,\n            reducedMotionConfig,\n            skipAnimations,\n            blockInitialAnimation,\n            visualState,\n        }: VisualElementOptions<Instance, RenderState>,\n        options: Options = {} as any\n    ) {\n        const { latestValues, renderState } = visualState\n        this.latestValues = latestValues\n        this.baseTarget = { ...latestValues }\n        this.initialValues = props.initial ? { ...latestValues } : {}\n        this.renderState = renderState\n        this.parent = parent\n        this.props = props\n        this.presenceContext = presenceContext\n        this.depth = parent ? parent.depth + 1 : 0\n        this.reducedMotionConfig = reducedMotionConfig\n        this.skipAnimationsConfig = skipAnimations\n        this.options = options\n        this.blockInitialAnimation = Boolean(blockInitialAnimation)\n\n        this.isControllingVariants = checkIsControllingVariants(props)\n        this.isVariantNode = checkIsVariantNode(props)\n        if (this.isVariantNode) {\n            this.variantChildren = new Set()\n        }\n\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current)\n\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } =\n            this.scrapeMotionValuesFromProps(props, {}, this)\n\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key]\n\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key])\n            }\n        }\n    }\n\n    mount(instance: Instance) {\n        /**\n         * If this element has been mounted before (e.g. after a Suspense\n         * unmount/remount), reset motion values to their initial state\n         * so animations replay correctly from initial â†’ animate.\n         */\n        if (this.hasBeenMounted) {\n            for (const key in this.initialValues) {\n                this.values.get(key)?.jump(this.initialValues[key])\n                this.latestValues[key] = this.initialValues[key]\n            }\n        }\n\n        this.current = instance\n\n        visualElementStore.set(instance, this)\n\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance)\n        }\n\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this)\n        }\n\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value))\n\n        /**\n         * Determine reduced motion preference. Only initialize the matchMedia\n         * listener if we actually need the dynamic value (i.e., when config\n         * is neither \"never\" nor \"always\").\n         */\n        if (this.reducedMotionConfig === \"never\") {\n            this.shouldReduceMotion = false\n        } else if (this.reducedMotionConfig === \"always\") {\n            this.shouldReduceMotion = true\n        } else {\n            if (!hasReducedMotionListener.current) {\n                initPrefersReducedMotion()\n            }\n            this.shouldReduceMotion = prefersReducedMotion.current\n        }\n\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(\n                this.shouldReduceMotion !== true,\n                \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\",\n                \"reduced-motion-disabled\"\n            )\n        }\n\n        /**\n         * Set whether animations should be skipped based on the config.\n         */\n        this.shouldSkipAnimations = this.skipAnimationsConfig ?? false\n\n        this.parent?.addChild(this)\n\n        this.update(this.props, this.presenceContext)\n\n        this.hasBeenMounted = true\n    }\n\n    unmount() {\n        this.projection && this.projection.unmount()\n        cancelFrame(this.notifyUpdate)\n        cancelFrame(this.render)\n        this.valueSubscriptions.forEach((remove) => remove())\n        this.valueSubscriptions.clear()\n        this.removeFromVariantTree && this.removeFromVariantTree()\n        this.parent?.removeChild(this)\n\n        for (const key in this.events) {\n            this.events[key].clear()\n        }\n\n        for (const key in this.features) {\n            const feature = this.features[key as keyof typeof this.features]\n            if (feature) {\n                feature.unmount()\n                feature.isMounted = false\n            }\n        }\n        this.current = null\n    }\n\n    addChild(child: VisualElement) {\n        this.children.add(child)\n        this.enteringChildren ??= new Set()\n        this.enteringChildren.add(child)\n    }\n\n    removeChild(child: VisualElement) {\n        this.children.delete(child)\n        this.enteringChildren && this.enteringChildren.delete(child)\n    }\n\n    private bindToMotionValue(key: string, value: MotionValue) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)!()\n        }\n\n        if (\n            value.accelerate &&\n            acceleratedValues.has(key) &&\n            this.current instanceof HTMLElement\n        ) {\n            const { factory, keyframes, times, ease, duration } =\n                value.accelerate\n\n            const animation = new NativeAnimation({\n                element: this.current,\n                name: key,\n                keyframes,\n                times,\n                ease,\n                duration: secondsToMilliseconds(duration),\n            })\n\n            const cleanup = factory(animation)\n\n            this.valueSubscriptions.set(key, () => {\n                cleanup()\n                animation.cancel()\n            })\n            return\n        }\n\n        const valueIsTransform = transformProps.has(key)\n\n        if (valueIsTransform && this.onBindTransform) {\n            this.onBindTransform()\n        }\n\n        const removeOnChange = value.on(\n            \"change\",\n            (latestValue: AnyResolvedKeyframe) => {\n                this.latestValues[key] = latestValue\n\n                this.props.onUpdate && frame.preRender(this.notifyUpdate)\n\n                if (valueIsTransform && this.projection) {\n                    this.projection.isTransformDirty = true\n                }\n\n                this.scheduleRender()\n            }\n        )\n\n        let removeSyncCheck: VoidFunction | void\n        if (\n            typeof window !== \"undefined\" &&\n            (window as any).MotionCheckAppearSync\n        ) {\n            removeSyncCheck = (window as any).MotionCheckAppearSync(\n                this,\n                key,\n                value\n            )\n        }\n\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange()\n            if (removeSyncCheck) removeSyncCheck()\n            if (value.owner) value.stop()\n        })\n    }\n\n    sortNodePosition(other: VisualElement<Instance>) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (\n            !this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type\n        ) {\n            return 0\n        }\n\n        return this.sortInstanceNodePosition(\n            this.current as Instance,\n            other.current as Instance\n        )\n    }\n\n    updateFeatures() {\n        let key: keyof typeof featureDefinitions = \"animation\"\n\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key]\n\n            if (!featureDefinition) continue\n\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition\n\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (\n                !this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)\n            ) {\n                this.features[key] = new FeatureConstructor(this) as any\n            }\n\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key]!\n                if (feature.isMounted) {\n                    feature.update()\n                } else {\n                    feature.mount()\n                    feature.isMounted = true\n                }\n            }\n        }\n    }\n\n    notifyUpdate = () => this.notify(\"Update\", this.latestValues)\n\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props)\n    }\n\n    render = () => {\n        if (!this.current) return\n        this.triggerBuild()\n        this.renderInstance(\n            this.current,\n            this.renderState,\n            (this.props as any).style,\n            this.projection\n        )\n    }\n\n    private renderScheduledAt = 0.0\n    scheduleRender = () => {\n        const now = time.now()\n        if (this.renderScheduledAt < now) {\n            this.renderScheduledAt = now\n            frame.render(this.render, false, true)\n        }\n    }\n\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox()\n    }\n\n    getStaticValue(key: string) {\n        return this.latestValues[key]\n    }\n\n    setStaticValue(key: string, value: AnyResolvedKeyframe) {\n        this.latestValues[key] = value\n    }\n\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(\n        props: MotionNodeOptions,\n        presenceContext: PresenceContextProps | null\n    ) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender()\n        }\n\n        this.prevProps = this.props\n        this.props = props\n\n        this.prevPresenceContext = this.presenceContext\n        this.presenceContext = presenceContext\n\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i]\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]()\n                delete this.propEventSubscriptions[key]\n            }\n\n            const listenerName = (\"on\" + key) as keyof typeof props\n            const listener = props[listenerName]\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key as any, listener)\n            }\n        }\n\n        this.prevMotionValues = updateMotionValuesFromProps(\n            this,\n            this.scrapeMotionValuesFromProps(props, this.prevProps || {}, this),\n            this.prevMotionValues\n        )\n\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue()\n        }\n    }\n\n    getProps() {\n        return this.props\n    }\n\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name: string) {\n        return this.props.variants ? this.props.variants[name] : undefined\n    }\n\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition\n    }\n\n    getTransformPagePoint() {\n        return (this.props as any).transformPagePoint\n    }\n\n    getClosestVariantNode(): VisualElement | undefined {\n        return this.isVariantNode\n            ? this\n            : this.parent\n            ? this.parent.getClosestVariantNode()\n            : undefined\n    }\n\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child: VisualElement) {\n        const closestVariantNode = this.getClosestVariantNode()\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child)\n            return () => closestVariantNode.variantChildren!.delete(child)\n        }\n    }\n\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key: string, value: MotionValue) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key)\n\n        if (value !== existingValue) {\n            if (existingValue) this.removeValue(key)\n            this.bindToMotionValue(key, value)\n            this.values.set(key, value)\n            this.latestValues[key] = value.get()\n        }\n    }\n\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key: string) {\n        this.values.delete(key)\n        const unsubscribe = this.valueSubscriptions.get(key)\n        if (unsubscribe) {\n            unsubscribe()\n            this.valueSubscriptions.delete(key)\n        }\n        delete this.latestValues[key]\n        this.removeValueFromRenderState(key, this.renderState)\n    }\n\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key: string) {\n        return this.values.has(key)\n    }\n\n    /**\n     * Get a motion value for this key. If called with a default\n     * value, we'll create one if none exists.\n     */\n    getValue(key: string): MotionValue | undefined\n    getValue(key: string, defaultValue: AnyResolvedKeyframe | null): MotionValue\n    getValue(\n        key: string,\n        defaultValue?: AnyResolvedKeyframe | null\n    ): MotionValue | undefined {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key]\n        }\n\n        let value = this.values.get(key)\n\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(\n                defaultValue === null ? undefined : defaultValue,\n                { owner: this }\n            )\n            this.addValue(key, value)\n        }\n\n        return value\n    }\n\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key: string, target?: AnyResolvedKeyframe | null) {\n        let value =\n            this.latestValues[key] !== undefined || !this.current\n                ? this.latestValues[key]\n                : this.getBaseTargetFromProps(this.props, key) ??\n                  this.readValueFromInstance(this.current, key, this.options)\n\n        if (value !== undefined && value !== null) {\n            if (\n                typeof value === \"string\" &&\n                (isNumericalString(value) || isZeroValueString(value))\n            ) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value)\n            } else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target as string)\n            }\n\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value)\n        }\n\n        return isMotionValue(value) ? value.get() : value\n    }\n\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key: string, value: AnyResolvedKeyframe) {\n        this.baseTarget[key] = value\n    }\n\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key: string): ResolvedValues[string] | undefined | null {\n        const { initial } = this.props\n\n        let valueFromInitial: ResolvedValues[string] | undefined | null\n\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(\n                this.props,\n                initial as any,\n                this.presenceContext?.custom\n            )\n            if (variant) {\n                valueFromInitial = variant[\n                    key as keyof typeof variant\n                ] as string\n            }\n        }\n\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial\n        }\n\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key)\n        if (target !== undefined && !isMotionValue(target)) return target\n\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key]\n    }\n\n    on<EventName extends keyof VisualElementEventCallbacks>(\n        eventName: EventName,\n        callback: VisualElementEventCallbacks[EventName]\n    ) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager()\n        }\n\n        return this.events[eventName].add(callback)\n    }\n\n    notify<EventName extends keyof VisualElementEventCallbacks>(\n        eventName: EventName,\n        ...args: any\n    ) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args)\n        }\n    }\n\n    scheduleRenderMicrotask() {\n        microtask.render(this.render)\n    }\n}\n"]},"metadata":{},"sourceType":"module"}