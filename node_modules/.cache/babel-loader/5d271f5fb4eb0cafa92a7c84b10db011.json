{"ast":null,"code":"import { mixNumber } from '../../utils/mix/number.mjs';\nimport { hasTransform } from '../utils/has-transform.mjs';\n/**\n * Scales a point based on a factor and an originPoint\n */\n\nfunction scalePoint(point, scale, originPoint) {\n  const distanceFromOrigin = point - originPoint;\n  const scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\n\n\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\n\n\nfunction applyAxisDelta(axis) {\n  let translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let originPoint = arguments.length > 3 ? arguments[3] : undefined;\n  let boxScale = arguments.length > 4 ? arguments[4] : undefined;\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\n\n\nfunction applyBoxDelta(box, _ref) {\n  let {\n    x,\n    y\n  } = _ref;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\n\nfunction applyTreeDeltas(box, treeScale, treePath) {\n  let isSharedTransition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const treeLength = treePath.length;\n  if (!treeLength) return; // Reset the treeScale\n\n  treeScale.x = treeScale.y = 1;\n  let node;\n  let delta;\n\n  for (let i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.projectionDelta;\n    /**\n     * TODO: Prefer to remove this, but currently we have motion components with\n     * display: contents in Framer.\n     */\n\n    const {\n      visualElement\n    } = node.options;\n\n    if (visualElement && visualElement.props.style && visualElement.props.style.display === \"contents\") {\n      continue;\n    }\n\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, {\n        x: -node.scroll.offset.x,\n        y: -node.scroll.offset.y\n      });\n    }\n\n    if (delta) {\n      // Incoporate each ancestor's scale into a cumulative treeScale for this component\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale; // Apply each ancestor's calculated delta into this component's recorded layout box\n\n      applyBoxDelta(box, delta);\n    }\n\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n  /**\n   * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n   * This will help reduce useless scales getting rendered.\n   */\n\n\n  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {\n    treeScale.x = 1.0;\n  }\n\n  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {\n    treeScale.y = 1.0;\n  }\n}\n\nfunction translateAxis(axis, distance) {\n  axis.min = axis.min + distance;\n  axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\n\n\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale) {\n  let axisOrigin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n  const originPoint = mixNumber(axis.min, axis.max, axisOrigin); // Apply the axis delta to the final axis\n\n  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\n\n\nfunction transformBox(box, transform) {\n  transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n  transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };","map":{"version":3,"mappings":"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","names":["scalePoint","point","scale","originPoint","distanceFromOrigin","scaled","applyPointDelta","translate","boxScale","undefined","axis","min","max","applyBoxDelta","box","x","y","applyAxisDelta","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","length","node","delta","i","projectionDelta","visualElement","options","props","style","display","layoutScroll","scroll","root","transformBox","offset","hasTransform","latestValues","distance","axisTranslate","axisScale","axisOrigin","mixNumber","transform","transformAxis","scaleX","originX","scaleY","originY"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\projection\\geometry\\delta-apply.ts"],"sourcesContent":["import { Axis, Box, Delta, Point } from \"motion-utils\"\nimport { mixNumber } from \"../../utils/mix/number\"\nimport { ResolvedValues } from \"../../render/types\"\nimport { hasTransform } from \"../utils/has-transform\"\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nexport function scalePoint(point: number, scale: number, originPoint: number) {\n    const distanceFromOrigin = point - originPoint\n    const scaled = scale * distanceFromOrigin\n    return originPoint + scaled\n}\n\n/**\n * Applies a translate/scale delta to a point\n */\nexport function applyPointDelta(\n    point: number,\n    translate: number,\n    scale: number,\n    originPoint: number,\n    boxScale?: number\n): number {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint)\n    }\n\n    return scalePoint(point, scale, originPoint) + translate\n}\n\n/**\n * Applies a translate/scale delta to an axis\n */\nexport function applyAxisDelta(\n    axis: Axis,\n    translate: number = 0,\n    scale: number = 1,\n    originPoint: number,\n    boxScale?: number\n): void {\n    axis.min = applyPointDelta(\n        axis.min,\n        translate,\n        scale,\n        originPoint,\n        boxScale\n    )\n\n    axis.max = applyPointDelta(\n        axis.max,\n        translate,\n        scale,\n        originPoint,\n        boxScale\n    )\n}\n\n/**\n * Applies a translate/scale delta to a box\n */\nexport function applyBoxDelta(box: Box, { x, y }: Delta): void {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint)\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint)\n}\n\nconst TREE_SCALE_SNAP_MIN = 0.999999999999\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001\n\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nexport function applyTreeDeltas(\n    box: Box,\n    treeScale: Point,\n    treePath: any[],\n    isSharedTransition: boolean = false\n) {\n    const treeLength = treePath.length\n    if (!treeLength) return\n\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1\n\n    let node: any\n    let delta: Delta | undefined\n\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i]\n        delta = node.projectionDelta\n\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const { visualElement } = node.options\n        if (\n            visualElement &&\n            visualElement.props.style &&\n            visualElement.props.style.display === \"contents\"\n        ) {\n            continue\n        }\n\n        if (\n            isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root\n        ) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            })\n        }\n\n        if (delta) {\n            // Incoporate each ancestor's scale into a cumulative treeScale for this component\n            treeScale.x *= delta.x.scale\n            treeScale.y *= delta.y.scale\n\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta)\n        }\n\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues)\n        }\n    }\n\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (\n        treeScale.x < TREE_SCALE_SNAP_MAX &&\n        treeScale.x > TREE_SCALE_SNAP_MIN\n    ) {\n        treeScale.x = 1.0\n    }\n    if (\n        treeScale.y < TREE_SCALE_SNAP_MAX &&\n        treeScale.y > TREE_SCALE_SNAP_MIN\n    ) {\n        treeScale.y = 1.0\n    }\n}\n\nexport function translateAxis(axis: Axis, distance: number) {\n    axis.min = axis.min + distance\n    axis.max = axis.max + distance\n}\n\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nexport function transformAxis(\n    axis: Axis,\n    axisTranslate?: number,\n    axisScale?: number,\n    boxScale?: number,\n    axisOrigin: number = 0.5\n): void {\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin)\n\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale)\n}\n\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nexport function transformBox(box: Box, transform: ResolvedValues) {\n    transformAxis(\n        box.x,\n        transform.x as number,\n        transform.scaleX as number,\n        transform.scale as number,\n        transform.originX as number\n    )\n    transformAxis(\n        box.y,\n        transform.y as number,\n        transform.scaleY as number,\n        transform.scale as number,\n        transform.originY as number\n    )\n}\n"]},"metadata":{},"sourceType":"module"}