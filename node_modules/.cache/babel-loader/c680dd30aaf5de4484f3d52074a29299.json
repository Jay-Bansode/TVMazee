{"ast":null,"code":"import { createBox, frame, eachAxis, measurePageBox, convertBoxToBoundingBox, convertBoundingBoxToBox, addValueToWillChange, animateMotionValue, mixNumber, isElementTextInput, addDomEvent, setDragLock, percent, calcLength, resize } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { PanSession } from '../pan/PanSession.mjs';\nimport { applyConstraints, calcRelativeConstraints, resolveDragElastic, rebaseAxisConstraints, calcViewportConstraints, calcOrigin, defaultElastic } from './utils/constraints.mjs';\nconst elementDragControls = new WeakMap();\n\nclass VisualElementDragControls {\n  constructor(visualElement) {\n    this.openDragLock = null;\n    this.isDragging = false;\n    this.currentDirection = null;\n    this.originPoint = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * The permitted boundaries of travel, in pixels.\n     */\n\n    this.constraints = false;\n    this.hasMutatedConstraints = false;\n    /**\n     * The per-axis resolved elastic values.\n     */\n\n    this.elastic = createBox();\n    /**\n     * The latest pointer event. Used as fallback when the `cancel` and `stop` functions are called without arguments.\n     */\n\n    this.latestPointerEvent = null;\n    /**\n     * The latest pan info. Used as fallback when the `cancel` and `stop` functions are called without arguments.\n     */\n\n    this.latestPanInfo = null;\n    this.visualElement = visualElement;\n  }\n\n  start(originEvent) {\n    let {\n      snapToCursor = false,\n      distanceThreshold\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * Don't start dragging if this component is exiting\n     */\n    const {\n      presenceContext\n    } = this.visualElement;\n    if (presenceContext && presenceContext.isPresent === false) return;\n\n    const onSessionStart = event => {\n      if (snapToCursor) {\n        this.snapToCursor(extractEventInfo(event).point);\n      }\n\n      this.stopAnimation();\n    };\n\n    const onStart = (event, info) => {\n      // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n      const {\n        drag,\n        dragPropagation,\n        onDragStart\n      } = this.getProps();\n\n      if (drag && !dragPropagation) {\n        if (this.openDragLock) this.openDragLock();\n        this.openDragLock = setDragLock(drag); // If we don 't have the lock, don't start dragging\n\n        if (!this.openDragLock) return;\n      }\n\n      this.latestPointerEvent = event;\n      this.latestPanInfo = info;\n      this.isDragging = true;\n      this.currentDirection = null;\n      this.resolveConstraints();\n\n      if (this.visualElement.projection) {\n        this.visualElement.projection.isAnimationBlocked = true;\n        this.visualElement.projection.target = undefined;\n      }\n      /**\n       * Record gesture origin and pointer offset\n       */\n\n\n      eachAxis(axis => {\n        let current = this.getAxisMotionValue(axis).get() || 0;\n        /**\n         * If the MotionValue is a percentage value convert to px\n         */\n\n        if (percent.test(current)) {\n          const {\n            projection\n          } = this.visualElement;\n\n          if (projection && projection.layout) {\n            const measuredAxis = projection.layout.layoutBox[axis];\n\n            if (measuredAxis) {\n              const length = calcLength(measuredAxis);\n              current = length * (parseFloat(current) / 100);\n            }\n          }\n        }\n\n        this.originPoint[axis] = current;\n      }); // Fire onDragStart event\n\n      if (onDragStart) {\n        frame.update(() => onDragStart(event, info), false, true);\n      }\n\n      addValueToWillChange(this.visualElement, \"transform\");\n      const {\n        animationState\n      } = this.visualElement;\n      animationState && animationState.setActive(\"whileDrag\", true);\n    };\n\n    const onMove = (event, info) => {\n      this.latestPointerEvent = event;\n      this.latestPanInfo = info;\n      const {\n        dragPropagation,\n        dragDirectionLock,\n        onDirectionLock,\n        onDrag\n      } = this.getProps(); // If we didn't successfully receive the gesture lock, early return.\n\n      if (!dragPropagation && !this.openDragLock) return;\n      const {\n        offset\n      } = info; // Attempt to detect drag direction if directionLock is true\n\n      if (dragDirectionLock && this.currentDirection === null) {\n        this.currentDirection = getCurrentDirection(offset); // If we've successfully set a direction, notify listener\n\n        if (this.currentDirection !== null) {\n          onDirectionLock && onDirectionLock(this.currentDirection);\n        }\n\n        return;\n      } // Update each point with the latest position\n\n\n      this.updateAxis(\"x\", info.point, offset);\n      this.updateAxis(\"y\", info.point, offset);\n      /**\n       * Ideally we would leave the renderer to fire naturally at the end of\n       * this frame but if the element is about to change layout as the result\n       * of a re-render we want to ensure the browser can read the latest\n       * bounding box to ensure the pointer and element don't fall out of sync.\n       */\n\n      this.visualElement.render();\n      /**\n       * This must fire after the render call as it might trigger a state\n       * change which itself might trigger a layout update.\n       */\n\n      if (onDrag) {\n        frame.update(() => onDrag(event, info), false, true);\n      }\n    };\n\n    const onSessionEnd = (event, info) => {\n      this.latestPointerEvent = event;\n      this.latestPanInfo = info;\n      this.stop(event, info);\n      this.latestPointerEvent = null;\n      this.latestPanInfo = null;\n    };\n\n    const resumeAnimation = () => {\n      const {\n        dragSnapToOrigin: snap\n      } = this.getProps();\n\n      if (snap || this.constraints) {\n        this.startAnimation({\n          x: 0,\n          y: 0\n        });\n      }\n    };\n\n    const {\n      dragSnapToOrigin\n    } = this.getProps();\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart,\n      onStart,\n      onMove,\n      onSessionEnd,\n      resumeAnimation\n    }, {\n      transformPagePoint: this.visualElement.getTransformPagePoint(),\n      dragSnapToOrigin,\n      distanceThreshold,\n      contextWindow: getContextWindow(this.visualElement),\n      element: this.visualElement.current\n    });\n  }\n  /**\n   * @internal\n   */\n\n\n  stop(event, panInfo) {\n    const finalEvent = event || this.latestPointerEvent;\n    const finalPanInfo = panInfo || this.latestPanInfo;\n    const isDragging = this.isDragging;\n    this.cancel();\n    if (!isDragging || !finalPanInfo || !finalEvent) return;\n    const {\n      velocity\n    } = finalPanInfo;\n    this.startAnimation(velocity);\n    const {\n      onDragEnd\n    } = this.getProps();\n\n    if (onDragEnd) {\n      frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  cancel() {\n    this.isDragging = false;\n    const {\n      projection,\n      animationState\n    } = this.visualElement;\n\n    if (projection) {\n      projection.isAnimationBlocked = false;\n    }\n\n    this.endPanSession();\n    const {\n      dragPropagation\n    } = this.getProps();\n\n    if (!dragPropagation && this.openDragLock) {\n      this.openDragLock();\n      this.openDragLock = null;\n    }\n\n    animationState && animationState.setActive(\"whileDrag\", false);\n  }\n  /**\n   * Clean up the pan session without modifying other drag state.\n   * This is used during unmount to ensure event listeners are removed\n   * without affecting projection animations or drag locks.\n   * @internal\n   */\n\n\n  endPanSession() {\n    this.panSession && this.panSession.end();\n    this.panSession = undefined;\n  }\n\n  updateAxis(axis, _point, offset) {\n    const {\n      drag\n    } = this.getProps(); // If we're not dragging this axis, do an early return.\n\n    if (!offset || !shouldDrag(axis, drag, this.currentDirection)) return;\n    const axisValue = this.getAxisMotionValue(axis);\n    let next = this.originPoint[axis] + offset[axis]; // Apply constraints\n\n    if (this.constraints && this.constraints[axis]) {\n      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n    }\n\n    axisValue.set(next);\n  }\n\n  resolveConstraints() {\n    const {\n      dragConstraints,\n      dragElastic\n    } = this.getProps();\n    const layout = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : this.visualElement.projection?.layout;\n    const prevConstraints = this.constraints;\n\n    if (dragConstraints && isRefObject(dragConstraints)) {\n      if (!this.constraints) {\n        this.constraints = this.resolveRefConstraints();\n      }\n    } else {\n      if (dragConstraints && layout) {\n        this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n      } else {\n        this.constraints = false;\n      }\n    }\n\n    this.elastic = resolveDragElastic(dragElastic);\n    /**\n     * If we're outputting to external MotionValues, we want to rebase the measured constraints\n     * from viewport-relative to component-relative. This only applies to relative (non-ref)\n     * constraints, as ref-based constraints from calcViewportConstraints are already in the\n     * correct coordinate space for the motion value transform offset.\n     */\n\n    if (prevConstraints !== this.constraints && !isRefObject(dragConstraints) && layout && this.constraints && !this.hasMutatedConstraints) {\n      eachAxis(axis => {\n        if (this.constraints !== false && this.getAxisMotionValue(axis)) {\n          this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n        }\n      });\n    }\n  }\n\n  resolveRefConstraints() {\n    const {\n      dragConstraints: constraints,\n      onMeasureDragConstraints\n    } = this.getProps();\n    if (!constraints || !isRefObject(constraints)) return false;\n    const constraintsElement = constraints.current;\n    invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\", \"drag-constraints-ref\");\n    const {\n      projection\n    } = this.visualElement; // TODO\n\n    if (!projection || !projection.layout) return false;\n    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n    /**\n     * If there's an onMeasureDragConstraints listener we call it and\n     * if different constraints are returned, set constraints to that\n     */\n\n    if (onMeasureDragConstraints) {\n      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n      this.hasMutatedConstraints = !!userConstraints;\n\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToBox(userConstraints);\n      }\n    }\n\n    return measuredConstraints;\n  }\n\n  startAnimation(velocity) {\n    const {\n      drag,\n      dragMomentum,\n      dragElastic,\n      dragTransition,\n      dragSnapToOrigin,\n      onDragTransitionEnd\n    } = this.getProps();\n    const constraints = this.constraints || {};\n    const momentumAnimations = eachAxis(axis => {\n      if (!shouldDrag(axis, drag, this.currentDirection)) {\n        return;\n      }\n\n      let transition = constraints && constraints[axis] || {};\n      if (dragSnapToOrigin) transition = {\n        min: 0,\n        max: 0\n      };\n      /**\n       * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n       * of spring animations so we should look into adding a disable spring option to `inertia`.\n       * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n       * using the value of `dragElastic`.\n       */\n\n      const bounceStiffness = dragElastic ? 200 : 1000000;\n      const bounceDamping = dragElastic ? 40 : 10000000;\n      const inertia = {\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness,\n        bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10,\n        ...dragTransition,\n        ...transition\n      }; // If we're not animating on an externally-provided `MotionValue` we can use the\n      // component's animation controls which will handle interactions with whileHover (etc),\n      // otherwise we just have to animate the `MotionValue` itself.\n\n      return this.startAxisValueAnimation(axis, inertia);\n    }); // Run all animations and then resolve the new drag constraints.\n\n    return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n  }\n\n  startAxisValueAnimation(axis, transition) {\n    const axisValue = this.getAxisMotionValue(axis);\n    addValueToWillChange(this.visualElement, axis);\n    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));\n  }\n\n  stopAnimation() {\n    eachAxis(axis => this.getAxisMotionValue(axis).stop());\n  }\n  /**\n   * Drag works differently depending on which props are provided.\n   *\n   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n   * - Otherwise, we apply the delta to the x/y motion values.\n   */\n\n\n  getAxisMotionValue(axis) {\n    const dragKey = `_drag${axis.toUpperCase()}`;\n    const props = this.visualElement.getProps();\n    const externalMotionValue = props[dragKey];\n    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : undefined) || 0);\n  }\n\n  snapToCursor(point) {\n    eachAxis(axis => {\n      const {\n        drag\n      } = this.getProps(); // If we're not dragging this axis, do an early return.\n\n      if (!shouldDrag(axis, drag, this.currentDirection)) return;\n      const {\n        projection\n      } = this.visualElement;\n      const axisValue = this.getAxisMotionValue(axis);\n\n      if (projection && projection.layout) {\n        const {\n          min,\n          max\n        } = projection.layout.layoutBox[axis];\n        /**\n         * The layout measurement includes the current transform value,\n         * so we need to add it back to get the correct snap position.\n         * This fixes an issue where elements with initial coordinates\n         * would snap to the wrong position on the first drag.\n         */\n\n        const current = axisValue.get() || 0;\n        axisValue.set(point[axis] - mixNumber(min, max, 0.5) + current);\n      }\n    });\n  }\n  /**\n   * When the viewport resizes we want to check if the measured constraints\n   * have changed and, if so, reposition the element within those new constraints\n   * relative to where it was before the resize.\n   */\n\n\n  scalePositionWithinConstraints() {\n    if (!this.visualElement.current) return;\n    const {\n      drag,\n      dragConstraints\n    } = this.getProps();\n    const {\n      projection\n    } = this.visualElement;\n    if (!isRefObject(dragConstraints) || !projection || !this.constraints) return;\n    /**\n     * Stop current animations as there can be visual glitching if we try to do\n     * this mid-animation\n     */\n\n    this.stopAnimation();\n    /**\n     * Record the relative position of the dragged element relative to the\n     * constraints box and save as a progress value.\n     */\n\n    const boxProgress = {\n      x: 0,\n      y: 0\n    };\n    eachAxis(axis => {\n      const axisValue = this.getAxisMotionValue(axis);\n\n      if (axisValue && this.constraints !== false) {\n        const latest = axisValue.get();\n        boxProgress[axis] = calcOrigin({\n          min: latest,\n          max: latest\n        }, this.constraints[axis]);\n      }\n    });\n    /**\n     * Update the layout of this element and resolve the latest drag constraints\n     */\n\n    const {\n      transformTemplate\n    } = this.visualElement.getProps();\n    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n    projection.root && projection.root.updateScroll();\n    projection.updateLayout();\n    /**\n     * Reset constraints so resolveConstraints() will recalculate them\n     * with the freshly measured layout rather than returning the cached value.\n     */\n\n    this.constraints = false;\n    this.resolveConstraints();\n    /**\n     * For each axis, calculate the current progress of the layout axis\n     * within the new constraints.\n     */\n\n    eachAxis(axis => {\n      if (!shouldDrag(axis, drag, null)) return;\n      /**\n       * Calculate a new transform based on the previous box progress\n       */\n\n      const axisValue = this.getAxisMotionValue(axis);\n      const {\n        min,\n        max\n      } = this.constraints[axis];\n      axisValue.set(mixNumber(min, max, boxProgress[axis]));\n    });\n    /**\n     * Flush the updated transform to the DOM synchronously to prevent\n     * a visual flash at the element's CSS layout position (0,0) when\n     * the transform was stripped for measurement.\n     */\n\n    this.visualElement.render();\n  }\n\n  addListeners() {\n    if (!this.visualElement.current) return;\n    elementDragControls.set(this.visualElement, this);\n    const element = this.visualElement.current;\n    /**\n     * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n     */\n\n    const stopPointerListener = addPointerEvent(element, \"pointerdown\", event => {\n      const {\n        drag,\n        dragListener = true\n      } = this.getProps();\n      const target = event.target;\n      /**\n       * Only block drag if clicking on a text input child element\n       * (input, textarea, select, contenteditable) where users might\n       * want to select text or interact with the control.\n       *\n       * Buttons and links don't block drag since they don't have\n       * click-and-move actions of their own.\n       */\n\n      const isClickingTextInputChild = target !== element && isElementTextInput(target);\n\n      if (drag && dragListener && !isClickingTextInputChild) {\n        this.start(event);\n      }\n    });\n    /**\n     * If using ref-based constraints, observe both the draggable element\n     * and the constraint container for size changes via ResizeObserver.\n     * Setup is deferred because dragConstraints.current is null when\n     * addListeners first runs (React hasn't committed the ref yet).\n     */\n\n    let stopResizeObservers;\n\n    const measureDragConstraints = () => {\n      const {\n        dragConstraints\n      } = this.getProps();\n\n      if (isRefObject(dragConstraints) && dragConstraints.current) {\n        this.constraints = this.resolveRefConstraints();\n\n        if (!stopResizeObservers) {\n          stopResizeObservers = startResizeObservers(element, dragConstraints.current, () => this.scalePositionWithinConstraints());\n        }\n      }\n    };\n\n    const {\n      projection\n    } = this.visualElement;\n    const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n\n    if (projection && !projection.layout) {\n      projection.root && projection.root.updateScroll();\n      projection.updateLayout();\n    }\n\n    frame.read(measureDragConstraints);\n    /**\n     * Attach a window resize listener to scale the draggable target within its defined\n     * constraints as the window resizes.\n     */\n\n    const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\n    /**\n     * If the element's layout changes, calculate the delta and apply that to\n     * the drag gesture's origin point.\n     */\n\n    const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", _ref => {\n      let {\n        delta,\n        hasLayoutChanged\n      } = _ref;\n\n      if (this.isDragging && hasLayoutChanged) {\n        eachAxis(axis => {\n          const motionValue = this.getAxisMotionValue(axis);\n          if (!motionValue) return;\n          this.originPoint[axis] += delta[axis].translate;\n          motionValue.set(motionValue.get() + delta[axis].translate);\n        });\n        this.visualElement.render();\n      }\n    });\n    return () => {\n      stopResizeListener();\n      stopPointerListener();\n      stopMeasureLayoutListener();\n      stopLayoutUpdateListener && stopLayoutUpdateListener();\n      stopResizeObservers && stopResizeObservers();\n    };\n  }\n\n  getProps() {\n    const props = this.visualElement.getProps();\n    const {\n      drag = false,\n      dragDirectionLock = false,\n      dragPropagation = false,\n      dragConstraints = false,\n      dragElastic = defaultElastic,\n      dragMomentum = true\n    } = props;\n    return { ...props,\n      drag,\n      dragDirectionLock,\n      dragPropagation,\n      dragConstraints,\n      dragElastic,\n      dragMomentum\n    };\n  }\n\n}\n\nfunction skipFirstCall(callback) {\n  let isFirst = true;\n  return () => {\n    if (isFirst) {\n      isFirst = false;\n      return;\n    }\n\n    callback();\n  };\n}\n\nfunction startResizeObservers(element, constraintsElement, onResize) {\n  const stopElement = resize(element, skipFirstCall(onResize));\n  const stopContainer = resize(constraintsElement, skipFirstCall(onResize));\n  return () => {\n    stopElement();\n    stopContainer();\n  };\n}\n\nfunction shouldDrag(direction, drag, currentDirection) {\n  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\n\n\nfunction getCurrentDirection(offset) {\n  let lockThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  let direction = null;\n\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n\n  return direction;\n}\n\nexport { VisualElementDragControls, elementDragControls };","map":{"version":3,"mappings":"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","names":["WeakMap","VisualElementDragControls","constructor","visualElement","openDragLock","isDragging","currentDirection","originPoint","x","y","constraints","hasMutatedConstraints","elastic","createBox","latestPointerEvent","latestPanInfo","start","originEvent","snapToCursor","distanceThreshold","presenceContext","isPresent","onSessionStart","event","extractEventInfo","point","stopAnimation","onStart","info","drag","dragPropagation","onDragStart","getProps","setDragLock","resolveConstraints","projection","isAnimationBlocked","target","undefined","eachAxis","axis","current","getAxisMotionValue","get","percent","test","layout","measuredAxis","layoutBox","length","calcLength","parseFloat","frame","update","addValueToWillChange","animationState","setActive","onMove","dragDirectionLock","onDirectionLock","onDrag","offset","getCurrentDirection","updateAxis","render","onSessionEnd","stop","resumeAnimation","dragSnapToOrigin","snap","startAnimation","panSession","PanSession","transformPagePoint","getTransformPagePoint","contextWindow","getContextWindow","element","panInfo","finalEvent","finalPanInfo","cancel","velocity","onDragEnd","postRender","endPanSession","end","_point","shouldDrag","axisValue","next","applyConstraints","set","dragConstraints","dragElastic","measure","prevConstraints","isRefObject","resolveRefConstraints","calcRelativeConstraints","resolveDragElastic","rebaseAxisConstraints","onMeasureDragConstraints","constraintsElement","invariant","constraintsBox","measurePageBox","root","measuredConstraints","calcViewportConstraints","userConstraints","convertBoxToBoundingBox","convertBoundingBoxToBox","dragMomentum","dragTransition","onDragTransitionEnd","momentumAnimations","transition","min","max","bounceStiffness","bounceDamping","inertia","type","timeConstant","restDelta","restSpeed","startAxisValueAnimation","Promise","all","then","animateMotionValue","dragKey","toUpperCase","props","externalMotionValue","getValue","initial","mixNumber","scalePositionWithinConstraints","boxProgress","latest","calcOrigin","transformTemplate","style","transform","updateScroll","updateLayout","addListeners","elementDragControls","stopPointerListener","addPointerEvent","dragListener","isClickingTextInputChild","isElementTextInput","stopResizeObservers","measureDragConstraints","startResizeObservers","stopMeasureLayoutListener","addEventListener","read","stopResizeListener","addDomEvent","window","stopLayoutUpdateListener","delta","hasLayoutChanged","motionValue","translate","defaultElastic","skipFirstCall","callback","isFirst","onResize","stopElement","resize","stopContainer","direction","lockThreshold","Math","abs"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\gestures\\drag\\VisualElementDragControls.ts"],"sourcesContent":["import {\n    addValueToWillChange,\n    animateMotionValue,\n    calcLength,\n    convertBoundingBoxToBox,\n    convertBoxToBoundingBox,\n    createBox,\n    eachAxis,\n    frame,\n    isElementTextInput,\n    measurePageBox,\n    mixNumber,\n    PanInfo,\n    percent,\n    ResolvedConstraints,\n    resize,\n    setDragLock,\n    Transition,\n    type VisualElement,\n} from \"motion-dom\"\nimport { Axis, Point, invariant } from \"motion-utils\"\nimport { addDomEvent, type LayoutUpdateData } from \"motion-dom\"\nimport { addPointerEvent } from \"../../events/add-pointer-event\"\nimport { extractEventInfo } from \"../../events/event-info\"\nimport { MotionProps } from \"../../motion/types\"\nimport { getContextWindow } from \"../../utils/get-context-window\"\nimport { isRefObject } from \"../../utils/is-ref-object\"\nimport { PanSession } from \"../pan/PanSession\"\nimport {\n    applyConstraints,\n    calcOrigin,\n    calcRelativeConstraints,\n    calcViewportConstraints,\n    defaultElastic,\n    rebaseAxisConstraints,\n    resolveDragElastic,\n} from \"./utils/constraints\"\n\nexport const elementDragControls = new WeakMap<\n    VisualElement,\n    VisualElementDragControls\n>()\n\nexport interface DragControlOptions {\n    /**\n     * This distance after which dragging starts and a direction is locked in.\n     *\n     * @public\n     */\n    distanceThreshold?: number\n\n    /**\n     * Whether to immediately snap to the cursor when dragging starts.\n     *\n     * @public\n     */\n    snapToCursor?: boolean\n}\n\ntype DragDirection = \"x\" | \"y\"\n\nexport class VisualElementDragControls {\n    private visualElement: VisualElement<HTMLElement>\n\n    private panSession?: PanSession\n\n    private openDragLock: VoidFunction | null = null\n\n    isDragging = false\n    private currentDirection: DragDirection | null = null\n\n    private originPoint: Point = { x: 0, y: 0 }\n\n    /**\n     * The permitted boundaries of travel, in pixels.\n     */\n    private constraints: ResolvedConstraints | false = false\n\n    private hasMutatedConstraints = false\n\n    /**\n     * The per-axis resolved elastic values.\n     */\n    private elastic = createBox()\n\n    /**\n     * The latest pointer event. Used as fallback when the `cancel` and `stop` functions are called without arguments.\n     */\n    private latestPointerEvent: PointerEvent | null = null\n\n    /**\n     * The latest pan info. Used as fallback when the `cancel` and `stop` functions are called without arguments.\n     */\n    private latestPanInfo: PanInfo | null = null\n\n    constructor(visualElement: VisualElement<HTMLElement>) {\n        this.visualElement = visualElement\n    }\n\n    start(\n        originEvent: PointerEvent,\n        { snapToCursor = false, distanceThreshold }: DragControlOptions = {}\n    ) {\n        /**\n         * Don't start dragging if this component is exiting\n         */\n        const { presenceContext } = this.visualElement\n        if (presenceContext && presenceContext.isPresent === false) return\n\n        const onSessionStart = (event: PointerEvent) => {\n            if (snapToCursor) {\n                this.snapToCursor(extractEventInfo(event).point)\n            }\n            this.stopAnimation()\n        }\n\n        const onStart = (event: PointerEvent, info: PanInfo) => {\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            const { drag, dragPropagation, onDragStart } = this.getProps()\n\n            if (drag && !dragPropagation) {\n                if (this.openDragLock) this.openDragLock()\n\n                this.openDragLock = setDragLock(drag)\n\n                // If we don 't have the lock, don't start dragging\n                if (!this.openDragLock) return\n            }\n\n            this.latestPointerEvent = event\n            this.latestPanInfo = info\n            this.isDragging = true\n\n            this.currentDirection = null\n\n            this.resolveConstraints()\n\n            if (this.visualElement.projection) {\n                this.visualElement.projection.isAnimationBlocked = true\n                this.visualElement.projection.target = undefined\n            }\n\n            /**\n             * Record gesture origin and pointer offset\n             */\n            eachAxis((axis) => {\n                let current = this.getAxisMotionValue(axis).get() || 0\n\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */\n                if (percent.test(current)) {\n                    const { projection } = this.visualElement\n\n                    if (projection && projection.layout) {\n                        const measuredAxis = projection.layout.layoutBox[axis]\n\n                        if (measuredAxis) {\n                            const length = calcLength(measuredAxis)\n                            current = length * (parseFloat(current) / 100)\n                        }\n                    }\n                }\n\n                this.originPoint[axis] = current\n            })\n\n            // Fire onDragStart event\n            if (onDragStart) {\n                frame.update(() => onDragStart(event, info), false, true)\n            }\n\n            addValueToWillChange(this.visualElement, \"transform\")\n\n            const { animationState } = this.visualElement\n            animationState && animationState.setActive(\"whileDrag\", true)\n        }\n\n        const onMove = (event: PointerEvent, info: PanInfo) => {\n            this.latestPointerEvent = event\n            this.latestPanInfo = info\n\n            const {\n                dragPropagation,\n                dragDirectionLock,\n                onDirectionLock,\n                onDrag,\n            } = this.getProps()\n\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !this.openDragLock) return\n\n            const { offset } = info\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && this.currentDirection === null) {\n                this.currentDirection = getCurrentDirection(offset)\n\n                // If we've successfully set a direction, notify listener\n                if (this.currentDirection !== null) {\n                    onDirectionLock && onDirectionLock(this.currentDirection)\n                }\n\n                return\n            }\n\n            // Update each point with the latest position\n            this.updateAxis(\"x\", info.point, offset)\n            this.updateAxis(\"y\", info.point, offset)\n\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don't fall out of sync.\n             */\n            this.visualElement.render()\n\n            /**\n             * This must fire after the render call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */\n            if (onDrag) {\n                frame.update(() => onDrag(event, info), false, true)\n            }\n        }\n\n        const onSessionEnd = (event: PointerEvent, info: PanInfo) => {\n            this.latestPointerEvent = event\n            this.latestPanInfo = info\n\n            this.stop(event, info)\n\n            this.latestPointerEvent = null\n            this.latestPanInfo = null\n        }\n\n        const resumeAnimation = () => {\n            const { dragSnapToOrigin: snap } = this.getProps()\n            if (snap || this.constraints) {\n                this.startAnimation({ x: 0, y: 0 })\n            }\n        }\n\n        const { dragSnapToOrigin } = this.getProps()\n        this.panSession = new PanSession(\n            originEvent,\n            {\n                onSessionStart,\n                onStart,\n                onMove,\n                onSessionEnd,\n                resumeAnimation,\n            },\n            {\n                transformPagePoint: this.visualElement.getTransformPagePoint(),\n                dragSnapToOrigin,\n                distanceThreshold,\n                contextWindow: getContextWindow(this.visualElement),\n                element: this.visualElement.current,\n            }\n        )\n    }\n\n    /**\n     * @internal\n     */\n    stop(event?: PointerEvent, panInfo?: PanInfo) {\n        const finalEvent = event || this.latestPointerEvent\n        const finalPanInfo = panInfo || this.latestPanInfo\n\n        const isDragging = this.isDragging\n        this.cancel()\n        if (!isDragging || !finalPanInfo || !finalEvent) return\n\n        const { velocity } = finalPanInfo\n        this.startAnimation(velocity)\n\n        const { onDragEnd } = this.getProps()\n        if (onDragEnd) {\n            frame.postRender(() => onDragEnd(finalEvent, finalPanInfo))\n        }\n    }\n\n    /**\n     * @internal\n     */\n    cancel() {\n        this.isDragging = false\n\n        const { projection, animationState } = this.visualElement\n\n        if (projection) {\n            projection.isAnimationBlocked = false\n        }\n\n        this.endPanSession()\n\n        const { dragPropagation } = this.getProps()\n\n        if (!dragPropagation && this.openDragLock) {\n            this.openDragLock()\n            this.openDragLock = null\n        }\n\n        animationState && animationState.setActive(\"whileDrag\", false)\n    }\n\n    /**\n     * Clean up the pan session without modifying other drag state.\n     * This is used during unmount to ensure event listeners are removed\n     * without affecting projection animations or drag locks.\n     * @internal\n     */\n    endPanSession() {\n        this.panSession && this.panSession.end()\n        this.panSession = undefined\n    }\n\n    private updateAxis(axis: DragDirection, _point: Point, offset?: Point) {\n        const { drag } = this.getProps()\n\n        // If we're not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection)) return\n\n        const axisValue = this.getAxisMotionValue(axis)\n        let next = this.originPoint[axis] + offset[axis]\n\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(\n                next,\n                this.constraints[axis],\n                this.elastic[axis]\n            )\n        }\n\n        axisValue.set(next)\n    }\n\n    private resolveConstraints() {\n        const { dragConstraints, dragElastic } = this.getProps()\n\n        const layout =\n            this.visualElement.projection &&\n            !this.visualElement.projection.layout\n                ? this.visualElement.projection.measure(false)\n                : this.visualElement.projection?.layout\n\n        const prevConstraints = this.constraints\n\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints()\n            }\n        } else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(\n                    layout.layoutBox,\n                    dragConstraints\n                )\n            } else {\n                this.constraints = false\n            }\n        }\n\n        this.elastic = resolveDragElastic(dragElastic)\n\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative. This only applies to relative (non-ref)\n         * constraints, as ref-based constraints from calcViewportConstraints are already in the\n         * correct coordinate space for the motion value transform offset.\n         */\n        if (\n            prevConstraints !== this.constraints &&\n            !isRefObject(dragConstraints) &&\n            layout &&\n            this.constraints &&\n            !this.hasMutatedConstraints\n        ) {\n            eachAxis((axis) => {\n                if (\n                    this.constraints !== false &&\n                    this.getAxisMotionValue(axis)\n                ) {\n                    this.constraints[axis] = rebaseAxisConstraints(\n                        layout.layoutBox[axis],\n                        this.constraints[axis]\n                    )\n                }\n            })\n        }\n    }\n\n    private resolveRefConstraints() {\n        const { dragConstraints: constraints, onMeasureDragConstraints } =\n            this.getProps()\n        if (!constraints || !isRefObject(constraints)) return false\n\n        const constraintsElement = constraints.current as HTMLElement\n\n        invariant(\n            constraintsElement !== null,\n            \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\",\n            \"drag-constraints-ref\"\n        )\n\n        const { projection } = this.visualElement\n\n        // TODO\n        if (!projection || !projection.layout) return false\n\n        const constraintsBox = measurePageBox(\n            constraintsElement,\n            projection.root!,\n            this.visualElement.getTransformPagePoint()\n        )\n\n        let measuredConstraints = calcViewportConstraints(\n            projection.layout.layoutBox,\n            constraintsBox\n        )\n\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            const userConstraints = onMeasureDragConstraints(\n                convertBoxToBoundingBox(measuredConstraints)\n            )\n\n            this.hasMutatedConstraints = !!userConstraints\n\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints)\n            }\n        }\n\n        return measuredConstraints\n    }\n\n    private startAnimation(velocity: Point) {\n        const {\n            drag,\n            dragMomentum,\n            dragElastic,\n            dragTransition,\n            dragSnapToOrigin,\n            onDragTransitionEnd,\n        } = this.getProps()\n\n        const constraints: Partial<ResolvedConstraints> = this.constraints || {}\n\n        const momentumAnimations = eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, this.currentDirection)) {\n                return\n            }\n\n            let transition = (constraints && constraints[axis]) || {}\n\n            if (dragSnapToOrigin) transition = { min: 0, max: 0 }\n\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            const bounceStiffness = dragElastic ? 200 : 1000000\n            const bounceDamping = dragElastic ? 40 : 10000000\n\n            const inertia: Transition = {\n                type: \"inertia\",\n                velocity: dragMomentum ? velocity[axis] : 0,\n                bounceStiffness,\n                bounceDamping,\n                timeConstant: 750,\n                restDelta: 1,\n                restSpeed: 10,\n                ...dragTransition,\n                ...transition,\n            }\n\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return this.startAxisValueAnimation(axis, inertia)\n        })\n\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd)\n    }\n\n    private startAxisValueAnimation(\n        axis: DragDirection,\n        transition: Transition\n    ) {\n        const axisValue = this.getAxisMotionValue(axis)\n\n        addValueToWillChange(this.visualElement, axis)\n\n        return axisValue.start(\n            animateMotionValue(\n                axis,\n                axisValue,\n                0,\n                transition,\n                this.visualElement,\n                false\n            )\n        )\n    }\n\n    private stopAnimation() {\n        eachAxis((axis) => this.getAxisMotionValue(axis).stop())\n    }\n\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    private getAxisMotionValue(axis: DragDirection) {\n        const dragKey =\n            `_drag${axis.toUpperCase()}` as `_drag${Uppercase<DragDirection>}`\n        const props = this.visualElement.getProps()\n        const externalMotionValue = props[dragKey]\n\n        return externalMotionValue\n            ? externalMotionValue\n            : this.visualElement.getValue(\n                  axis,\n                  (props.initial\n                      ? props.initial[axis as keyof typeof props.initial]\n                      : undefined) || 0\n              )\n    }\n\n    private snapToCursor(point: Point) {\n        eachAxis((axis) => {\n            const { drag } = this.getProps()\n\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, this.currentDirection)) return\n\n            const { projection } = this.visualElement\n            const axisValue = this.getAxisMotionValue(axis)\n\n            if (projection && projection.layout) {\n                const { min, max } = projection.layout.layoutBox[axis]\n\n                /**\n                 * The layout measurement includes the current transform value,\n                 * so we need to add it back to get the correct snap position.\n                 * This fixes an issue where elements with initial coordinates\n                 * would snap to the wrong position on the first drag.\n                 */\n                const current = axisValue.get() || 0\n\n                axisValue.set(point[axis] - mixNumber(min, max, 0.5) + current)\n            }\n        })\n    }\n\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */\n    scalePositionWithinConstraints() {\n        if (!this.visualElement.current) return\n\n        const { drag, dragConstraints } = this.getProps()\n        const { projection } = this.visualElement\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n            return\n\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */\n        this.stopAnimation()\n\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */\n        const boxProgress = { x: 0, y: 0 }\n        eachAxis((axis) => {\n            const axisValue = this.getAxisMotionValue(axis)\n            if (axisValue && this.constraints !== false) {\n                const latest = axisValue.get()\n                boxProgress[axis] = calcOrigin(\n                    { min: latest, max: latest },\n                    this.constraints[axis] as Axis\n                )\n            }\n        })\n\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */\n        const { transformTemplate } = this.visualElement.getProps()\n        this.visualElement.current.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\"\n        projection.root && projection.root.updateScroll()\n        projection.updateLayout()\n\n        /**\n         * Reset constraints so resolveConstraints() will recalculate them\n         * with the freshly measured layout rather than returning the cached value.\n         */\n        this.constraints = false\n        this.resolveConstraints()\n\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */\n        eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, null)) return\n\n            /**\n             * Calculate a new transform based on the previous box progress\n             */\n            const axisValue = this.getAxisMotionValue(axis)\n            const { min, max } = (this.constraints as ResolvedConstraints)[\n                axis\n            ] as Axis\n            axisValue.set(mixNumber(min, max, boxProgress[axis]))\n        })\n\n        /**\n         * Flush the updated transform to the DOM synchronously to prevent\n         * a visual flash at the element's CSS layout position (0,0) when\n         * the transform was stripped for measurement.\n         */\n        this.visualElement.render()\n    }\n\n    addListeners() {\n        if (!this.visualElement.current) return\n        elementDragControls.set(this.visualElement, this)\n        const element = this.visualElement.current\n\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        const stopPointerListener = addPointerEvent(\n            element,\n            \"pointerdown\",\n            (event) => {\n                const { drag, dragListener = true } = this.getProps()\n                const target = event.target as Element\n\n                /**\n                 * Only block drag if clicking on a text input child element\n                 * (input, textarea, select, contenteditable) where users might\n                 * want to select text or interact with the control.\n                 *\n                 * Buttons and links don't block drag since they don't have\n                 * click-and-move actions of their own.\n                 */\n                const isClickingTextInputChild =\n                    target !== element && isElementTextInput(target)\n\n                if (drag && dragListener && !isClickingTextInputChild) {\n                    this.start(event)\n                }\n            }\n        )\n\n        /**\n         * If using ref-based constraints, observe both the draggable element\n         * and the constraint container for size changes via ResizeObserver.\n         * Setup is deferred because dragConstraints.current is null when\n         * addListeners first runs (React hasn't committed the ref yet).\n         */\n        let stopResizeObservers: VoidFunction | undefined\n\n        const measureDragConstraints = () => {\n            const { dragConstraints } = this.getProps()\n            if (isRefObject(dragConstraints) && dragConstraints.current) {\n                this.constraints = this.resolveRefConstraints()\n\n                if (!stopResizeObservers) {\n                    stopResizeObservers = startResizeObservers(\n                        element,\n                        dragConstraints.current as HTMLElement,\n                        () => this.scalePositionWithinConstraints()\n                    )\n                }\n            }\n        }\n\n        const { projection } = this.visualElement\n\n        const stopMeasureLayoutListener = projection!.addEventListener(\n            \"measure\",\n            measureDragConstraints\n        )\n\n        if (projection && !projection!.layout) {\n            projection.root && projection.root.updateScroll()\n            projection.updateLayout()\n        }\n\n        frame.read(measureDragConstraints)\n\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        const stopResizeListener = addDomEvent(window, \"resize\", () =>\n            this.scalePositionWithinConstraints()\n        )\n\n        /**\n         * If the element's layout changes, calculate the delta and apply that to\n         * the drag gesture's origin point.\n         */\n        const stopLayoutUpdateListener = projection!.addEventListener(\n            \"didUpdate\",\n            (({ delta, hasLayoutChanged }: LayoutUpdateData) => {\n                if (this.isDragging && hasLayoutChanged) {\n                    eachAxis((axis) => {\n                        const motionValue = this.getAxisMotionValue(axis)\n                        if (!motionValue) return\n\n                        this.originPoint[axis] += delta[axis].translate\n                        motionValue.set(\n                            motionValue.get() + delta[axis].translate\n                        )\n                    })\n\n                    this.visualElement.render()\n                }\n            }) as any\n        )\n\n        return () => {\n            stopResizeListener()\n            stopPointerListener()\n            stopMeasureLayoutListener()\n            stopLayoutUpdateListener && stopLayoutUpdateListener()\n            stopResizeObservers && stopResizeObservers()\n        }\n    }\n\n    getProps(): MotionProps {\n        const props = this.visualElement.getProps()\n        const {\n            drag = false,\n            dragDirectionLock = false,\n            dragPropagation = false,\n            dragConstraints = false,\n            dragElastic = defaultElastic,\n            dragMomentum = true,\n        } = props\n        return {\n            ...props,\n            drag,\n            dragDirectionLock,\n            dragPropagation,\n            dragConstraints,\n            dragElastic,\n            dragMomentum,\n        }\n    }\n}\n\nfunction skipFirstCall(callback: VoidFunction): VoidFunction {\n    let isFirst = true\n    return () => {\n        if (isFirst) {\n            isFirst = false\n            return\n        }\n        callback()\n    }\n}\n\nfunction startResizeObservers(\n    element: HTMLElement,\n    constraintsElement: HTMLElement,\n    onResize: VoidFunction\n): VoidFunction {\n    const stopElement = resize(element, skipFirstCall(onResize))\n    const stopContainer = resize(constraintsElement, skipFirstCall(onResize))\n    return () => {\n        stopElement()\n        stopContainer()\n    }\n}\n\nfunction shouldDrag(\n    direction: DragDirection,\n    drag: boolean | DragDirection | undefined,\n    currentDirection: null | DragDirection\n) {\n    return (\n        (drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction)\n    )\n}\n\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(\n    offset: Point,\n    lockThreshold = 10\n): DragDirection | null {\n    let direction: DragDirection | null = null\n\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\"\n    } else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\"\n    }\n\n    return direction\n}\n\nexport function expectsResolvedDragConstraints({\n    dragConstraints,\n    onMeasureDragConstraints,\n}: MotionProps) {\n    return isRefObject(dragConstraints) && !!onMeasureDragConstraints\n}\n"]},"metadata":{},"sourceType":"module"}