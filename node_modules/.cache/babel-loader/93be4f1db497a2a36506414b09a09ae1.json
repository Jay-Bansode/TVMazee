{"ast":null,"code":"import { complex } from '../../value/types/complex/index.mjs';\nimport { mixNumber } from '../../utils/mix/number.mjs';\nconst correctBoxShadow = {\n  correct: (latest, _ref) => {\n    let {\n      treeScale,\n      projectionDelta\n    } = _ref;\n    const original = latest;\n    const shadow = complex.parse(latest); // TODO: Doesn't support multiple shadows\n\n    if (shadow.length > 5) return original;\n    const template = complex.createTransformer(latest);\n    const offset = typeof shadow[0] !== \"number\" ? 1 : 0; // Calculate the overall context scale\n\n    const xScale = projectionDelta.x.scale * treeScale.x;\n    const yScale = projectionDelta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    /**\n     * Ideally we'd correct x and y scales individually, but because blur and\n     * spread apply to both we have to take a scale average and apply that instead.\n     * We could potentially improve the outcome of this by incorporating the ratio between\n     * the two scales.\n     */\n\n    const averageScale = mixNumber(xScale, yScale, 0.5); // Blur\n\n    if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale; // Spread\n\n    if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n    return template(shadow);\n  }\n};\nexport { correctBoxShadow };","map":{"version":3,"mappings":";;AAIa,sBAAgB,GAA6B;EACtDA,OAAO,EAAE,CAACC,MAAD,WAAmD;IAAA,IAAlC;MAAEC,SAAF;MAAaC;IAAb,CAAkC;IACxD,MAAMC,QAAQ,GAAGH,MAAjB;IACA,MAAMI,MAAM,GAAGC,OAAO,CAACC,KAAR,CAAcN,MAAd,CAAf,CAFwD;;IAKxD,IAAII,MAAM,CAACG,MAAP,GAAgB,CAApB,EAAuB,OAAOJ,QAAP;IAEvB,MAAMK,QAAQ,GAAGH,OAAO,CAACI,iBAAR,CAA0BT,MAA1B,CAAjB;IACA,MAAMU,MAAM,GAAG,OAAON,MAAM,CAAC,CAAD,CAAb,KAAqB,QAArB,GAAgC,CAAhC,GAAoC,CAAnD,CARwD;;IAWxD,MAAMO,MAAM,GAAGT,eAAgB,CAACU,CAAjB,CAAmBC,KAAnB,GAA2BZ,SAAU,CAACW,CAArD;IACA,MAAME,MAAM,GAAGZ,eAAgB,CAACa,CAAjB,CAAmBF,KAAnB,GAA2BZ,SAAU,CAACc,CAArD;IAGEX,MAAM,CAAC,IAAIM,MAAL,CAAN,IAAiCC,MAAjC;IACAP,MAAM,CAAC,IAAIM,MAAL,CAAN,IAAiCI,MAAjC;IAEF;;;;;AAKG;;IACH,MAAME,YAAY,GAAGC,SAAS,CAACN,MAAD,EAASG,MAAT,EAAiB,GAAjB,CAA9B,CAxBwD;;IA2BxD,IAAI,OAAOV,MAAM,CAAC,IAAIM,MAAL,CAAb,KAA8B,QAAlC,EACKN,MAAM,CAAC,IAAIM,MAAL,CAAN,IAAiCM,YAAjC,CA5BmD;;IA+BxD,IAAI,OAAOZ,MAAM,CAAC,IAAIM,MAAL,CAAb,KAA8B,QAAlC,EACKN,MAAM,CAAC,IAAIM,MAAL,CAAN,IAAiCM,YAAjC;IAEL,OAAOR,QAAQ,CAACJ,MAAD,CAAf;EACH;AApCqD,CAA7C","names":["correct","latest","treeScale","projectionDelta","original","shadow","complex","parse","length","template","createTransformer","offset","xScale","x","scale","yScale","y","averageScale","mixNumber"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\projection\\styles\\scale-box-shadow.ts"],"sourcesContent":["import { complex } from \"../../value/types/complex\"\nimport { mixNumber } from \"../../utils/mix/number\"\nimport type { ScaleCorrectorDefinition } from \"./types\"\n\nexport const correctBoxShadow: ScaleCorrectorDefinition = {\n    correct: (latest: string, { treeScale, projectionDelta }) => {\n        const original = latest\n        const shadow = complex.parse(latest)\n\n        // TODO: Doesn't support multiple shadows\n        if (shadow.length > 5) return original\n\n        const template = complex.createTransformer(latest)\n        const offset = typeof shadow[0] !== \"number\" ? 1 : 0\n\n        // Calculate the overall context scale\n        const xScale = projectionDelta!.x.scale * treeScale!.x\n        const yScale = projectionDelta!.y.scale * treeScale!.y\n\n        // Scale x/y\n        ;(shadow[0 + offset] as number) /= xScale\n        ;(shadow[1 + offset] as number) /= yScale\n\n        /**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */\n        const averageScale = mixNumber(xScale, yScale, 0.5)\n\n        // Blur\n        if (typeof shadow[2 + offset] === \"number\")\n            (shadow[2 + offset] as number) /= averageScale\n\n        // Spread\n        if (typeof shadow[3 + offset] === \"number\")\n            (shadow[3 + offset] as number) /= averageScale\n\n        return template(shadow)\n    },\n}\n"]},"metadata":{},"sourceType":"module"}