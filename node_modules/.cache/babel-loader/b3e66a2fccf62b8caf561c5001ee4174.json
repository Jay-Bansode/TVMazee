{"ast":null,"code":"import { invariant, clamp, MotionGlobalConfig, noop, pipe, progress } from 'motion-utils';\nimport { mix } from './mix/index.mjs';\n\nfunction createMixers(output, ease, customMixer) {\n  const mixers = [];\n  const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;\n  const numMixers = output.length - 1;\n\n  for (let i = 0; i < numMixers; i++) {\n    let mixer = mixerFactory(output[i], output[i + 1]);\n\n    if (ease) {\n      const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n\n    mixers.push(mixer);\n  }\n\n  return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revisit this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\n\n\nfunction interpolate(input, output) {\n  let {\n    clamp: isClamp = true,\n    ease,\n    mixer\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const inputLength = input.length;\n  invariant(inputLength === output.length, \"Both input and output ranges must be the same length\", \"range-length\");\n  /**\n   * If we're only provided a single input, we can just make a function\n   * that returns the output.\n   */\n\n  if (inputLength === 1) return () => output[0];\n  if (inputLength === 2 && output[0] === output[1]) return () => output[1];\n  const isZeroDeltaRange = input[0] === input[1]; // If input runs highest -> lowest, reverse both arrays\n\n  if (input[0] > input[inputLength - 1]) {\n    input = [...input].reverse();\n    output = [...output].reverse();\n  }\n\n  const mixers = createMixers(output, ease, mixer);\n  const numMixers = mixers.length;\n\n  const interpolator = v => {\n    if (isZeroDeltaRange && v < input[0]) return output[0];\n    let i = 0;\n\n    if (numMixers > 1) {\n      for (; i < input.length - 2; i++) {\n        if (v < input[i + 1]) break;\n      }\n    }\n\n    const progressInRange = progress(input[i], input[i + 1], v);\n    return mixers[i](progressInRange);\n  };\n\n  return isClamp ? v => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;\n}\n\nexport { interpolate };","map":{"version":3,"mappings":"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","names":["createMixers","output","ease","customMixer","mixers","mixerFactory","MotionGlobalConfig","mix","numMixers","length","i","mixer","easingFunction","Array","isArray","noop","pipe","push","interpolate","input","clamp","isClamp","inputLength","invariant","isZeroDeltaRange","reverse","interpolator","v","progressInRange","progress"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\utils\\interpolate.ts"],"sourcesContent":["import {\n    clamp,\n    EasingFunction,\n    invariant,\n    MotionGlobalConfig,\n    noop,\n    pipe,\n    progress,\n} from \"motion-utils\"\nimport { mix } from \"./mix\"\nimport { Mixer, MixerFactory } from \"./mix/types\"\n\nexport interface InterpolateOptions<T> {\n    clamp?: boolean\n    ease?: EasingFunction | EasingFunction[]\n    mixer?: MixerFactory<T>\n}\n\nfunction createMixers<T>(\n    output: T[],\n    ease?: EasingFunction | EasingFunction[],\n    customMixer?: MixerFactory<T>\n) {\n    const mixers: Array<Mixer<T>> = []\n    const mixerFactory: MixerFactory<T> =\n        customMixer || MotionGlobalConfig.mix || mix\n    const numMixers = output.length - 1\n\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1])\n\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease\n            mixer = pipe(easingFunction, mixer) as Mixer<T>\n        }\n\n        mixers.push(mixer)\n    }\n\n    return mixers\n}\n\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revisit this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nexport function interpolate<T>(\n    input: number[],\n    output: T[],\n    { clamp: isClamp = true, ease, mixer }: InterpolateOptions<T> = {}\n): (v: number) => T {\n    const inputLength = input.length\n\n    invariant(\n        inputLength === output.length,\n        \"Both input and output ranges must be the same length\",\n        \"range-length\"\n    )\n\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1) return () => output[0]\n    if (inputLength === 2 && output[0] === output[1]) return () => output[1]\n\n    const isZeroDeltaRange = input[0] === input[1]\n\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse()\n        output = [...output].reverse()\n    }\n\n    const mixers = createMixers(output, ease, mixer)\n    const numMixers = mixers.length\n\n    const interpolator = (v: number): T => {\n        if (isZeroDeltaRange && v < input[0]) return output[0]\n\n        let i = 0\n\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1]) break\n            }\n        }\n\n        const progressInRange = progress(input[i], input[i + 1], v)\n\n        return mixers[i](progressInRange)\n    }\n\n    return isClamp\n        ? (v: number) =>\n              interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator\n}\n"]},"metadata":{},"sourceType":"module"}