{"ast":null,"code":"import { MotionGlobalConfig, noop } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { KeyframeResolver, flushKeyframeResolvers } from './keyframes/KeyframesResolver.mjs';\nimport { NativeAnimationExtended } from './NativeAnimationExtended.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { makeAnimationInstant } from './utils/make-animation-instant.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { supportsBrowserAnimation } from './waapi/supports/waapi.mjs';\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\n\nconst MAX_RESOLVE_DELAY = 40;\n\nclass AsyncMotionValueAnimation extends WithPromise {\n  constructor(_ref) {\n    let {\n      autoplay = true,\n      delay = 0,\n      type = \"keyframes\",\n      repeat = 0,\n      repeatDelay = 0,\n      repeatType = \"loop\",\n      keyframes,\n      name,\n      motionValue,\n      element,\n      ...options\n    } = _ref;\n    super();\n    /**\n     * Bound to support return animation.stop pattern\n     */\n\n    this.stop = () => {\n      if (this._animation) {\n        this._animation.stop();\n\n        this.stopTimeline?.();\n      }\n\n      this.keyframeResolver?.cancel();\n    };\n\n    this.createdAt = time.now();\n    const optionsWithDefaults = {\n      autoplay,\n      delay,\n      type,\n      repeat,\n      repeatDelay,\n      repeatType,\n      name,\n      motionValue,\n      element,\n      ...options\n    };\n    const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;\n    this.keyframeResolver = new KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);\n    this.keyframeResolver?.scheduleResolve();\n  }\n\n  onKeyframesResolved(keyframes, finalKeyframe, options, sync) {\n    this.keyframeResolver = undefined;\n    const {\n      name,\n      type,\n      velocity,\n      delay,\n      isHandoff,\n      onUpdate\n    } = options;\n    this.resolvedAt = time.now();\n    /**\n     * If we can't animate this value with the resolved keyframes\n     * then we should complete it immediately.\n     */\n\n    if (!canAnimate(keyframes, name, type, velocity)) {\n      if (MotionGlobalConfig.instantAnimations || !delay) {\n        onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe));\n      }\n\n      keyframes[0] = keyframes[keyframes.length - 1];\n      makeAnimationInstant(options);\n      options.repeat = 0;\n    }\n    /**\n     * Resolve startTime for the animation.\n     *\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first committed frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n\n\n    const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : undefined;\n    const resolvedOptions = {\n      startTime,\n      finalKeyframe,\n      ...options,\n      keyframes\n    };\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n\n    const useWaapi = !isHandoff && supportsBrowserAnimation(resolvedOptions);\n    const element = resolvedOptions.motionValue?.owner?.current;\n    const animation = useWaapi ? new NativeAnimationExtended({ ...resolvedOptions,\n      element\n    }) : new JSAnimation(resolvedOptions);\n    animation.finished.then(() => {\n      this.notifyFinished();\n    }).catch(noop);\n\n    if (this.pendingTimeline) {\n      this.stopTimeline = animation.attachTimeline(this.pendingTimeline);\n      this.pendingTimeline = undefined;\n    }\n\n    this._animation = animation;\n  }\n\n  get finished() {\n    if (!this._animation) {\n      return this._finished;\n    } else {\n      return this.animation.finished;\n    }\n  }\n\n  then(onResolve, _onReject) {\n    return this.finished.finally(onResolve).then(() => {});\n  }\n\n  get animation() {\n    if (!this._animation) {\n      this.keyframeResolver?.resume();\n      flushKeyframeResolvers();\n    }\n\n    return this._animation;\n  }\n\n  get duration() {\n    return this.animation.duration;\n  }\n\n  get iterationDuration() {\n    return this.animation.iterationDuration;\n  }\n\n  get time() {\n    return this.animation.time;\n  }\n\n  set time(newTime) {\n    this.animation.time = newTime;\n  }\n\n  get speed() {\n    return this.animation.speed;\n  }\n\n  get state() {\n    return this.animation.state;\n  }\n\n  set speed(newSpeed) {\n    this.animation.speed = newSpeed;\n  }\n\n  get startTime() {\n    return this.animation.startTime;\n  }\n\n  attachTimeline(timeline) {\n    if (this._animation) {\n      this.stopTimeline = this.animation.attachTimeline(timeline);\n    } else {\n      this.pendingTimeline = timeline;\n    }\n\n    return () => this.stop();\n  }\n\n  play() {\n    this.animation.play();\n  }\n\n  pause() {\n    this.animation.pause();\n  }\n\n  complete() {\n    this.animation.complete();\n  }\n\n  cancel() {\n    if (this._animation) {\n      this.animation.cancel();\n    }\n\n    this.keyframeResolver?.cancel();\n  }\n\n}\n\nexport { AsyncMotionValueAnimation };","map":{"version":3,"mappings":"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","names":["MAX_RESOLVE_DELAY","AsyncMotionValueAnimation","WithPromise","constructor","autoplay","delay","type","repeat","repeatDelay","repeatType","keyframes","name","motionValue","element","options","stop","_animation","stopTimeline","keyframeResolver","cancel","createdAt","time","now","optionsWithDefaults","KeyframeResolver","DefaultKeyframeResolver","resolvedKeyframes","finalKeyframe","forced","onKeyframesResolved","scheduleResolve","sync","undefined","velocity","isHandoff","onUpdate","resolvedAt","canAnimate","MotionGlobalConfig","instantAnimations","getFinalKeyframe","length","makeAnimationInstant","startTime","resolvedOptions","useWaapi","supportsBrowserAnimation","owner","current","animation","NativeAnimationExtended","JSAnimation","finished","then","notifyFinished","catch","noop","pendingTimeline","attachTimeline","_finished","onResolve","_onReject","finally","resume","flushKeyframeResolvers","duration","iterationDuration","newTime","speed","state","newSpeed","timeline","play","pause","complete"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\animation\\AsyncMotionValueAnimation.ts"],"sourcesContent":["import { MotionGlobalConfig, noop } from \"motion-utils\"\nimport { time } from \"../frameloop/sync-time\"\nimport { JSAnimation } from \"./JSAnimation\"\nimport { getFinalKeyframe } from \"./keyframes/get-final\"\nimport {\n    KeyframeResolver as DefaultKeyframeResolver,\n    flushKeyframeResolvers,\n    ResolvedKeyframes,\n} from \"./keyframes/KeyframesResolver\"\nimport { NativeAnimationExtended } from \"./NativeAnimationExtended\"\nimport {\n    AnimationPlaybackControls,\n    AnyResolvedKeyframe,\n    TimelineWithFallback,\n    ValueAnimationOptions,\n} from \"./types\"\nimport { canAnimate } from \"./utils/can-animate\"\nimport { makeAnimationInstant } from \"./utils/make-animation-instant\"\nimport { WithPromise } from \"./utils/WithPromise\"\nimport { supportsBrowserAnimation } from \"./waapi/supports/waapi\"\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40\n\ntype OptionsWithoutKeyframes<T extends AnyResolvedKeyframe> = Omit<\n    ValueAnimationOptions<T>,\n    \"keyframes\"\n>\n\nexport class AsyncMotionValueAnimation<T extends AnyResolvedKeyframe>\n    extends WithPromise\n    implements AnimationPlaybackControls\n{\n    private createdAt: number\n\n    private resolvedAt: number | undefined\n\n    private _animation: AnimationPlaybackControls | undefined\n\n    private pendingTimeline: TimelineWithFallback | undefined\n\n    private keyframeResolver: DefaultKeyframeResolver | undefined\n\n    private stopTimeline: VoidFunction | undefined\n\n    constructor({\n        autoplay = true,\n        delay = 0,\n        type = \"keyframes\",\n        repeat = 0,\n        repeatDelay = 0,\n        repeatType = \"loop\",\n        keyframes,\n        name,\n        motionValue,\n        element,\n        ...options\n    }: ValueAnimationOptions<T>) {\n        super()\n\n        this.createdAt = time.now()\n\n        const optionsWithDefaults: OptionsWithoutKeyframes<T> = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            name,\n            motionValue,\n            element,\n            ...options,\n        }\n\n        const KeyframeResolver =\n            element?.KeyframeResolver || DefaultKeyframeResolver\n\n        this.keyframeResolver = new KeyframeResolver(\n            keyframes,\n            (\n                resolvedKeyframes: ResolvedKeyframes<T>,\n                finalKeyframe: T,\n                forced: boolean\n            ) =>\n                this.onKeyframesResolved(\n                    resolvedKeyframes,\n                    finalKeyframe,\n                    optionsWithDefaults,\n                    !forced\n                ),\n            name,\n            motionValue,\n            element\n        )\n        this.keyframeResolver?.scheduleResolve()\n    }\n\n    onKeyframesResolved(\n        keyframes: ResolvedKeyframes<T>,\n        finalKeyframe: T,\n        options: OptionsWithoutKeyframes<T>,\n        sync: boolean\n    ) {\n        this.keyframeResolver = undefined\n\n        const { name, type, velocity, delay, isHandoff, onUpdate } = options\n        this.resolvedAt = time.now()\n\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!canAnimate(keyframes, name, type, velocity)) {\n            if (MotionGlobalConfig.instantAnimations || !delay) {\n                onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe))\n            }\n\n            keyframes[0] = keyframes[keyframes.length - 1]\n\n            makeAnimationInstant(options)\n            options.repeat = 0\n        }\n\n        /**\n         * Resolve startTime for the animation.\n         *\n         * This method uses the createdAt and resolvedAt to calculate the\n         * animation startTime. *Ideally*, we would use the createdAt time as t=0\n         * as the following frame would then be the first frame of the animation in\n         * progress, which would feel snappier.\n         *\n         * However, if there's a delay (main thread work) between the creation of\n         * the animation and the first committed frame, we prefer to use resolvedAt\n         * to avoid a sudden jump into the animation.\n         */\n        const startTime = sync\n            ? !this.resolvedAt\n                ? this.createdAt\n                : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n                ? this.resolvedAt\n                : this.createdAt\n            : undefined\n\n        const resolvedOptions = {\n            startTime,\n            finalKeyframe,\n            ...options,\n            keyframes,\n        }\n\n        /**\n         * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n         * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n         * optimised animation.\n         */\n        const useWaapi = !isHandoff && supportsBrowserAnimation(resolvedOptions)\n        const element = resolvedOptions.motionValue?.owner?.current\n\n        const animation = useWaapi\n                ? new NativeAnimationExtended({\n                      ...resolvedOptions,\n                      element,\n                  } as any)\n                : new JSAnimation(resolvedOptions)\n\n        animation.finished.then(() => {\n            this.notifyFinished()\n        }).catch(noop)\n\n        if (this.pendingTimeline) {\n            this.stopTimeline = animation.attachTimeline(this.pendingTimeline)\n            this.pendingTimeline = undefined\n        }\n\n        this._animation = animation\n    }\n\n    get finished() {\n        if (!this._animation) {\n            return this._finished\n        } else {\n            return this.animation.finished\n        }\n    }\n\n    then(onResolve: VoidFunction, _onReject?: VoidFunction) {\n        return this.finished.finally(onResolve).then(() => {})\n    }\n\n    get animation(): AnimationPlaybackControls {\n        if (!this._animation) {\n            this.keyframeResolver?.resume()\n            flushKeyframeResolvers()\n        }\n\n        return this._animation!\n    }\n\n    get duration() {\n        return this.animation.duration\n    }\n\n    get iterationDuration() {\n        return this.animation.iterationDuration\n    }\n\n    get time() {\n        return this.animation.time\n    }\n\n    set time(newTime: number) {\n        this.animation.time = newTime\n    }\n\n    get speed() {\n        return this.animation.speed\n    }\n\n    get state() {\n        return this.animation.state\n    }\n\n    set speed(newSpeed: number) {\n        this.animation.speed = newSpeed\n    }\n\n    get startTime() {\n        return this.animation.startTime\n    }\n\n    attachTimeline(timeline: TimelineWithFallback) {\n        if (this._animation) {\n            this.stopTimeline = this.animation.attachTimeline(timeline)\n        } else {\n            this.pendingTimeline = timeline\n        }\n\n        return () => this.stop()\n    }\n\n    play() {\n        this.animation.play()\n    }\n\n    pause() {\n        this.animation.pause()\n    }\n\n    complete() {\n        this.animation.complete()\n    }\n\n    cancel() {\n        if (this._animation) {\n            this.animation.cancel()\n        }\n\n        this.keyframeResolver?.cancel()\n    }\n\n    /**\n     * Bound to support return animation.stop pattern\n     */\n    stop = () => {\n        if (this._animation) {\n            this._animation.stop()\n            this.stopTimeline?.()\n        }\n\n        this.keyframeResolver?.cancel()\n    }\n}\n"]},"metadata":{},"sourceType":"module"}