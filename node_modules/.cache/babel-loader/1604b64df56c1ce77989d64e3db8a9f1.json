{"ast":null,"code":"import { fillWildcards } from './utils/fill-wildcards.mjs';\nimport { removeNonTranslationalTransform } from './utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nlet isForced = false;\n\nfunction measureAllKeyframes() {\n  if (anyNeedsMeasurement) {\n    const resolversToMeasure = Array.from(toResolve).filter(resolver => resolver.needsMeasurement);\n    const elementsToMeasure = new Set(resolversToMeasure.map(resolver => resolver.element));\n    const transformsToRestore = new Map();\n    /**\n     * Write pass\n     * If we're measuring elements we want to remove bounding box-changing transforms.\n     */\n\n    elementsToMeasure.forEach(element => {\n      const removedTransforms = removeNonTranslationalTransform(element);\n      if (!removedTransforms.length) return;\n      transformsToRestore.set(element, removedTransforms);\n      element.render();\n    }); // Read\n\n    resolversToMeasure.forEach(resolver => resolver.measureInitialState()); // Write\n\n    elementsToMeasure.forEach(element => {\n      element.render();\n      const restore = transformsToRestore.get(element);\n\n      if (restore) {\n        restore.forEach(_ref => {\n          let [key, value] = _ref;\n          element.getValue(key)?.set(value);\n        });\n      }\n    }); // Read\n\n    resolversToMeasure.forEach(resolver => resolver.measureEndState()); // Write\n\n    resolversToMeasure.forEach(resolver => {\n      if (resolver.suspendedScrollY !== undefined) {\n        window.scrollTo(0, resolver.suspendedScrollY);\n      }\n    });\n  }\n\n  anyNeedsMeasurement = false;\n  isScheduled = false;\n  toResolve.forEach(resolver => resolver.complete(isForced));\n  toResolve.clear();\n}\n\nfunction readAllKeyframes() {\n  toResolve.forEach(resolver => {\n    resolver.readKeyframes();\n\n    if (resolver.needsMeasurement) {\n      anyNeedsMeasurement = true;\n    }\n  });\n}\n\nfunction flushKeyframeResolvers() {\n  isForced = true;\n  readAllKeyframes();\n  measureAllKeyframes();\n  isForced = false;\n}\n\nclass KeyframeResolver {\n  constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n    let isAsync = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    this.state = \"pending\";\n    /**\n     * Track whether this resolver is async. If it is, it'll be added to the\n     * resolver queue and flushed in the next frame. Resolvers that aren't going\n     * to trigger read/write thrashing don't need to be async.\n     */\n\n    this.isAsync = false;\n    /**\n     * Track whether this resolver needs to perform a measurement\n     * to resolve its keyframes.\n     */\n\n    this.needsMeasurement = false;\n    this.unresolvedKeyframes = [...unresolvedKeyframes];\n    this.onComplete = onComplete;\n    this.name = name;\n    this.motionValue = motionValue;\n    this.element = element;\n    this.isAsync = isAsync;\n  }\n\n  scheduleResolve() {\n    this.state = \"scheduled\";\n\n    if (this.isAsync) {\n      toResolve.add(this);\n\n      if (!isScheduled) {\n        isScheduled = true;\n        frame.read(readAllKeyframes);\n        frame.resolveKeyframes(measureAllKeyframes);\n      }\n    } else {\n      this.readKeyframes();\n      this.complete();\n    }\n  }\n\n  readKeyframes() {\n    const {\n      unresolvedKeyframes,\n      name,\n      element,\n      motionValue\n    } = this; // If initial keyframe is null we need to read it from the DOM\n\n    if (unresolvedKeyframes[0] === null) {\n      const currentValue = motionValue?.get(); // TODO: This doesn't work if the final keyframe is a wildcard\n\n      const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n\n      if (currentValue !== undefined) {\n        unresolvedKeyframes[0] = currentValue;\n      } else if (element && name) {\n        const valueAsRead = element.readValue(name, finalKeyframe);\n\n        if (valueAsRead !== undefined && valueAsRead !== null) {\n          unresolvedKeyframes[0] = valueAsRead;\n        }\n      }\n\n      if (unresolvedKeyframes[0] === undefined) {\n        unresolvedKeyframes[0] = finalKeyframe;\n      }\n\n      if (motionValue && currentValue === undefined) {\n        motionValue.set(unresolvedKeyframes[0]);\n      }\n    }\n\n    fillWildcards(unresolvedKeyframes);\n  }\n\n  setFinalKeyframe() {}\n\n  measureInitialState() {}\n\n  renderEndStyles() {}\n\n  measureEndState() {}\n\n  complete() {\n    let isForcedComplete = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.state = \"complete\";\n    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);\n    toResolve.delete(this);\n  }\n\n  cancel() {\n    if (this.state === \"scheduled\") {\n      toResolve.delete(this);\n      this.state = \"pending\";\n    }\n  }\n\n  resume() {\n    if (this.state === \"pending\") this.scheduleResolve();\n  }\n\n}\n\nexport { KeyframeResolver, flushKeyframeResolvers };","map":{"version":3,"mappings":"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","names":["toResolve","Set","isScheduled","anyNeedsMeasurement","isForced","measureAllKeyframes","resolversToMeasure","Array","from","filter","resolver","needsMeasurement","elementsToMeasure","map","element","transformsToRestore","Map","forEach","removedTransforms","removeNonTranslationalTransform","length","set","render","measureInitialState","restore","get","key","value","getValue","measureEndState","suspendedScrollY","undefined","window","scrollTo","complete","clear","readAllKeyframes","readKeyframes","flushKeyframeResolvers","KeyframeResolver","constructor","unresolvedKeyframes","onComplete","name","motionValue","isAsync","state","scheduleResolve","add","frame","read","resolveKeyframes","currentValue","finalKeyframe","valueAsRead","readValue","fillWildcards","setFinalKeyframe","renderEndStyles","isForcedComplete","delete","cancel","resume"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\animation\\keyframes\\KeyframesResolver.ts"],"sourcesContent":["import { frame } from \"../../frameloop\"\nimport { MotionValue } from \"../../value\"\nimport { AnyResolvedKeyframe } from \"../types\"\nimport { WithRender } from \"./types\"\nimport { fillWildcards } from \"./utils/fill-wildcards\"\nimport { removeNonTranslationalTransform } from \"./utils/unit-conversion\"\n\nexport type UnresolvedKeyframes<T extends AnyResolvedKeyframe> = Array<T | null>\n\nexport type ResolvedKeyframes<T extends AnyResolvedKeyframe> = Array<T>\n\nconst toResolve = new Set<KeyframeResolver>()\nlet isScheduled = false\nlet anyNeedsMeasurement = false\nlet isForced = false\n\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter(\n            (resolver: KeyframeResolver) => resolver.needsMeasurement\n        )\n        const elementsToMeasure = new Set(\n            resolversToMeasure.map((resolver) => resolver.element)\n        )\n        const transformsToRestore = new Map<\n            WithRender,\n            [string, AnyResolvedKeyframe][]\n        >()\n\n        /**\n         * Write pass\n         * If we're measuring elements we want to remove bounding box-changing transforms.\n         */\n        elementsToMeasure.forEach((element: WithRender) => {\n            const removedTransforms = removeNonTranslationalTransform(\n                element as any\n            )\n\n            if (!removedTransforms.length) return\n\n            transformsToRestore.set(element, removedTransforms)\n\n            element.render()\n        })\n\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState())\n\n        // Write\n        elementsToMeasure.forEach((element: WithRender) => {\n            element.render()\n\n            const restore = transformsToRestore.get(element)\n            if (restore) {\n                restore.forEach(([key, value]) => {\n                    element.getValue(key)?.set(value)\n                })\n            }\n        })\n\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState())\n\n        // Write\n        resolversToMeasure.forEach((resolver) => {\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY)\n            }\n        })\n    }\n\n    anyNeedsMeasurement = false\n    isScheduled = false\n\n    toResolve.forEach((resolver) => resolver.complete(isForced))\n    toResolve.clear()\n}\n\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver) => {\n        resolver.readKeyframes()\n\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true\n        }\n    })\n}\n\nexport function flushKeyframeResolvers() {\n    isForced = true\n    readAllKeyframes()\n    measureAllKeyframes()\n    isForced = false\n}\n\nexport type OnKeyframesResolved<T extends AnyResolvedKeyframe> = (\n    resolvedKeyframes: ResolvedKeyframes<T>,\n    finalKeyframe: T,\n    forced: boolean\n) => void\n\nexport class KeyframeResolver<T extends AnyResolvedKeyframe = any> {\n    name?: string\n    element?: WithRender\n    finalKeyframe?: T\n    suspendedScrollY?: number\n\n    protected unresolvedKeyframes: UnresolvedKeyframes<AnyResolvedKeyframe>\n\n    private motionValue?: MotionValue<T>\n    private onComplete: OnKeyframesResolved<T>\n\n    state: \"pending\" | \"scheduled\" | \"complete\" = \"pending\"\n\n    /**\n     * Track whether this resolver is async. If it is, it'll be added to the\n     * resolver queue and flushed in the next frame. Resolvers that aren't going\n     * to trigger read/write thrashing don't need to be async.\n     */\n    private isAsync = false\n\n    /**\n     * Track whether this resolver needs to perform a measurement\n     * to resolve its keyframes.\n     */\n    needsMeasurement = false\n\n    constructor(\n        unresolvedKeyframes: UnresolvedKeyframes<AnyResolvedKeyframe>,\n        onComplete: OnKeyframesResolved<T>,\n        name?: string,\n        motionValue?: MotionValue<T>,\n        element?: WithRender,\n        isAsync = false\n    ) {\n        this.unresolvedKeyframes = [...unresolvedKeyframes]\n        this.onComplete = onComplete\n        this.name = name\n        this.motionValue = motionValue\n        this.element = element\n        this.isAsync = isAsync\n    }\n\n    scheduleResolve() {\n        this.state = \"scheduled\"\n\n        if (this.isAsync) {\n            toResolve.add(this)\n\n            if (!isScheduled) {\n                isScheduled = true\n                frame.read(readAllKeyframes)\n                frame.resolveKeyframes(measureAllKeyframes)\n            }\n        } else {\n            this.readKeyframes()\n            this.complete()\n        }\n    }\n\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this\n\n        // If initial keyframe is null we need to read it from the DOM\n        if (unresolvedKeyframes[0] === null) {\n            const currentValue = motionValue?.get()\n\n            // TODO: This doesn't work if the final keyframe is a wildcard\n            const finalKeyframe =\n                unresolvedKeyframes[unresolvedKeyframes.length - 1]\n\n            if (currentValue !== undefined) {\n                unresolvedKeyframes[0] = currentValue\n            } else if (element && name) {\n                const valueAsRead = element.readValue(name, finalKeyframe)\n\n                if (valueAsRead !== undefined && valueAsRead !== null) {\n                    unresolvedKeyframes[0] = valueAsRead\n                }\n            }\n\n            if (unresolvedKeyframes[0] === undefined) {\n                unresolvedKeyframes[0] = finalKeyframe\n            }\n\n            if (motionValue && currentValue === undefined) {\n                motionValue.set(unresolvedKeyframes[0] as T)\n            }\n        }\n\n        fillWildcards(unresolvedKeyframes)\n    }\n\n    setFinalKeyframe() {}\n    measureInitialState() {}\n    renderEndStyles() {}\n    measureEndState() {}\n\n    complete(isForcedComplete = false) {\n        this.state = \"complete\"\n\n        this.onComplete(\n            this.unresolvedKeyframes as ResolvedKeyframes<T>,\n            this.finalKeyframe as T,\n            isForcedComplete\n        )\n\n        toResolve.delete(this)\n    }\n\n    cancel() {\n        if (this.state === \"scheduled\") {\n            toResolve.delete(this)\n            this.state = \"pending\"\n        }\n    }\n\n    resume() {\n        if (this.state === \"pending\") this.scheduleResolve()\n    }\n}\n"]},"metadata":{},"sourceType":"module"}