{"ast":null,"code":"/**\n * react-router v7.13.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\"use client\";\n\nimport { RSCRouterGlobalErrorBoundary, deserializeErrors, getHydrationData, populateRSCRouteModules } from \"./chunk-JPUPSTYD.mjs\";\nimport { CRITICAL_CSS_DATA_ATTRIBUTE, ErrorResponseImpl, FrameworkContext, RSCRouterContext, RemixErrorBoundary, RouterProvider, createBrowserHistory, createClientRoutes, createClientRoutesWithHMRRevalidationOptOut, createContext, createRequestInit, createRouter, decodeViaTurboStream, getPatchRoutesOnNavigationFunction, getSingleFetchDataStrategyImpl, getTurboStreamSingleFetchDataStrategy, hydrationRouteProperties, invariant, isMutationMethod, mapRouteProperties, noActionDefinedError, setIsHydrated, shouldHydrateRouteLoader, singleFetchUrl, stripIndexParam, useFogOFWarDiscovery } from \"./chunk-LFPYN7LY.mjs\"; // lib/dom-export/dom-router-provider.tsx\n\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nfunction RouterProvider2(props) {\n  return /* @__PURE__ */React.createElement(RouterProvider, {\n    flushSync: ReactDOM.flushSync,\n    ...props\n  });\n} // lib/dom-export/hydrated-router.tsx\n\n\nimport * as React2 from \"react\";\nvar ssrInfo = null;\nvar router = null;\n\nfunction initSsrInfo() {\n  if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {\n    if (window.__reactRouterManifest.sri === true) {\n      const importMap = document.querySelector(\"script[rr-importmap]\");\n\n      if (importMap?.textContent) {\n        try {\n          window.__reactRouterManifest.sri = JSON.parse(importMap.textContent).integrity;\n        } catch (err) {\n          console.error(\"Failed to parse import map\", err);\n        }\n      }\n    }\n\n    ssrInfo = {\n      context: window.__reactRouterContext,\n      manifest: window.__reactRouterManifest,\n      routeModules: window.__reactRouterRouteModules,\n      stateDecodingPromise: void 0,\n      router: void 0,\n      routerInitialized: false\n    };\n  }\n}\n\nfunction createHydratedRouter(_ref) {\n  let {\n    getContext,\n    unstable_instrumentations\n  } = _ref;\n  initSsrInfo();\n\n  if (!ssrInfo) {\n    throw new Error(\"You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`\");\n  }\n\n  let localSsrInfo = ssrInfo;\n\n  if (!ssrInfo.stateDecodingPromise) {\n    let stream = ssrInfo.context.stream;\n    invariant(stream, \"No stream found for single fetch decoding\");\n    ssrInfo.context.stream = void 0;\n    ssrInfo.stateDecodingPromise = decodeViaTurboStream(stream, window).then(value => {\n      ssrInfo.context.state = value.value;\n      localSsrInfo.stateDecodingPromise.value = true;\n    }).catch(e => {\n      localSsrInfo.stateDecodingPromise.error = e;\n    });\n  }\n\n  if (ssrInfo.stateDecodingPromise.error) {\n    throw ssrInfo.stateDecodingPromise.error;\n  }\n\n  if (!ssrInfo.stateDecodingPromise.value) {\n    throw ssrInfo.stateDecodingPromise;\n  }\n\n  let routes = createClientRoutes(ssrInfo.manifest.routes, ssrInfo.routeModules, ssrInfo.context.state, ssrInfo.context.ssr, ssrInfo.context.isSpaMode);\n  let hydrationData = void 0;\n\n  if (ssrInfo.context.isSpaMode) {\n    let {\n      loaderData\n    } = ssrInfo.context.state;\n\n    if (ssrInfo.manifest.routes.root?.hasLoader && loaderData && \"root\" in loaderData) {\n      hydrationData = {\n        loaderData: {\n          root: loaderData.root\n        }\n      };\n    }\n  } else {\n    hydrationData = getHydrationData({\n      state: ssrInfo.context.state,\n      routes,\n      getRouteInfo: routeId => ({\n        clientLoader: ssrInfo.routeModules[routeId]?.clientLoader,\n        hasLoader: ssrInfo.manifest.routes[routeId]?.hasLoader === true,\n        hasHydrateFallback: ssrInfo.routeModules[routeId]?.HydrateFallback != null\n      }),\n      location: window.location,\n      basename: window.__reactRouterContext?.basename,\n      isSpaMode: ssrInfo.context.isSpaMode\n    });\n\n    if (hydrationData && hydrationData.errors) {\n      hydrationData.errors = deserializeErrors(hydrationData.errors);\n    }\n  }\n\n  if (window.history.state && window.history.state.masked) {\n    window.history.replaceState({ ...window.history.state,\n      masked: void 0\n    }, \"\");\n  }\n\n  let router2 = createRouter({\n    routes,\n    history: createBrowserHistory(),\n    basename: ssrInfo.context.basename,\n    getContext,\n    hydrationData,\n    hydrationRouteProperties,\n    unstable_instrumentations,\n    mapRouteProperties,\n    future: {\n      middleware: ssrInfo.context.future.v8_middleware\n    },\n    dataStrategy: getTurboStreamSingleFetchDataStrategy(() => router2, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.basename, ssrInfo.context.future.unstable_trailingSlashAwareDataRequests),\n    patchRoutesOnNavigation: getPatchRoutesOnNavigationFunction(() => router2, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode, ssrInfo.context.basename)\n  });\n  ssrInfo.router = router2;\n\n  if (router2.state.initialized) {\n    ssrInfo.routerInitialized = true;\n    router2.initialize();\n  }\n\n  router2.createRoutesForHMR =\n  /* spacer so ts-ignore does not affect the right hand of the assignment */\n  createClientRoutesWithHMRRevalidationOptOut;\n  window.__reactRouterDataRouter = router2;\n  return router2;\n}\n\nfunction HydratedRouter(props) {\n  if (!router) {\n    router = createHydratedRouter({\n      getContext: props.getContext,\n      unstable_instrumentations: props.unstable_instrumentations\n    });\n  }\n\n  let [criticalCss, setCriticalCss] = React2.useState(process.env.NODE_ENV === \"development\" ? ssrInfo?.context.criticalCss : void 0);\n  React2.useEffect(() => {\n    if (process.env.NODE_ENV === \"development\") {\n      setCriticalCss(void 0);\n    }\n  }, []);\n  React2.useEffect(() => {\n    if (process.env.NODE_ENV === \"development\" && criticalCss === void 0) {\n      document.querySelectorAll(`[${CRITICAL_CSS_DATA_ATTRIBUTE}]`).forEach(element => element.remove());\n    }\n  }, [criticalCss]);\n  let [location2, setLocation] = React2.useState(router.state.location);\n  React2.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\n      ssrInfo.routerInitialized = true;\n      ssrInfo.router.initialize();\n    }\n  }, []);\n  React2.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router) {\n      return ssrInfo.router.subscribe(newState => {\n        if (newState.location !== location2) {\n          setLocation(newState.location);\n        }\n      });\n    }\n  }, [location2]);\n  invariant(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\n  useFogOFWarDiscovery(router, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode);\n  return (// This fragment is important to ensure we match the <ServerRouter> JSX\n    // structure so that useId values hydrate correctly\n\n    /* @__PURE__ */\n    React2.createElement(React2.Fragment, null, /* @__PURE__ */React2.createElement(FrameworkContext.Provider, {\n      value: {\n        manifest: ssrInfo.manifest,\n        routeModules: ssrInfo.routeModules,\n        future: ssrInfo.context.future,\n        criticalCss,\n        ssr: ssrInfo.context.ssr,\n        isSpaMode: ssrInfo.context.isSpaMode,\n        routeDiscovery: ssrInfo.context.routeDiscovery\n      }\n    }, /* @__PURE__ */React2.createElement(RemixErrorBoundary, {\n      location: location2\n    }, /* @__PURE__ */React2.createElement(RouterProvider2, {\n      router,\n      unstable_useTransitions: props.unstable_useTransitions,\n      onError: props.onError\n    }))), /* @__PURE__ */React2.createElement(React2.Fragment, null))\n  );\n} // lib/rsc/browser.tsx\n\n\nimport * as React3 from \"react\";\nimport * as ReactDOM2 from \"react-dom\";\n\nfunction createCallServer(_ref2) {\n  let {\n    createFromReadableStream,\n    createTemporaryReferenceSet,\n    encodeReply,\n    fetch: fetchImplementation = fetch\n  } = _ref2;\n  const globalVar = window;\n  let landedActionId = 0;\n  return async (id, args) => {\n    let actionId = globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\n    const temporaryReferences = createTemporaryReferenceSet();\n    const payloadPromise = fetchImplementation(new Request(location.href, {\n      body: await encodeReply(args, {\n        temporaryReferences\n      }),\n      method: \"POST\",\n      headers: {\n        Accept: \"text/x-component\",\n        \"rsc-action-id\": id\n      }\n    })).then(response => {\n      if (!response.body) {\n        throw new Error(\"No response body\");\n      }\n\n      return createFromReadableStream(response.body, {\n        temporaryReferences\n      });\n    });\n    React3.startTransition(() => // @ts-expect-error - Needs React 19 types\n    Promise.resolve(payloadPromise).then(async payload => {\n      if (payload.type === \"redirect\") {\n        if (payload.reload || isExternalLocation(payload.location)) {\n          window.location.href = payload.location;\n          return;\n        }\n\n        React3.startTransition(() => {\n          globalVar.__reactRouterDataRouter.navigate(payload.location, {\n            replace: payload.replace\n          });\n        });\n        return;\n      }\n\n      if (payload.type !== \"action\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n\n      const rerender = await payload.rerender;\n\n      if (rerender && landedActionId < actionId && globalVar.__routerActionID <= actionId) {\n        if (rerender.type === \"redirect\") {\n          if (rerender.reload || isExternalLocation(rerender.location)) {\n            window.location.href = rerender.location;\n            return;\n          }\n\n          React3.startTransition(() => {\n            globalVar.__reactRouterDataRouter.navigate(rerender.location, {\n              replace: rerender.replace\n            });\n          });\n          return;\n        }\n\n        React3.startTransition(() => {\n          let lastMatch;\n\n          for (const match of rerender.matches) {\n            globalVar.__reactRouterDataRouter.patchRoutes(lastMatch?.id ?? null, [createRouteFromServerManifest(match)], true);\n\n            lastMatch = match;\n          }\n\n          window.__reactRouterDataRouter._internalSetStateDoNotUseOrYouWillBreakYourApp({\n            loaderData: Object.assign({}, globalVar.__reactRouterDataRouter.state.loaderData, rerender.loaderData),\n            errors: rerender.errors ? Object.assign({}, globalVar.__reactRouterDataRouter.state.errors, rerender.errors) : null\n          });\n        });\n      }\n    }).catch(() => {}));\n    return payloadPromise.then(payload => {\n      if (payload.type !== \"action\" && payload.type !== \"redirect\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n\n      return payload.actionResult;\n    });\n  };\n}\n\nfunction createRouterFromPayload(_ref3) {\n  let {\n    fetchImplementation,\n    createFromReadableStream,\n    getContext,\n    payload\n  } = _ref3;\n  const globalVar = window;\n  if (globalVar.__reactRouterDataRouter && globalVar.__reactRouterRouteModules) return {\n    router: globalVar.__reactRouterDataRouter,\n    routeModules: globalVar.__reactRouterRouteModules\n  };\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  globalVar.__reactRouterRouteModules = globalVar.__reactRouterRouteModules ?? {};\n  populateRSCRouteModules(globalVar.__reactRouterRouteModules, payload.matches);\n  let patches = /* @__PURE__ */new Map();\n  payload.patches?.forEach(patch => {\n    invariant(patch.parentId, \"Invalid patch parentId\");\n\n    if (!patches.has(patch.parentId)) {\n      patches.set(patch.parentId, []);\n    }\n\n    patches.get(patch.parentId)?.push(patch);\n  });\n  let routes = payload.matches.reduceRight((previous, match) => {\n    const route = createRouteFromServerManifest(match, payload);\n\n    if (previous.length > 0) {\n      route.children = previous;\n      let childrenToPatch = patches.get(match.id);\n\n      if (childrenToPatch) {\n        route.children.push(...childrenToPatch.map(r => createRouteFromServerManifest(r)));\n      }\n    }\n\n    return [route];\n  }, []);\n  globalVar.__reactRouterDataRouter = createRouter({\n    routes,\n    getContext,\n    basename: payload.basename,\n    history: createBrowserHistory(),\n    hydrationData: getHydrationData({\n      state: {\n        loaderData: payload.loaderData,\n        actionData: payload.actionData,\n        errors: payload.errors\n      },\n      routes,\n      getRouteInfo: routeId => {\n        let match = payload.matches.find(m => m.id === routeId);\n        invariant(match, \"Route not found in payload\");\n        return {\n          clientLoader: match.clientLoader,\n          hasLoader: match.hasLoader,\n          hasHydrateFallback: match.hydrateFallbackElement != null\n        };\n      },\n      location: payload.location,\n      basename: payload.basename,\n      isSpaMode: false\n    }),\n\n    async patchRoutesOnNavigation(_ref4) {\n      let {\n        path,\n        signal\n      } = _ref4;\n\n      if (discoveredPaths.has(path)) {\n        return;\n      }\n\n      await fetchAndApplyManifestPatches([path], createFromReadableStream, fetchImplementation, signal);\n    },\n\n    // FIXME: Pass `build.ssr` into this function\n    dataStrategy: getRSCSingleFetchDataStrategy(() => globalVar.__reactRouterDataRouter, true, payload.basename, createFromReadableStream, fetchImplementation)\n  });\n\n  if (globalVar.__reactRouterDataRouter.state.initialized) {\n    globalVar.__routerInitialized = true;\n\n    globalVar.__reactRouterDataRouter.initialize();\n  } else {\n    globalVar.__routerInitialized = false;\n  }\n\n  let lastLoaderData = void 0;\n\n  globalVar.__reactRouterDataRouter.subscribe(_ref5 => {\n    let {\n      loaderData,\n      actionData\n    } = _ref5;\n\n    if (lastLoaderData !== loaderData) {\n      globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\n    }\n  });\n\n  globalVar.__reactRouterDataRouter._updateRoutesForHMR = routeUpdateByRouteId => {\n    const oldRoutes = window.__reactRouterDataRouter.routes;\n    const newRoutes = [];\n\n    function walkRoutes(routes2, parentId) {\n      return routes2.map(route => {\n        const routeUpdate = routeUpdateByRouteId.get(route.id);\n\n        if (routeUpdate) {\n          const {\n            routeModule,\n            hasAction,\n            hasComponent,\n            hasErrorBoundary,\n            hasLoader\n          } = routeUpdate;\n          const newRoute = createRouteFromServerManifest({\n            clientAction: routeModule.clientAction,\n            clientLoader: routeModule.clientLoader,\n            element: route.element,\n            errorElement: route.errorElement,\n            handle: route.handle,\n            hasAction,\n            hasComponent,\n            hasErrorBoundary,\n            hasLoader,\n            hydrateFallbackElement: route.hydrateFallbackElement,\n            id: route.id,\n            index: route.index,\n            links: routeModule.links,\n            meta: routeModule.meta,\n            parentId,\n            path: route.path,\n            shouldRevalidate: routeModule.shouldRevalidate\n          });\n\n          if (route.children) {\n            newRoute.children = walkRoutes(route.children, route.id);\n          }\n\n          return newRoute;\n        }\n\n        const updatedRoute = { ...route\n        };\n\n        if (route.children) {\n          updatedRoute.children = walkRoutes(route.children, route.id);\n        }\n\n        return updatedRoute;\n      });\n    }\n\n    newRoutes.push(...walkRoutes(oldRoutes, void 0));\n\n    window.__reactRouterDataRouter._internalSetRoutes(newRoutes);\n  };\n\n  return {\n    router: globalVar.__reactRouterDataRouter,\n    routeModules: globalVar.__reactRouterRouteModules\n  };\n}\n\nvar renderedRoutesContext = createContext();\n\nfunction getRSCSingleFetchDataStrategy(getRouter, ssr, basename, createFromReadableStream, fetchImplementation) {\n  let dataStrategy = getSingleFetchDataStrategyImpl(getRouter, match => {\n    let M = match;\n    return {\n      hasLoader: M.route.hasLoader,\n      hasClientLoader: M.route.hasClientLoader,\n      hasComponent: M.route.hasComponent,\n      hasAction: M.route.hasAction,\n      hasClientAction: M.route.hasClientAction,\n      hasShouldRevalidate: M.route.hasShouldRevalidate\n    };\n  }, // pass map into fetchAndDecode so it can add payloads\n  getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation), ssr, basename, // .rsc requests are always trailing slash aware\n  true, // If the route has a component but we don't have an element, we need to hit\n  // the server loader flow regardless of whether the client loader calls\n  // `serverLoader` or not, otherwise we'll have nothing to render.\n  match => {\n    let M = match;\n    return M.route.hasComponent && !M.route.element;\n  });\n  return async args => args.runClientMiddleware(async () => {\n    let context = args.context;\n    context.set(renderedRoutesContext, []);\n    let results = await dataStrategy(args);\n    const renderedRoutesById = /* @__PURE__ */new Map();\n\n    for (const route of context.get(renderedRoutesContext)) {\n      if (!renderedRoutesById.has(route.id)) {\n        renderedRoutesById.set(route.id, []);\n      }\n\n      renderedRoutesById.get(route.id).push(route);\n    }\n\n    React3.startTransition(() => {\n      for (const match of args.matches) {\n        const renderedRoutes = renderedRoutesById.get(match.route.id);\n\n        if (renderedRoutes) {\n          for (const rendered of renderedRoutes) {\n            window.__reactRouterDataRouter.patchRoutes(rendered.parentId ?? null, [createRouteFromServerManifest(rendered)], true);\n          }\n        }\n      }\n    });\n    return results;\n  });\n}\n\nfunction getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation) {\n  return async (args, basename, trailingSlashAware, targetRoutes) => {\n    let {\n      request,\n      context\n    } = args;\n    let url = singleFetchUrl(request.url, basename, trailingSlashAware, \"rsc\");\n\n    if (request.method === \"GET\") {\n      url = stripIndexParam(url);\n\n      if (targetRoutes) {\n        url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\n      }\n    }\n\n    let res = await fetchImplementation(new Request(url, await createRequestInit(request)));\n\n    if (res.status >= 400 && !res.headers.has(\"X-Remix-Response\")) {\n      throw new ErrorResponseImpl(res.status, res.statusText, await res.text());\n    }\n\n    invariant(res.body, \"No response body to decode\");\n\n    try {\n      const payload = await createFromReadableStream(res.body, {\n        temporaryReferences: void 0\n      });\n\n      if (payload.type === \"redirect\") {\n        return {\n          status: res.status,\n          data: {\n            redirect: {\n              redirect: payload.location,\n              reload: payload.reload,\n              replace: payload.replace,\n              revalidate: false,\n              status: payload.status\n            }\n          }\n        };\n      }\n\n      if (payload.type !== \"render\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n\n      context.get(renderedRoutesContext).push(...payload.matches);\n      let results = {\n        routes: {}\n      };\n      const dataKey = isMutationMethod(request.method) ? \"actionData\" : \"loaderData\";\n\n      for (let [routeId, data] of Object.entries(payload[dataKey] || {})) {\n        results.routes[routeId] = {\n          data\n        };\n      }\n\n      if (payload.errors) {\n        for (let [routeId, error] of Object.entries(payload.errors)) {\n          results.routes[routeId] = {\n            error\n          };\n        }\n      }\n\n      return {\n        status: res.status,\n        data: results\n      };\n    } catch (e) {\n      throw new Error(\"Unable to decode RSC response\");\n    }\n  };\n}\n\nfunction RSCHydratedRouter(_ref6) {\n  let {\n    createFromReadableStream,\n    fetch: fetchImplementation = fetch,\n    payload,\n    routeDiscovery = \"eager\",\n    getContext\n  } = _ref6;\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  let {\n    router: router2,\n    routeModules\n  } = React3.useMemo(() => createRouterFromPayload({\n    payload,\n    fetchImplementation,\n    getContext,\n    createFromReadableStream\n  }), [createFromReadableStream, payload, fetchImplementation, getContext]);\n  React3.useEffect(() => {\n    setIsHydrated();\n  }, []);\n  React3.useLayoutEffect(() => {\n    const globalVar = window;\n\n    if (!globalVar.__routerInitialized) {\n      globalVar.__routerInitialized = true;\n\n      globalVar.__reactRouterDataRouter.initialize();\n    }\n  }, []);\n  let [{\n    routes,\n    state\n  }, setState] = React3.useState(() => ({\n    routes: cloneRoutes(router2.routes),\n    state: router2.state\n  }));\n  React3.useLayoutEffect(() => router2.subscribe(newState => {\n    if (diffRoutes(router2.routes, routes)) React3.startTransition(() => {\n      setState({\n        routes: cloneRoutes(router2.routes),\n        state: newState\n      });\n    });\n  }), [router2.subscribe, routes, router2]);\n  const transitionEnabledRouter = React3.useMemo(() => ({ ...router2,\n    state,\n    routes\n  }), [router2, routes, state]);\n  React3.useEffect(() => {\n    if (routeDiscovery === \"lazy\" || // @ts-expect-error - TS doesn't know about this yet\n    window.navigator?.connection?.saveData === true) {\n      return;\n    }\n\n    function registerElement(el) {\n      let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\n\n      if (!path) {\n        return;\n      }\n\n      let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\n\n      if (!discoveredPaths.has(pathname)) {\n        nextPaths.add(pathname);\n      }\n    }\n\n    async function fetchPatches() {\n      document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\n      let paths = Array.from(nextPaths.keys()).filter(path => {\n        if (discoveredPaths.has(path)) {\n          nextPaths.delete(path);\n          return false;\n        }\n\n        return true;\n      });\n\n      if (paths.length === 0) {\n        return;\n      }\n\n      try {\n        await fetchAndApplyManifestPatches(paths, createFromReadableStream, fetchImplementation);\n      } catch (e) {\n        console.error(\"Failed to fetch manifest patches\", e);\n      }\n    }\n\n    let debouncedFetchPatches = debounce(fetchPatches, 100);\n    fetchPatches();\n    let observer = new MutationObserver(() => debouncedFetchPatches());\n    observer.observe(document.documentElement, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      attributeFilter: [\"data-discover\", \"href\", \"action\"]\n    });\n  }, [routeDiscovery, createFromReadableStream, fetchImplementation]);\n  const frameworkContext = {\n    future: {\n      // These flags have no runtime impact so can always be false.  If we add\n      // flags that drive runtime behavior they'll need to be proxied through.\n      v8_middleware: false,\n      unstable_subResourceIntegrity: false,\n      unstable_trailingSlashAwareDataRequests: true // always on for RSC\n\n    },\n    isSpaMode: false,\n    ssr: true,\n    criticalCss: \"\",\n    manifest: {\n      routes: {},\n      version: \"1\",\n      url: \"\",\n      entry: {\n        module: \"\",\n        imports: []\n      }\n    },\n    routeDiscovery: {\n      mode: \"lazy\",\n      manifestPath: \"/__manifest\"\n    },\n    routeModules\n  };\n  return /* @__PURE__ */React3.createElement(RSCRouterContext.Provider, {\n    value: true\n  }, /* @__PURE__ */React3.createElement(RSCRouterGlobalErrorBoundary, {\n    location: state.location\n  }, /* @__PURE__ */React3.createElement(FrameworkContext.Provider, {\n    value: frameworkContext\n  }, /* @__PURE__ */React3.createElement(RouterProvider, {\n    router: transitionEnabledRouter,\n    flushSync: ReactDOM2.flushSync\n  }))));\n}\n\nfunction createRouteFromServerManifest(match, payload) {\n  let hasInitialData = payload && match.id in payload.loaderData;\n  let initialData = payload?.loaderData[match.id];\n  let hasInitialError = payload?.errors && match.id in payload.errors;\n  let initialError = payload?.errors?.[match.id];\n  let isHydrationRequest = match.clientLoader?.hydrate === true || !match.hasLoader || // If the route has a component but we don't have an element, we need to hit\n  // the server loader flow regardless of whether the client loader calls\n  // `serverLoader` or not, otherwise we'll have nothing to render.\n  match.hasComponent && !match.element;\n  invariant(window.__reactRouterRouteModules);\n  populateRSCRouteModules(window.__reactRouterRouteModules, match);\n  let dataRoute = {\n    id: match.id,\n    element: match.element,\n    errorElement: match.errorElement,\n    handle: match.handle,\n    hasErrorBoundary: match.hasErrorBoundary,\n    hydrateFallbackElement: match.hydrateFallbackElement,\n    index: match.index,\n    loader: match.clientLoader ? async (args, singleFetch) => {\n      try {\n        let result = await match.clientLoader({ ...args,\n          serverLoader: () => {\n            preventInvalidServerHandlerCall(\"loader\", match.id, match.hasLoader);\n\n            if (isHydrationRequest) {\n              if (hasInitialData) {\n                return initialData;\n              }\n\n              if (hasInitialError) {\n                throw initialError;\n              }\n            }\n\n            return callSingleFetch(singleFetch);\n          }\n        });\n        return result;\n      } finally {\n        isHydrationRequest = false;\n      }\n    } : // We always make the call in this RSC world since even if we don't\n    // have a `loader` we may need to get the `element` implementation\n    (_, singleFetch) => callSingleFetch(singleFetch),\n    action: match.clientAction ? (args, singleFetch) => match.clientAction({ ...args,\n      serverAction: async () => {\n        preventInvalidServerHandlerCall(\"action\", match.id, match.hasLoader);\n        return await callSingleFetch(singleFetch);\n      }\n    }) : match.hasAction ? (_, singleFetch) => callSingleFetch(singleFetch) : () => {\n      throw noActionDefinedError(\"action\", match.id);\n    },\n    path: match.path,\n    shouldRevalidate: match.shouldRevalidate,\n    // We always have a \"loader\" in this RSC world since even if we don't\n    // have a `loader` we may need to get the `element` implementation\n    hasLoader: true,\n    hasClientLoader: match.clientLoader != null,\n    hasAction: match.hasAction,\n    hasClientAction: match.clientAction != null,\n    hasShouldRevalidate: match.shouldRevalidate != null\n  };\n\n  if (typeof dataRoute.loader === \"function\") {\n    dataRoute.loader.hydrate = shouldHydrateRouteLoader(match.id, match.clientLoader, match.hasLoader, false);\n  }\n\n  return dataRoute;\n}\n\nfunction callSingleFetch(singleFetch) {\n  invariant(typeof singleFetch === \"function\", \"Invalid singleFetch parameter\");\n  return singleFetch();\n}\n\nfunction preventInvalidServerHandlerCall(type, routeId, hasHandler) {\n  if (!hasHandler) {\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n    let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${routeId}\")`;\n    console.error(msg);\n    throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n}\n\nvar nextPaths = /* @__PURE__ */new Set();\nvar discoveredPathsMaxSize = 1e3;\nvar discoveredPaths = /* @__PURE__ */new Set();\nvar URL_LIMIT = 7680;\n\nfunction getManifestUrl(paths) {\n  if (paths.length === 0) {\n    return null;\n  }\n\n  if (paths.length === 1) {\n    return new URL(`${paths[0]}.manifest`, window.location.origin);\n  }\n\n  const globalVar = window;\n  let basename = (globalVar.__reactRouterDataRouter.basename ?? \"\").replace(/^\\/|\\/$/g, \"\");\n  let url = new URL(`${basename}/.manifest`, window.location.origin);\n  url.searchParams.set(\"paths\", paths.sort().join(\",\"));\n  return url;\n}\n\nasync function fetchAndApplyManifestPatches(paths, createFromReadableStream, fetchImplementation, signal) {\n  let url = getManifestUrl(paths);\n\n  if (url == null) {\n    return;\n  }\n\n  if (url.toString().length > URL_LIMIT) {\n    nextPaths.clear();\n    return;\n  }\n\n  let response = await fetchImplementation(new Request(url, {\n    signal\n  }));\n\n  if (!response.body || response.status < 200 || response.status >= 300) {\n    throw new Error(\"Unable to fetch new route matches from the server\");\n  }\n\n  let payload = await createFromReadableStream(response.body, {\n    temporaryReferences: void 0\n  });\n\n  if (payload.type !== \"manifest\") {\n    throw new Error(\"Failed to patch routes\");\n  }\n\n  paths.forEach(p => addToFifoQueue(p, discoveredPaths));\n  React3.startTransition(() => {\n    payload.patches.forEach(p => {\n      window.__reactRouterDataRouter.patchRoutes(p.parentId ?? null, [createRouteFromServerManifest(p)]);\n    });\n  });\n}\n\nfunction addToFifoQueue(path, queue) {\n  if (queue.size >= discoveredPathsMaxSize) {\n    let first = queue.values().next().value;\n    if (typeof first === \"string\") queue.delete(first);\n  }\n\n  queue.add(path);\n}\n\nfunction debounce(callback, wait) {\n  let timeoutId;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    window.clearTimeout(timeoutId);\n    timeoutId = window.setTimeout(() => callback(...args), wait);\n  };\n}\n\nfunction isExternalLocation(location2) {\n  const newLocation = new URL(location2, window.location.href);\n  return newLocation.origin !== window.location.origin;\n}\n\nfunction cloneRoutes(routes) {\n  if (!routes) return void 0;\n  return routes.map(route => ({ ...route,\n    children: cloneRoutes(route.children)\n  }));\n}\n\nfunction diffRoutes(a, b) {\n  if (a.length !== b.length) return true;\n  return a.some((route, index) => {\n    if (route.element !== b[index].element) return true;\n    if (route.errorElement !== b[index].errorElement) return true;\n    if (route.hydrateFallbackElement !== b[index].hydrateFallbackElement) return true;\n    if (route.hasErrorBoundary !== b[index].hasErrorBoundary) return true;\n    if (route.hasLoader !== b[index].hasLoader) return true;\n    if (route.hasClientLoader !== b[index].hasClientLoader) return true;\n    if (route.hasAction !== b[index].hasAction) return true;\n    if (route.hasClientAction !== b[index].hasClientAction) return true;\n    return diffRoutes(route.children || [], b[index].children || []);\n  });\n} // lib/rsc/html-stream/browser.ts\n\n\nfunction getRSCStream() {\n  let encoder = new TextEncoder();\n  let streamController = null;\n  let rscStream = new ReadableStream({\n    start(controller) {\n      if (typeof window === \"undefined\") {\n        return;\n      }\n\n      let handleChunk = chunk => {\n        if (typeof chunk === \"string\") {\n          controller.enqueue(encoder.encode(chunk));\n        } else {\n          controller.enqueue(chunk);\n        }\n      };\n\n      window.__FLIGHT_DATA || (window.__FLIGHT_DATA = []);\n\n      window.__FLIGHT_DATA.forEach(handleChunk);\n\n      window.__FLIGHT_DATA.push = chunk => {\n        handleChunk(chunk);\n        return 0;\n      };\n\n      streamController = controller;\n    }\n\n  });\n\n  if (typeof document !== \"undefined\" && document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n      streamController?.close();\n    });\n  } else {\n    streamController?.close();\n  }\n\n  return rscStream;\n}\n\nexport { HydratedRouter, RouterProvider2 as RouterProvider, RSCHydratedRouter as unstable_RSCHydratedRouter, createCallServer as unstable_createCallServer, getRSCStream as unstable_getRSCStream };","map":{"version":3,"names":["RSCRouterGlobalErrorBoundary","deserializeErrors","getHydrationData","populateRSCRouteModules","CRITICAL_CSS_DATA_ATTRIBUTE","ErrorResponseImpl","FrameworkContext","RSCRouterContext","RemixErrorBoundary","RouterProvider","createBrowserHistory","createClientRoutes","createClientRoutesWithHMRRevalidationOptOut","createContext","createRequestInit","createRouter","decodeViaTurboStream","getPatchRoutesOnNavigationFunction","getSingleFetchDataStrategyImpl","getTurboStreamSingleFetchDataStrategy","hydrationRouteProperties","invariant","isMutationMethod","mapRouteProperties","noActionDefinedError","setIsHydrated","shouldHydrateRouteLoader","singleFetchUrl","stripIndexParam","useFogOFWarDiscovery","React","ReactDOM","RouterProvider2","props","createElement","flushSync","React2","ssrInfo","router","initSsrInfo","window","__reactRouterContext","__reactRouterManifest","__reactRouterRouteModules","sri","importMap","document","querySelector","textContent","JSON","parse","integrity","err","console","error","context","manifest","routeModules","stateDecodingPromise","routerInitialized","createHydratedRouter","getContext","unstable_instrumentations","Error","localSsrInfo","stream","then","value","state","catch","e","routes","ssr","isSpaMode","hydrationData","loaderData","root","hasLoader","getRouteInfo","routeId","clientLoader","hasHydrateFallback","HydrateFallback","location","basename","errors","history","masked","replaceState","router2","future","middleware","v8_middleware","dataStrategy","unstable_trailingSlashAwareDataRequests","patchRoutesOnNavigation","routeDiscovery","initialized","initialize","createRoutesForHMR","__reactRouterDataRouter","HydratedRouter","criticalCss","setCriticalCss","useState","process","env","NODE_ENV","useEffect","querySelectorAll","forEach","element","remove","location2","setLocation","useLayoutEffect","subscribe","newState","Fragment","Provider","unstable_useTransitions","onError","React3","ReactDOM2","createCallServer","createFromReadableStream","createTemporaryReferenceSet","encodeReply","fetch","fetchImplementation","globalVar","landedActionId","id","args","actionId","__routerActionID","temporaryReferences","payloadPromise","Request","href","body","method","headers","Accept","response","startTransition","Promise","resolve","payload","type","reload","isExternalLocation","navigate","replace","rerender","lastMatch","match","matches","patchRoutes","createRouteFromServerManifest","_internalSetStateDoNotUseOrYouWillBreakYourApp","Object","assign","actionResult","createRouterFromPayload","patches","Map","patch","parentId","has","set","get","push","reduceRight","previous","route","length","children","childrenToPatch","map","r","actionData","find","m","hydrateFallbackElement","path","signal","discoveredPaths","fetchAndApplyManifestPatches","getRSCSingleFetchDataStrategy","__routerInitialized","lastLoaderData","_updateRoutesForHMR","routeUpdateByRouteId","oldRoutes","newRoutes","walkRoutes","routes2","routeUpdate","routeModule","hasAction","hasComponent","hasErrorBoundary","newRoute","clientAction","errorElement","handle","index","links","meta","shouldRevalidate","updatedRoute","_internalSetRoutes","renderedRoutesContext","getRouter","M","hasClientLoader","hasClientAction","hasShouldRevalidate","getFetchAndDecodeViaRSC","runClientMiddleware","results","renderedRoutesById","renderedRoutes","rendered","trailingSlashAware","targetRoutes","request","url","searchParams","join","res","status","statusText","text","data","redirect","revalidate","dataKey","entries","RSCHydratedRouter","useMemo","setState","cloneRoutes","diffRoutes","transitionEnabledRouter","navigator","connection","saveData","registerElement","el","tagName","getAttribute","pathname","URL","origin","nextPaths","add","fetchPatches","paths","Array","from","keys","filter","delete","debouncedFetchPatches","debounce","observer","MutationObserver","observe","documentElement","subtree","childList","attributes","attributeFilter","frameworkContext","unstable_subResourceIntegrity","version","entry","module","imports","mode","manifestPath","hasInitialData","initialData","hasInitialError","initialError","isHydrationRequest","hydrate","dataRoute","loader","singleFetch","result","serverLoader","preventInvalidServerHandlerCall","callSingleFetch","_","action","serverAction","hasHandler","fn","msg","Set","discoveredPathsMaxSize","URL_LIMIT","getManifestUrl","sort","toString","clear","p","addToFifoQueue","queue","size","first","values","next","callback","wait","timeoutId","clearTimeout","setTimeout","newLocation","a","b","some","getRSCStream","encoder","TextEncoder","streamController","rscStream","ReadableStream","start","controller","handleChunk","chunk","enqueue","encode","__FLIGHT_DATA","readyState","addEventListener","close","unstable_RSCHydratedRouter","unstable_createCallServer","unstable_getRSCStream"],"sources":["C:/Projects/TVMazee/node_modules/react-router/dist/development/dom-export.mjs"],"sourcesContent":["/**\n * react-router v7.13.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\"use client\";\nimport {\n  RSCRouterGlobalErrorBoundary,\n  deserializeErrors,\n  getHydrationData,\n  populateRSCRouteModules\n} from \"./chunk-JPUPSTYD.mjs\";\nimport {\n  CRITICAL_CSS_DATA_ATTRIBUTE,\n  ErrorResponseImpl,\n  FrameworkContext,\n  RSCRouterContext,\n  RemixErrorBoundary,\n  RouterProvider,\n  createBrowserHistory,\n  createClientRoutes,\n  createClientRoutesWithHMRRevalidationOptOut,\n  createContext,\n  createRequestInit,\n  createRouter,\n  decodeViaTurboStream,\n  getPatchRoutesOnNavigationFunction,\n  getSingleFetchDataStrategyImpl,\n  getTurboStreamSingleFetchDataStrategy,\n  hydrationRouteProperties,\n  invariant,\n  isMutationMethod,\n  mapRouteProperties,\n  noActionDefinedError,\n  setIsHydrated,\n  shouldHydrateRouteLoader,\n  singleFetchUrl,\n  stripIndexParam,\n  useFogOFWarDiscovery\n} from \"./chunk-LFPYN7LY.mjs\";\n\n// lib/dom-export/dom-router-provider.tsx\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nfunction RouterProvider2(props) {\n  return /* @__PURE__ */ React.createElement(RouterProvider, { flushSync: ReactDOM.flushSync, ...props });\n}\n\n// lib/dom-export/hydrated-router.tsx\nimport * as React2 from \"react\";\nvar ssrInfo = null;\nvar router = null;\nfunction initSsrInfo() {\n  if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {\n    if (window.__reactRouterManifest.sri === true) {\n      const importMap = document.querySelector(\"script[rr-importmap]\");\n      if (importMap?.textContent) {\n        try {\n          window.__reactRouterManifest.sri = JSON.parse(\n            importMap.textContent\n          ).integrity;\n        } catch (err) {\n          console.error(\"Failed to parse import map\", err);\n        }\n      }\n    }\n    ssrInfo = {\n      context: window.__reactRouterContext,\n      manifest: window.__reactRouterManifest,\n      routeModules: window.__reactRouterRouteModules,\n      stateDecodingPromise: void 0,\n      router: void 0,\n      routerInitialized: false\n    };\n  }\n}\nfunction createHydratedRouter({\n  getContext,\n  unstable_instrumentations\n}) {\n  initSsrInfo();\n  if (!ssrInfo) {\n    throw new Error(\n      \"You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`\"\n    );\n  }\n  let localSsrInfo = ssrInfo;\n  if (!ssrInfo.stateDecodingPromise) {\n    let stream = ssrInfo.context.stream;\n    invariant(stream, \"No stream found for single fetch decoding\");\n    ssrInfo.context.stream = void 0;\n    ssrInfo.stateDecodingPromise = decodeViaTurboStream(stream, window).then((value) => {\n      ssrInfo.context.state = value.value;\n      localSsrInfo.stateDecodingPromise.value = true;\n    }).catch((e) => {\n      localSsrInfo.stateDecodingPromise.error = e;\n    });\n  }\n  if (ssrInfo.stateDecodingPromise.error) {\n    throw ssrInfo.stateDecodingPromise.error;\n  }\n  if (!ssrInfo.stateDecodingPromise.value) {\n    throw ssrInfo.stateDecodingPromise;\n  }\n  let routes = createClientRoutes(\n    ssrInfo.manifest.routes,\n    ssrInfo.routeModules,\n    ssrInfo.context.state,\n    ssrInfo.context.ssr,\n    ssrInfo.context.isSpaMode\n  );\n  let hydrationData = void 0;\n  if (ssrInfo.context.isSpaMode) {\n    let { loaderData } = ssrInfo.context.state;\n    if (ssrInfo.manifest.routes.root?.hasLoader && loaderData && \"root\" in loaderData) {\n      hydrationData = {\n        loaderData: {\n          root: loaderData.root\n        }\n      };\n    }\n  } else {\n    hydrationData = getHydrationData({\n      state: ssrInfo.context.state,\n      routes,\n      getRouteInfo: (routeId) => ({\n        clientLoader: ssrInfo.routeModules[routeId]?.clientLoader,\n        hasLoader: ssrInfo.manifest.routes[routeId]?.hasLoader === true,\n        hasHydrateFallback: ssrInfo.routeModules[routeId]?.HydrateFallback != null\n      }),\n      location: window.location,\n      basename: window.__reactRouterContext?.basename,\n      isSpaMode: ssrInfo.context.isSpaMode\n    });\n    if (hydrationData && hydrationData.errors) {\n      hydrationData.errors = deserializeErrors(hydrationData.errors);\n    }\n  }\n  if (window.history.state && window.history.state.masked) {\n    window.history.replaceState(\n      { ...window.history.state, masked: void 0 },\n      \"\"\n    );\n  }\n  let router2 = createRouter({\n    routes,\n    history: createBrowserHistory(),\n    basename: ssrInfo.context.basename,\n    getContext,\n    hydrationData,\n    hydrationRouteProperties,\n    unstable_instrumentations,\n    mapRouteProperties,\n    future: {\n      middleware: ssrInfo.context.future.v8_middleware\n    },\n    dataStrategy: getTurboStreamSingleFetchDataStrategy(\n      () => router2,\n      ssrInfo.manifest,\n      ssrInfo.routeModules,\n      ssrInfo.context.ssr,\n      ssrInfo.context.basename,\n      ssrInfo.context.future.unstable_trailingSlashAwareDataRequests\n    ),\n    patchRoutesOnNavigation: getPatchRoutesOnNavigationFunction(\n      () => router2,\n      ssrInfo.manifest,\n      ssrInfo.routeModules,\n      ssrInfo.context.ssr,\n      ssrInfo.context.routeDiscovery,\n      ssrInfo.context.isSpaMode,\n      ssrInfo.context.basename\n    )\n  });\n  ssrInfo.router = router2;\n  if (router2.state.initialized) {\n    ssrInfo.routerInitialized = true;\n    router2.initialize();\n  }\n  router2.createRoutesForHMR = /* spacer so ts-ignore does not affect the right hand of the assignment */\n  createClientRoutesWithHMRRevalidationOptOut;\n  window.__reactRouterDataRouter = router2;\n  return router2;\n}\nfunction HydratedRouter(props) {\n  if (!router) {\n    router = createHydratedRouter({\n      getContext: props.getContext,\n      unstable_instrumentations: props.unstable_instrumentations\n    });\n  }\n  let [criticalCss, setCriticalCss] = React2.useState(\n    process.env.NODE_ENV === \"development\" ? ssrInfo?.context.criticalCss : void 0\n  );\n  React2.useEffect(() => {\n    if (process.env.NODE_ENV === \"development\") {\n      setCriticalCss(void 0);\n    }\n  }, []);\n  React2.useEffect(() => {\n    if (process.env.NODE_ENV === \"development\" && criticalCss === void 0) {\n      document.querySelectorAll(`[${CRITICAL_CSS_DATA_ATTRIBUTE}]`).forEach((element) => element.remove());\n    }\n  }, [criticalCss]);\n  let [location2, setLocation] = React2.useState(router.state.location);\n  React2.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\n      ssrInfo.routerInitialized = true;\n      ssrInfo.router.initialize();\n    }\n  }, []);\n  React2.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router) {\n      return ssrInfo.router.subscribe((newState) => {\n        if (newState.location !== location2) {\n          setLocation(newState.location);\n        }\n      });\n    }\n  }, [location2]);\n  invariant(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\n  useFogOFWarDiscovery(\n    router,\n    ssrInfo.manifest,\n    ssrInfo.routeModules,\n    ssrInfo.context.ssr,\n    ssrInfo.context.routeDiscovery,\n    ssrInfo.context.isSpaMode\n  );\n  return (\n    // This fragment is important to ensure we match the <ServerRouter> JSX\n    // structure so that useId values hydrate correctly\n    /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\n      FrameworkContext.Provider,\n      {\n        value: {\n          manifest: ssrInfo.manifest,\n          routeModules: ssrInfo.routeModules,\n          future: ssrInfo.context.future,\n          criticalCss,\n          ssr: ssrInfo.context.ssr,\n          isSpaMode: ssrInfo.context.isSpaMode,\n          routeDiscovery: ssrInfo.context.routeDiscovery\n        }\n      },\n      /* @__PURE__ */ React2.createElement(RemixErrorBoundary, { location: location2 }, /* @__PURE__ */ React2.createElement(\n        RouterProvider2,\n        {\n          router,\n          unstable_useTransitions: props.unstable_useTransitions,\n          onError: props.onError\n        }\n      ))\n    ), /* @__PURE__ */ React2.createElement(React2.Fragment, null))\n  );\n}\n\n// lib/rsc/browser.tsx\nimport * as React3 from \"react\";\nimport * as ReactDOM2 from \"react-dom\";\nfunction createCallServer({\n  createFromReadableStream,\n  createTemporaryReferenceSet,\n  encodeReply,\n  fetch: fetchImplementation = fetch\n}) {\n  const globalVar = window;\n  let landedActionId = 0;\n  return async (id, args) => {\n    let actionId = globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\n    const temporaryReferences = createTemporaryReferenceSet();\n    const payloadPromise = fetchImplementation(\n      new Request(location.href, {\n        body: await encodeReply(args, { temporaryReferences }),\n        method: \"POST\",\n        headers: {\n          Accept: \"text/x-component\",\n          \"rsc-action-id\": id\n        }\n      })\n    ).then((response) => {\n      if (!response.body) {\n        throw new Error(\"No response body\");\n      }\n      return createFromReadableStream(response.body, {\n        temporaryReferences\n      });\n    });\n    React3.startTransition(\n      () => (\n        // @ts-expect-error - Needs React 19 types\n        Promise.resolve(payloadPromise).then(async (payload) => {\n          if (payload.type === \"redirect\") {\n            if (payload.reload || isExternalLocation(payload.location)) {\n              window.location.href = payload.location;\n              return;\n            }\n            React3.startTransition(() => {\n              globalVar.__reactRouterDataRouter.navigate(payload.location, {\n                replace: payload.replace\n              });\n            });\n            return;\n          }\n          if (payload.type !== \"action\") {\n            throw new Error(\"Unexpected payload type\");\n          }\n          const rerender = await payload.rerender;\n          if (rerender && landedActionId < actionId && globalVar.__routerActionID <= actionId) {\n            if (rerender.type === \"redirect\") {\n              if (rerender.reload || isExternalLocation(rerender.location)) {\n                window.location.href = rerender.location;\n                return;\n              }\n              React3.startTransition(() => {\n                globalVar.__reactRouterDataRouter.navigate(rerender.location, {\n                  replace: rerender.replace\n                });\n              });\n              return;\n            }\n            React3.startTransition(() => {\n              let lastMatch;\n              for (const match of rerender.matches) {\n                globalVar.__reactRouterDataRouter.patchRoutes(\n                  lastMatch?.id ?? null,\n                  [createRouteFromServerManifest(match)],\n                  true\n                );\n                lastMatch = match;\n              }\n              window.__reactRouterDataRouter._internalSetStateDoNotUseOrYouWillBreakYourApp(\n                {\n                  loaderData: Object.assign(\n                    {},\n                    globalVar.__reactRouterDataRouter.state.loaderData,\n                    rerender.loaderData\n                  ),\n                  errors: rerender.errors ? Object.assign(\n                    {},\n                    globalVar.__reactRouterDataRouter.state.errors,\n                    rerender.errors\n                  ) : null\n                }\n              );\n            });\n          }\n        }).catch(() => {\n        })\n      )\n    );\n    return payloadPromise.then((payload) => {\n      if (payload.type !== \"action\" && payload.type !== \"redirect\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n      return payload.actionResult;\n    });\n  };\n}\nfunction createRouterFromPayload({\n  fetchImplementation,\n  createFromReadableStream,\n  getContext,\n  payload\n}) {\n  const globalVar = window;\n  if (globalVar.__reactRouterDataRouter && globalVar.__reactRouterRouteModules)\n    return {\n      router: globalVar.__reactRouterDataRouter,\n      routeModules: globalVar.__reactRouterRouteModules\n    };\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  globalVar.__reactRouterRouteModules = globalVar.__reactRouterRouteModules ?? {};\n  populateRSCRouteModules(globalVar.__reactRouterRouteModules, payload.matches);\n  let patches = /* @__PURE__ */ new Map();\n  payload.patches?.forEach((patch) => {\n    invariant(patch.parentId, \"Invalid patch parentId\");\n    if (!patches.has(patch.parentId)) {\n      patches.set(patch.parentId, []);\n    }\n    patches.get(patch.parentId)?.push(patch);\n  });\n  let routes = payload.matches.reduceRight((previous, match) => {\n    const route = createRouteFromServerManifest(\n      match,\n      payload\n    );\n    if (previous.length > 0) {\n      route.children = previous;\n      let childrenToPatch = patches.get(match.id);\n      if (childrenToPatch) {\n        route.children.push(\n          ...childrenToPatch.map((r) => createRouteFromServerManifest(r))\n        );\n      }\n    }\n    return [route];\n  }, []);\n  globalVar.__reactRouterDataRouter = createRouter({\n    routes,\n    getContext,\n    basename: payload.basename,\n    history: createBrowserHistory(),\n    hydrationData: getHydrationData({\n      state: {\n        loaderData: payload.loaderData,\n        actionData: payload.actionData,\n        errors: payload.errors\n      },\n      routes,\n      getRouteInfo: (routeId) => {\n        let match = payload.matches.find((m) => m.id === routeId);\n        invariant(match, \"Route not found in payload\");\n        return {\n          clientLoader: match.clientLoader,\n          hasLoader: match.hasLoader,\n          hasHydrateFallback: match.hydrateFallbackElement != null\n        };\n      },\n      location: payload.location,\n      basename: payload.basename,\n      isSpaMode: false\n    }),\n    async patchRoutesOnNavigation({ path, signal }) {\n      if (discoveredPaths.has(path)) {\n        return;\n      }\n      await fetchAndApplyManifestPatches(\n        [path],\n        createFromReadableStream,\n        fetchImplementation,\n        signal\n      );\n    },\n    // FIXME: Pass `build.ssr` into this function\n    dataStrategy: getRSCSingleFetchDataStrategy(\n      () => globalVar.__reactRouterDataRouter,\n      true,\n      payload.basename,\n      createFromReadableStream,\n      fetchImplementation\n    )\n  });\n  if (globalVar.__reactRouterDataRouter.state.initialized) {\n    globalVar.__routerInitialized = true;\n    globalVar.__reactRouterDataRouter.initialize();\n  } else {\n    globalVar.__routerInitialized = false;\n  }\n  let lastLoaderData = void 0;\n  globalVar.__reactRouterDataRouter.subscribe(({ loaderData, actionData }) => {\n    if (lastLoaderData !== loaderData) {\n      globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\n    }\n  });\n  globalVar.__reactRouterDataRouter._updateRoutesForHMR = (routeUpdateByRouteId) => {\n    const oldRoutes = window.__reactRouterDataRouter.routes;\n    const newRoutes = [];\n    function walkRoutes(routes2, parentId) {\n      return routes2.map((route) => {\n        const routeUpdate = routeUpdateByRouteId.get(route.id);\n        if (routeUpdate) {\n          const {\n            routeModule,\n            hasAction,\n            hasComponent,\n            hasErrorBoundary,\n            hasLoader\n          } = routeUpdate;\n          const newRoute = createRouteFromServerManifest({\n            clientAction: routeModule.clientAction,\n            clientLoader: routeModule.clientLoader,\n            element: route.element,\n            errorElement: route.errorElement,\n            handle: route.handle,\n            hasAction,\n            hasComponent,\n            hasErrorBoundary,\n            hasLoader,\n            hydrateFallbackElement: route.hydrateFallbackElement,\n            id: route.id,\n            index: route.index,\n            links: routeModule.links,\n            meta: routeModule.meta,\n            parentId,\n            path: route.path,\n            shouldRevalidate: routeModule.shouldRevalidate\n          });\n          if (route.children) {\n            newRoute.children = walkRoutes(route.children, route.id);\n          }\n          return newRoute;\n        }\n        const updatedRoute = { ...route };\n        if (route.children) {\n          updatedRoute.children = walkRoutes(route.children, route.id);\n        }\n        return updatedRoute;\n      });\n    }\n    newRoutes.push(\n      ...walkRoutes(oldRoutes, void 0)\n    );\n    window.__reactRouterDataRouter._internalSetRoutes(newRoutes);\n  };\n  return {\n    router: globalVar.__reactRouterDataRouter,\n    routeModules: globalVar.__reactRouterRouteModules\n  };\n}\nvar renderedRoutesContext = createContext();\nfunction getRSCSingleFetchDataStrategy(getRouter, ssr, basename, createFromReadableStream, fetchImplementation) {\n  let dataStrategy = getSingleFetchDataStrategyImpl(\n    getRouter,\n    (match) => {\n      let M = match;\n      return {\n        hasLoader: M.route.hasLoader,\n        hasClientLoader: M.route.hasClientLoader,\n        hasComponent: M.route.hasComponent,\n        hasAction: M.route.hasAction,\n        hasClientAction: M.route.hasClientAction,\n        hasShouldRevalidate: M.route.hasShouldRevalidate\n      };\n    },\n    // pass map into fetchAndDecode so it can add payloads\n    getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation),\n    ssr,\n    basename,\n    // .rsc requests are always trailing slash aware\n    true,\n    // If the route has a component but we don't have an element, we need to hit\n    // the server loader flow regardless of whether the client loader calls\n    // `serverLoader` or not, otherwise we'll have nothing to render.\n    (match) => {\n      let M = match;\n      return M.route.hasComponent && !M.route.element;\n    }\n  );\n  return async (args) => args.runClientMiddleware(async () => {\n    let context = args.context;\n    context.set(renderedRoutesContext, []);\n    let results = await dataStrategy(args);\n    const renderedRoutesById = /* @__PURE__ */ new Map();\n    for (const route of context.get(renderedRoutesContext)) {\n      if (!renderedRoutesById.has(route.id)) {\n        renderedRoutesById.set(route.id, []);\n      }\n      renderedRoutesById.get(route.id).push(route);\n    }\n    React3.startTransition(() => {\n      for (const match of args.matches) {\n        const renderedRoutes = renderedRoutesById.get(match.route.id);\n        if (renderedRoutes) {\n          for (const rendered of renderedRoutes) {\n            window.__reactRouterDataRouter.patchRoutes(\n              rendered.parentId ?? null,\n              [createRouteFromServerManifest(rendered)],\n              true\n            );\n          }\n        }\n      }\n    });\n    return results;\n  });\n}\nfunction getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation) {\n  return async (args, basename, trailingSlashAware, targetRoutes) => {\n    let { request, context } = args;\n    let url = singleFetchUrl(request.url, basename, trailingSlashAware, \"rsc\");\n    if (request.method === \"GET\") {\n      url = stripIndexParam(url);\n      if (targetRoutes) {\n        url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\n      }\n    }\n    let res = await fetchImplementation(\n      new Request(url, await createRequestInit(request))\n    );\n    if (res.status >= 400 && !res.headers.has(\"X-Remix-Response\")) {\n      throw new ErrorResponseImpl(res.status, res.statusText, await res.text());\n    }\n    invariant(res.body, \"No response body to decode\");\n    try {\n      const payload = await createFromReadableStream(res.body, {\n        temporaryReferences: void 0\n      });\n      if (payload.type === \"redirect\") {\n        return {\n          status: res.status,\n          data: {\n            redirect: {\n              redirect: payload.location,\n              reload: payload.reload,\n              replace: payload.replace,\n              revalidate: false,\n              status: payload.status\n            }\n          }\n        };\n      }\n      if (payload.type !== \"render\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n      context.get(renderedRoutesContext).push(...payload.matches);\n      let results = { routes: {} };\n      const dataKey = isMutationMethod(request.method) ? \"actionData\" : \"loaderData\";\n      for (let [routeId, data] of Object.entries(payload[dataKey] || {})) {\n        results.routes[routeId] = { data };\n      }\n      if (payload.errors) {\n        for (let [routeId, error] of Object.entries(payload.errors)) {\n          results.routes[routeId] = { error };\n        }\n      }\n      return { status: res.status, data: results };\n    } catch (e) {\n      throw new Error(\"Unable to decode RSC response\");\n    }\n  };\n}\nfunction RSCHydratedRouter({\n  createFromReadableStream,\n  fetch: fetchImplementation = fetch,\n  payload,\n  routeDiscovery = \"eager\",\n  getContext\n}) {\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  let { router: router2, routeModules } = React3.useMemo(\n    () => createRouterFromPayload({\n      payload,\n      fetchImplementation,\n      getContext,\n      createFromReadableStream\n    }),\n    [createFromReadableStream, payload, fetchImplementation, getContext]\n  );\n  React3.useEffect(() => {\n    setIsHydrated();\n  }, []);\n  React3.useLayoutEffect(() => {\n    const globalVar = window;\n    if (!globalVar.__routerInitialized) {\n      globalVar.__routerInitialized = true;\n      globalVar.__reactRouterDataRouter.initialize();\n    }\n  }, []);\n  let [{ routes, state }, setState] = React3.useState(() => ({\n    routes: cloneRoutes(router2.routes),\n    state: router2.state\n  }));\n  React3.useLayoutEffect(\n    () => router2.subscribe((newState) => {\n      if (diffRoutes(router2.routes, routes))\n        React3.startTransition(() => {\n          setState({\n            routes: cloneRoutes(router2.routes),\n            state: newState\n          });\n        });\n    }),\n    [router2.subscribe, routes, router2]\n  );\n  const transitionEnabledRouter = React3.useMemo(\n    () => ({\n      ...router2,\n      state,\n      routes\n    }),\n    [router2, routes, state]\n  );\n  React3.useEffect(() => {\n    if (routeDiscovery === \"lazy\" || // @ts-expect-error - TS doesn't know about this yet\n    window.navigator?.connection?.saveData === true) {\n      return;\n    }\n    function registerElement(el) {\n      let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\n      if (!path) {\n        return;\n      }\n      let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\n      if (!discoveredPaths.has(pathname)) {\n        nextPaths.add(pathname);\n      }\n    }\n    async function fetchPatches() {\n      document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\n      let paths = Array.from(nextPaths.keys()).filter((path) => {\n        if (discoveredPaths.has(path)) {\n          nextPaths.delete(path);\n          return false;\n        }\n        return true;\n      });\n      if (paths.length === 0) {\n        return;\n      }\n      try {\n        await fetchAndApplyManifestPatches(\n          paths,\n          createFromReadableStream,\n          fetchImplementation\n        );\n      } catch (e) {\n        console.error(\"Failed to fetch manifest patches\", e);\n      }\n    }\n    let debouncedFetchPatches = debounce(fetchPatches, 100);\n    fetchPatches();\n    let observer = new MutationObserver(() => debouncedFetchPatches());\n    observer.observe(document.documentElement, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      attributeFilter: [\"data-discover\", \"href\", \"action\"]\n    });\n  }, [routeDiscovery, createFromReadableStream, fetchImplementation]);\n  const frameworkContext = {\n    future: {\n      // These flags have no runtime impact so can always be false.  If we add\n      // flags that drive runtime behavior they'll need to be proxied through.\n      v8_middleware: false,\n      unstable_subResourceIntegrity: false,\n      unstable_trailingSlashAwareDataRequests: true\n      // always on for RSC\n    },\n    isSpaMode: false,\n    ssr: true,\n    criticalCss: \"\",\n    manifest: {\n      routes: {},\n      version: \"1\",\n      url: \"\",\n      entry: {\n        module: \"\",\n        imports: []\n      }\n    },\n    routeDiscovery: { mode: \"lazy\", manifestPath: \"/__manifest\" },\n    routeModules\n  };\n  return /* @__PURE__ */ React3.createElement(RSCRouterContext.Provider, { value: true }, /* @__PURE__ */ React3.createElement(RSCRouterGlobalErrorBoundary, { location: state.location }, /* @__PURE__ */ React3.createElement(FrameworkContext.Provider, { value: frameworkContext }, /* @__PURE__ */ React3.createElement(\n    RouterProvider,\n    {\n      router: transitionEnabledRouter,\n      flushSync: ReactDOM2.flushSync\n    }\n  ))));\n}\nfunction createRouteFromServerManifest(match, payload) {\n  let hasInitialData = payload && match.id in payload.loaderData;\n  let initialData = payload?.loaderData[match.id];\n  let hasInitialError = payload?.errors && match.id in payload.errors;\n  let initialError = payload?.errors?.[match.id];\n  let isHydrationRequest = match.clientLoader?.hydrate === true || !match.hasLoader || // If the route has a component but we don't have an element, we need to hit\n  // the server loader flow regardless of whether the client loader calls\n  // `serverLoader` or not, otherwise we'll have nothing to render.\n  match.hasComponent && !match.element;\n  invariant(window.__reactRouterRouteModules);\n  populateRSCRouteModules(window.__reactRouterRouteModules, match);\n  let dataRoute = {\n    id: match.id,\n    element: match.element,\n    errorElement: match.errorElement,\n    handle: match.handle,\n    hasErrorBoundary: match.hasErrorBoundary,\n    hydrateFallbackElement: match.hydrateFallbackElement,\n    index: match.index,\n    loader: match.clientLoader ? async (args, singleFetch) => {\n      try {\n        let result = await match.clientLoader({\n          ...args,\n          serverLoader: () => {\n            preventInvalidServerHandlerCall(\n              \"loader\",\n              match.id,\n              match.hasLoader\n            );\n            if (isHydrationRequest) {\n              if (hasInitialData) {\n                return initialData;\n              }\n              if (hasInitialError) {\n                throw initialError;\n              }\n            }\n            return callSingleFetch(singleFetch);\n          }\n        });\n        return result;\n      } finally {\n        isHydrationRequest = false;\n      }\n    } : (\n      // We always make the call in this RSC world since even if we don't\n      // have a `loader` we may need to get the `element` implementation\n      (_, singleFetch) => callSingleFetch(singleFetch)\n    ),\n    action: match.clientAction ? (args, singleFetch) => match.clientAction({\n      ...args,\n      serverAction: async () => {\n        preventInvalidServerHandlerCall(\n          \"action\",\n          match.id,\n          match.hasLoader\n        );\n        return await callSingleFetch(singleFetch);\n      }\n    }) : match.hasAction ? (_, singleFetch) => callSingleFetch(singleFetch) : () => {\n      throw noActionDefinedError(\"action\", match.id);\n    },\n    path: match.path,\n    shouldRevalidate: match.shouldRevalidate,\n    // We always have a \"loader\" in this RSC world since even if we don't\n    // have a `loader` we may need to get the `element` implementation\n    hasLoader: true,\n    hasClientLoader: match.clientLoader != null,\n    hasAction: match.hasAction,\n    hasClientAction: match.clientAction != null,\n    hasShouldRevalidate: match.shouldRevalidate != null\n  };\n  if (typeof dataRoute.loader === \"function\") {\n    dataRoute.loader.hydrate = shouldHydrateRouteLoader(\n      match.id,\n      match.clientLoader,\n      match.hasLoader,\n      false\n    );\n  }\n  return dataRoute;\n}\nfunction callSingleFetch(singleFetch) {\n  invariant(typeof singleFetch === \"function\", \"Invalid singleFetch parameter\");\n  return singleFetch();\n}\nfunction preventInvalidServerHandlerCall(type, routeId, hasHandler) {\n  if (!hasHandler) {\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n    let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${routeId}\")`;\n    console.error(msg);\n    throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n}\nvar nextPaths = /* @__PURE__ */ new Set();\nvar discoveredPathsMaxSize = 1e3;\nvar discoveredPaths = /* @__PURE__ */ new Set();\nvar URL_LIMIT = 7680;\nfunction getManifestUrl(paths) {\n  if (paths.length === 0) {\n    return null;\n  }\n  if (paths.length === 1) {\n    return new URL(`${paths[0]}.manifest`, window.location.origin);\n  }\n  const globalVar = window;\n  let basename = (globalVar.__reactRouterDataRouter.basename ?? \"\").replace(\n    /^\\/|\\/$/g,\n    \"\"\n  );\n  let url = new URL(`${basename}/.manifest`, window.location.origin);\n  url.searchParams.set(\"paths\", paths.sort().join(\",\"));\n  return url;\n}\nasync function fetchAndApplyManifestPatches(paths, createFromReadableStream, fetchImplementation, signal) {\n  let url = getManifestUrl(paths);\n  if (url == null) {\n    return;\n  }\n  if (url.toString().length > URL_LIMIT) {\n    nextPaths.clear();\n    return;\n  }\n  let response = await fetchImplementation(new Request(url, { signal }));\n  if (!response.body || response.status < 200 || response.status >= 300) {\n    throw new Error(\"Unable to fetch new route matches from the server\");\n  }\n  let payload = await createFromReadableStream(response.body, {\n    temporaryReferences: void 0\n  });\n  if (payload.type !== \"manifest\") {\n    throw new Error(\"Failed to patch routes\");\n  }\n  paths.forEach((p) => addToFifoQueue(p, discoveredPaths));\n  React3.startTransition(() => {\n    payload.patches.forEach((p) => {\n      window.__reactRouterDataRouter.patchRoutes(\n        p.parentId ?? null,\n        [createRouteFromServerManifest(p)]\n      );\n    });\n  });\n}\nfunction addToFifoQueue(path, queue) {\n  if (queue.size >= discoveredPathsMaxSize) {\n    let first = queue.values().next().value;\n    if (typeof first === \"string\") queue.delete(first);\n  }\n  queue.add(path);\n}\nfunction debounce(callback, wait) {\n  let timeoutId;\n  return (...args) => {\n    window.clearTimeout(timeoutId);\n    timeoutId = window.setTimeout(() => callback(...args), wait);\n  };\n}\nfunction isExternalLocation(location2) {\n  const newLocation = new URL(location2, window.location.href);\n  return newLocation.origin !== window.location.origin;\n}\nfunction cloneRoutes(routes) {\n  if (!routes) return void 0;\n  return routes.map((route) => ({\n    ...route,\n    children: cloneRoutes(route.children)\n  }));\n}\nfunction diffRoutes(a, b) {\n  if (a.length !== b.length) return true;\n  return a.some((route, index) => {\n    if (route.element !== b[index].element) return true;\n    if (route.errorElement !== b[index].errorElement)\n      return true;\n    if (route.hydrateFallbackElement !== b[index].hydrateFallbackElement)\n      return true;\n    if (route.hasErrorBoundary !== b[index].hasErrorBoundary)\n      return true;\n    if (route.hasLoader !== b[index].hasLoader) return true;\n    if (route.hasClientLoader !== b[index].hasClientLoader)\n      return true;\n    if (route.hasAction !== b[index].hasAction) return true;\n    if (route.hasClientAction !== b[index].hasClientAction)\n      return true;\n    return diffRoutes(route.children || [], b[index].children || []);\n  });\n}\n\n// lib/rsc/html-stream/browser.ts\nfunction getRSCStream() {\n  let encoder = new TextEncoder();\n  let streamController = null;\n  let rscStream = new ReadableStream({\n    start(controller) {\n      if (typeof window === \"undefined\") {\n        return;\n      }\n      let handleChunk = (chunk) => {\n        if (typeof chunk === \"string\") {\n          controller.enqueue(encoder.encode(chunk));\n        } else {\n          controller.enqueue(chunk);\n        }\n      };\n      window.__FLIGHT_DATA || (window.__FLIGHT_DATA = []);\n      window.__FLIGHT_DATA.forEach(handleChunk);\n      window.__FLIGHT_DATA.push = (chunk) => {\n        handleChunk(chunk);\n        return 0;\n      };\n      streamController = controller;\n    }\n  });\n  if (typeof document !== \"undefined\" && document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n      streamController?.close();\n    });\n  } else {\n    streamController?.close();\n  }\n  return rscStream;\n}\nexport {\n  HydratedRouter,\n  RouterProvider2 as RouterProvider,\n  RSCHydratedRouter as unstable_RSCHydratedRouter,\n  createCallServer as unstable_createCallServer,\n  getRSCStream as unstable_getRSCStream\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SACEA,4BADF,EAEEC,iBAFF,EAGEC,gBAHF,EAIEC,uBAJF,QAKO,sBALP;AAMA,SACEC,2BADF,EAEEC,iBAFF,EAGEC,gBAHF,EAIEC,gBAJF,EAKEC,kBALF,EAMEC,cANF,EAOEC,oBAPF,EAQEC,kBARF,EASEC,2CATF,EAUEC,aAVF,EAWEC,iBAXF,EAYEC,YAZF,EAaEC,oBAbF,EAcEC,kCAdF,EAeEC,8BAfF,EAgBEC,qCAhBF,EAiBEC,wBAjBF,EAkBEC,SAlBF,EAmBEC,gBAnBF,EAoBEC,kBApBF,EAqBEC,oBArBF,EAsBEC,aAtBF,EAuBEC,wBAvBF,EAwBEC,cAxBF,EAyBEC,eAzBF,EA0BEC,oBA1BF,QA2BO,sBA3BP,C,CA6BA;;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,OAAO,KAAKC,QAAZ,MAA0B,WAA1B;;AACA,SAASC,eAAT,CAAyBC,KAAzB,EAAgC;EAC9B,OAAO,eAAgBH,KAAK,CAACI,aAAN,CAAoBzB,cAApB,EAAoC;IAAE0B,SAAS,EAAEJ,QAAQ,CAACI,SAAtB;IAAiC,GAAGF;EAApC,CAApC,CAAvB;AACD,C,CAED;;;AACA,OAAO,KAAKG,MAAZ,MAAwB,OAAxB;AACA,IAAIC,OAAO,GAAG,IAAd;AACA,IAAIC,MAAM,GAAG,IAAb;;AACA,SAASC,WAAT,GAAuB;EACrB,IAAI,CAACF,OAAD,IAAYG,MAAM,CAACC,oBAAnB,IAA2CD,MAAM,CAACE,qBAAlD,IAA2EF,MAAM,CAACG,yBAAtF,EAAiH;IAC/G,IAAIH,MAAM,CAACE,qBAAP,CAA6BE,GAA7B,KAAqC,IAAzC,EAA+C;MAC7C,MAAMC,SAAS,GAAGC,QAAQ,CAACC,aAAT,CAAuB,sBAAvB,CAAlB;;MACA,IAAIF,SAAS,EAAEG,WAAf,EAA4B;QAC1B,IAAI;UACFR,MAAM,CAACE,qBAAP,CAA6BE,GAA7B,GAAmCK,IAAI,CAACC,KAAL,CACjCL,SAAS,CAACG,WADuB,EAEjCG,SAFF;QAGD,CAJD,CAIE,OAAOC,GAAP,EAAY;UACZC,OAAO,CAACC,KAAR,CAAc,4BAAd,EAA4CF,GAA5C;QACD;MACF;IACF;;IACDf,OAAO,GAAG;MACRkB,OAAO,EAAEf,MAAM,CAACC,oBADR;MAERe,QAAQ,EAAEhB,MAAM,CAACE,qBAFT;MAGRe,YAAY,EAAEjB,MAAM,CAACG,yBAHb;MAIRe,oBAAoB,EAAE,KAAK,CAJnB;MAKRpB,MAAM,EAAE,KAAK,CALL;MAMRqB,iBAAiB,EAAE;IANX,CAAV;EAQD;AACF;;AACD,SAASC,oBAAT,OAGG;EAAA,IAH2B;IAC5BC,UAD4B;IAE5BC;EAF4B,CAG3B;EACDvB,WAAW;;EACX,IAAI,CAACF,OAAL,EAAc;IACZ,MAAM,IAAI0B,KAAJ,CACJ,mHADI,CAAN;EAGD;;EACD,IAAIC,YAAY,GAAG3B,OAAnB;;EACA,IAAI,CAACA,OAAO,CAACqB,oBAAb,EAAmC;IACjC,IAAIO,MAAM,GAAG5B,OAAO,CAACkB,OAAR,CAAgBU,MAA7B;IACA5C,SAAS,CAAC4C,MAAD,EAAS,2CAAT,CAAT;IACA5B,OAAO,CAACkB,OAAR,CAAgBU,MAAhB,GAAyB,KAAK,CAA9B;IACA5B,OAAO,CAACqB,oBAAR,GAA+B1C,oBAAoB,CAACiD,MAAD,EAASzB,MAAT,CAApB,CAAqC0B,IAArC,CAA2CC,KAAD,IAAW;MAClF9B,OAAO,CAACkB,OAAR,CAAgBa,KAAhB,GAAwBD,KAAK,CAACA,KAA9B;MACAH,YAAY,CAACN,oBAAb,CAAkCS,KAAlC,GAA0C,IAA1C;IACD,CAH8B,EAG5BE,KAH4B,CAGrBC,CAAD,IAAO;MACdN,YAAY,CAACN,oBAAb,CAAkCJ,KAAlC,GAA0CgB,CAA1C;IACD,CAL8B,CAA/B;EAMD;;EACD,IAAIjC,OAAO,CAACqB,oBAAR,CAA6BJ,KAAjC,EAAwC;IACtC,MAAMjB,OAAO,CAACqB,oBAAR,CAA6BJ,KAAnC;EACD;;EACD,IAAI,CAACjB,OAAO,CAACqB,oBAAR,CAA6BS,KAAlC,EAAyC;IACvC,MAAM9B,OAAO,CAACqB,oBAAd;EACD;;EACD,IAAIa,MAAM,GAAG5D,kBAAkB,CAC7B0B,OAAO,CAACmB,QAAR,CAAiBe,MADY,EAE7BlC,OAAO,CAACoB,YAFqB,EAG7BpB,OAAO,CAACkB,OAAR,CAAgBa,KAHa,EAI7B/B,OAAO,CAACkB,OAAR,CAAgBiB,GAJa,EAK7BnC,OAAO,CAACkB,OAAR,CAAgBkB,SALa,CAA/B;EAOA,IAAIC,aAAa,GAAG,KAAK,CAAzB;;EACA,IAAIrC,OAAO,CAACkB,OAAR,CAAgBkB,SAApB,EAA+B;IAC7B,IAAI;MAAEE;IAAF,IAAiBtC,OAAO,CAACkB,OAAR,CAAgBa,KAArC;;IACA,IAAI/B,OAAO,CAACmB,QAAR,CAAiBe,MAAjB,CAAwBK,IAAxB,EAA8BC,SAA9B,IAA2CF,UAA3C,IAAyD,UAAUA,UAAvE,EAAmF;MACjFD,aAAa,GAAG;QACdC,UAAU,EAAE;UACVC,IAAI,EAAED,UAAU,CAACC;QADP;MADE,CAAhB;IAKD;EACF,CATD,MASO;IACLF,aAAa,GAAGxE,gBAAgB,CAAC;MAC/BkE,KAAK,EAAE/B,OAAO,CAACkB,OAAR,CAAgBa,KADQ;MAE/BG,MAF+B;MAG/BO,YAAY,EAAGC,OAAD,KAAc;QAC1BC,YAAY,EAAE3C,OAAO,CAACoB,YAAR,CAAqBsB,OAArB,GAA+BC,YADnB;QAE1BH,SAAS,EAAExC,OAAO,CAACmB,QAAR,CAAiBe,MAAjB,CAAwBQ,OAAxB,GAAkCF,SAAlC,KAAgD,IAFjC;QAG1BI,kBAAkB,EAAE5C,OAAO,CAACoB,YAAR,CAAqBsB,OAArB,GAA+BG,eAA/B,IAAkD;MAH5C,CAAd,CAHiB;MAQ/BC,QAAQ,EAAE3C,MAAM,CAAC2C,QARc;MAS/BC,QAAQ,EAAE5C,MAAM,CAACC,oBAAP,EAA6B2C,QATR;MAU/BX,SAAS,EAAEpC,OAAO,CAACkB,OAAR,CAAgBkB;IAVI,CAAD,CAAhC;;IAYA,IAAIC,aAAa,IAAIA,aAAa,CAACW,MAAnC,EAA2C;MACzCX,aAAa,CAACW,MAAd,GAAuBpF,iBAAiB,CAACyE,aAAa,CAACW,MAAf,CAAxC;IACD;EACF;;EACD,IAAI7C,MAAM,CAAC8C,OAAP,CAAelB,KAAf,IAAwB5B,MAAM,CAAC8C,OAAP,CAAelB,KAAf,CAAqBmB,MAAjD,EAAyD;IACvD/C,MAAM,CAAC8C,OAAP,CAAeE,YAAf,CACE,EAAE,GAAGhD,MAAM,CAAC8C,OAAP,CAAelB,KAApB;MAA2BmB,MAAM,EAAE,KAAK;IAAxC,CADF,EAEE,EAFF;EAID;;EACD,IAAIE,OAAO,GAAG1E,YAAY,CAAC;IACzBwD,MADyB;IAEzBe,OAAO,EAAE5E,oBAAoB,EAFJ;IAGzB0E,QAAQ,EAAE/C,OAAO,CAACkB,OAAR,CAAgB6B,QAHD;IAIzBvB,UAJyB;IAKzBa,aALyB;IAMzBtD,wBANyB;IAOzB0C,yBAPyB;IAQzBvC,kBARyB;IASzBmE,MAAM,EAAE;MACNC,UAAU,EAAEtD,OAAO,CAACkB,OAAR,CAAgBmC,MAAhB,CAAuBE;IAD7B,CATiB;IAYzBC,YAAY,EAAE1E,qCAAqC,CACjD,MAAMsE,OAD2C,EAEjDpD,OAAO,CAACmB,QAFyC,EAGjDnB,OAAO,CAACoB,YAHyC,EAIjDpB,OAAO,CAACkB,OAAR,CAAgBiB,GAJiC,EAKjDnC,OAAO,CAACkB,OAAR,CAAgB6B,QALiC,EAMjD/C,OAAO,CAACkB,OAAR,CAAgBmC,MAAhB,CAAuBI,uCAN0B,CAZ1B;IAoBzBC,uBAAuB,EAAE9E,kCAAkC,CACzD,MAAMwE,OADmD,EAEzDpD,OAAO,CAACmB,QAFiD,EAGzDnB,OAAO,CAACoB,YAHiD,EAIzDpB,OAAO,CAACkB,OAAR,CAAgBiB,GAJyC,EAKzDnC,OAAO,CAACkB,OAAR,CAAgByC,cALyC,EAMzD3D,OAAO,CAACkB,OAAR,CAAgBkB,SANyC,EAOzDpC,OAAO,CAACkB,OAAR,CAAgB6B,QAPyC;EApBlC,CAAD,CAA1B;EA8BA/C,OAAO,CAACC,MAAR,GAAiBmD,OAAjB;;EACA,IAAIA,OAAO,CAACrB,KAAR,CAAc6B,WAAlB,EAA+B;IAC7B5D,OAAO,CAACsB,iBAAR,GAA4B,IAA5B;IACA8B,OAAO,CAACS,UAAR;EACD;;EACDT,OAAO,CAACU,kBAAR;EAA6B;EAC7BvF,2CADA;EAEA4B,MAAM,CAAC4D,uBAAP,GAAiCX,OAAjC;EACA,OAAOA,OAAP;AACD;;AACD,SAASY,cAAT,CAAwBpE,KAAxB,EAA+B;EAC7B,IAAI,CAACK,MAAL,EAAa;IACXA,MAAM,GAAGsB,oBAAoB,CAAC;MAC5BC,UAAU,EAAE5B,KAAK,CAAC4B,UADU;MAE5BC,yBAAyB,EAAE7B,KAAK,CAAC6B;IAFL,CAAD,CAA7B;EAID;;EACD,IAAI,CAACwC,WAAD,EAAcC,cAAd,IAAgCnE,MAAM,CAACoE,QAAP,CAClCC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,aAAzB,GAAyCtE,OAAO,EAAEkB,OAAT,CAAiB+C,WAA1D,GAAwE,KAAK,CAD3C,CAApC;EAGAlE,MAAM,CAACwE,SAAP,CAAiB,MAAM;IACrB,IAAIH,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,aAA7B,EAA4C;MAC1CJ,cAAc,CAAC,KAAK,CAAN,CAAd;IACD;EACF,CAJD,EAIG,EAJH;EAKAnE,MAAM,CAACwE,SAAP,CAAiB,MAAM;IACrB,IAAIH,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,aAAzB,IAA0CL,WAAW,KAAK,KAAK,CAAnE,EAAsE;MACpExD,QAAQ,CAAC+D,gBAAT,CAA2B,IAAGzG,2BAA4B,GAA1D,EAA8D0G,OAA9D,CAAuEC,OAAD,IAAaA,OAAO,CAACC,MAAR,EAAnF;IACD;EACF,CAJD,EAIG,CAACV,WAAD,CAJH;EAKA,IAAI,CAACW,SAAD,EAAYC,WAAZ,IAA2B9E,MAAM,CAACoE,QAAP,CAAgBlE,MAAM,CAAC8B,KAAP,CAAae,QAA7B,CAA/B;EACA/C,MAAM,CAAC+E,eAAP,CAAuB,MAAM;IAC3B,IAAI9E,OAAO,IAAIA,OAAO,CAACC,MAAnB,IAA6B,CAACD,OAAO,CAACsB,iBAA1C,EAA6D;MAC3DtB,OAAO,CAACsB,iBAAR,GAA4B,IAA5B;MACAtB,OAAO,CAACC,MAAR,CAAe4D,UAAf;IACD;EACF,CALD,EAKG,EALH;EAMA9D,MAAM,CAAC+E,eAAP,CAAuB,MAAM;IAC3B,IAAI9E,OAAO,IAAIA,OAAO,CAACC,MAAvB,EAA+B;MAC7B,OAAOD,OAAO,CAACC,MAAR,CAAe8E,SAAf,CAA0BC,QAAD,IAAc;QAC5C,IAAIA,QAAQ,CAAClC,QAAT,KAAsB8B,SAA1B,EAAqC;UACnCC,WAAW,CAACG,QAAQ,CAAClC,QAAV,CAAX;QACD;MACF,CAJM,CAAP;IAKD;EACF,CARD,EAQG,CAAC8B,SAAD,CARH;EASA5F,SAAS,CAACgB,OAAD,EAAU,wCAAV,CAAT;EACAR,oBAAoB,CAClBS,MADkB,EAElBD,OAAO,CAACmB,QAFU,EAGlBnB,OAAO,CAACoB,YAHU,EAIlBpB,OAAO,CAACkB,OAAR,CAAgBiB,GAJE,EAKlBnC,OAAO,CAACkB,OAAR,CAAgByC,cALE,EAMlB3D,OAAO,CAACkB,OAAR,CAAgBkB,SANE,CAApB;EAQA,OACE;IACA;;IACA;IAAgBrC,MAAM,CAACF,aAAP,CAAqBE,MAAM,CAACkF,QAA5B,EAAsC,IAAtC,EAA4C,eAAgBlF,MAAM,CAACF,aAAP,CAC1E5B,gBAAgB,CAACiH,QADyD,EAE1E;MACEpD,KAAK,EAAE;QACLX,QAAQ,EAAEnB,OAAO,CAACmB,QADb;QAELC,YAAY,EAAEpB,OAAO,CAACoB,YAFjB;QAGLiC,MAAM,EAAErD,OAAO,CAACkB,OAAR,CAAgBmC,MAHnB;QAILY,WAJK;QAKL9B,GAAG,EAAEnC,OAAO,CAACkB,OAAR,CAAgBiB,GALhB;QAMLC,SAAS,EAAEpC,OAAO,CAACkB,OAAR,CAAgBkB,SANtB;QAOLuB,cAAc,EAAE3D,OAAO,CAACkB,OAAR,CAAgByC;MAP3B;IADT,CAF0E,EAa1E,eAAgB5D,MAAM,CAACF,aAAP,CAAqB1B,kBAArB,EAAyC;MAAE2E,QAAQ,EAAE8B;IAAZ,CAAzC,EAAkE,eAAgB7E,MAAM,CAACF,aAAP,CAChGF,eADgG,EAEhG;MACEM,MADF;MAEEkF,uBAAuB,EAAEvF,KAAK,CAACuF,uBAFjC;MAGEC,OAAO,EAAExF,KAAK,CAACwF;IAHjB,CAFgG,CAAlF,CAb0D,CAA5D,EAqBb,eAAgBrF,MAAM,CAACF,aAAP,CAAqBE,MAAM,CAACkF,QAA5B,EAAsC,IAAtC,CArBH;EAHlB;AA0BD,C,CAED;;;AACA,OAAO,KAAKI,MAAZ,MAAwB,OAAxB;AACA,OAAO,KAAKC,SAAZ,MAA2B,WAA3B;;AACA,SAASC,gBAAT,QAKG;EAAA,IALuB;IACxBC,wBADwB;IAExBC,2BAFwB;IAGxBC,WAHwB;IAIxBC,KAAK,EAAEC,mBAAmB,GAAGD;EAJL,CAKvB;EACD,MAAME,SAAS,GAAG1F,MAAlB;EACA,IAAI2F,cAAc,GAAG,CAArB;EACA,OAAO,OAAOC,EAAP,EAAWC,IAAX,KAAoB;IACzB,IAAIC,QAAQ,GAAGJ,SAAS,CAACK,gBAAV,GAA6B,CAACL,SAAS,CAACK,gBAAV,KAA+BL,SAAS,CAACK,gBAAV,GAA6B,CAA5D,CAAD,IAAmE,CAA/G;IACA,MAAMC,mBAAmB,GAAGV,2BAA2B,EAAvD;IACA,MAAMW,cAAc,GAAGR,mBAAmB,CACxC,IAAIS,OAAJ,CAAYvD,QAAQ,CAACwD,IAArB,EAA2B;MACzBC,IAAI,EAAE,MAAMb,WAAW,CAACM,IAAD,EAAO;QAAEG;MAAF,CAAP,CADE;MAEzBK,MAAM,EAAE,MAFiB;MAGzBC,OAAO,EAAE;QACPC,MAAM,EAAE,kBADD;QAEP,iBAAiBX;MAFV;IAHgB,CAA3B,CADwC,CAAnB,CASrBlE,IATqB,CASf8E,QAAD,IAAc;MACnB,IAAI,CAACA,QAAQ,CAACJ,IAAd,EAAoB;QAClB,MAAM,IAAI7E,KAAJ,CAAU,kBAAV,CAAN;MACD;;MACD,OAAO8D,wBAAwB,CAACmB,QAAQ,CAACJ,IAAV,EAAgB;QAC7CJ;MAD6C,CAAhB,CAA/B;IAGD,CAhBsB,CAAvB;IAiBAd,MAAM,CAACuB,eAAP,CACE,MACE;IACAC,OAAO,CAACC,OAAR,CAAgBV,cAAhB,EAAgCvE,IAAhC,CAAqC,MAAOkF,OAAP,IAAmB;MACtD,IAAIA,OAAO,CAACC,IAAR,KAAiB,UAArB,EAAiC;QAC/B,IAAID,OAAO,CAACE,MAAR,IAAkBC,kBAAkB,CAACH,OAAO,CAACjE,QAAT,CAAxC,EAA4D;UAC1D3C,MAAM,CAAC2C,QAAP,CAAgBwD,IAAhB,GAAuBS,OAAO,CAACjE,QAA/B;UACA;QACD;;QACDuC,MAAM,CAACuB,eAAP,CAAuB,MAAM;UAC3Bf,SAAS,CAAC9B,uBAAV,CAAkCoD,QAAlC,CAA2CJ,OAAO,CAACjE,QAAnD,EAA6D;YAC3DsE,OAAO,EAAEL,OAAO,CAACK;UAD0C,CAA7D;QAGD,CAJD;QAKA;MACD;;MACD,IAAIL,OAAO,CAACC,IAAR,KAAiB,QAArB,EAA+B;QAC7B,MAAM,IAAItF,KAAJ,CAAU,yBAAV,CAAN;MACD;;MACD,MAAM2F,QAAQ,GAAG,MAAMN,OAAO,CAACM,QAA/B;;MACA,IAAIA,QAAQ,IAAIvB,cAAc,GAAGG,QAA7B,IAAyCJ,SAAS,CAACK,gBAAV,IAA8BD,QAA3E,EAAqF;QACnF,IAAIoB,QAAQ,CAACL,IAAT,KAAkB,UAAtB,EAAkC;UAChC,IAAIK,QAAQ,CAACJ,MAAT,IAAmBC,kBAAkB,CAACG,QAAQ,CAACvE,QAAV,CAAzC,EAA8D;YAC5D3C,MAAM,CAAC2C,QAAP,CAAgBwD,IAAhB,GAAuBe,QAAQ,CAACvE,QAAhC;YACA;UACD;;UACDuC,MAAM,CAACuB,eAAP,CAAuB,MAAM;YAC3Bf,SAAS,CAAC9B,uBAAV,CAAkCoD,QAAlC,CAA2CE,QAAQ,CAACvE,QAApD,EAA8D;cAC5DsE,OAAO,EAAEC,QAAQ,CAACD;YAD0C,CAA9D;UAGD,CAJD;UAKA;QACD;;QACD/B,MAAM,CAACuB,eAAP,CAAuB,MAAM;UAC3B,IAAIU,SAAJ;;UACA,KAAK,MAAMC,KAAX,IAAoBF,QAAQ,CAACG,OAA7B,EAAsC;YACpC3B,SAAS,CAAC9B,uBAAV,CAAkC0D,WAAlC,CACEH,SAAS,EAAEvB,EAAX,IAAiB,IADnB,EAEE,CAAC2B,6BAA6B,CAACH,KAAD,CAA9B,CAFF,EAGE,IAHF;;YAKAD,SAAS,GAAGC,KAAZ;UACD;;UACDpH,MAAM,CAAC4D,uBAAP,CAA+B4D,8CAA/B,CACE;YACErF,UAAU,EAAEsF,MAAM,CAACC,MAAP,CACV,EADU,EAEVhC,SAAS,CAAC9B,uBAAV,CAAkChC,KAAlC,CAAwCO,UAF9B,EAGV+E,QAAQ,CAAC/E,UAHC,CADd;YAMEU,MAAM,EAAEqE,QAAQ,CAACrE,MAAT,GAAkB4E,MAAM,CAACC,MAAP,CACxB,EADwB,EAExBhC,SAAS,CAAC9B,uBAAV,CAAkChC,KAAlC,CAAwCiB,MAFhB,EAGxBqE,QAAQ,CAACrE,MAHe,CAAlB,GAIJ;UAVN,CADF;QAcD,CAxBD;MAyBD;IACF,CAxDD,EAwDGhB,KAxDH,CAwDS,MAAM,CACd,CAzDD,CAHJ;IA+DA,OAAOoE,cAAc,CAACvE,IAAf,CAAqBkF,OAAD,IAAa;MACtC,IAAIA,OAAO,CAACC,IAAR,KAAiB,QAAjB,IAA6BD,OAAO,CAACC,IAAR,KAAiB,UAAlD,EAA8D;QAC5D,MAAM,IAAItF,KAAJ,CAAU,yBAAV,CAAN;MACD;;MACD,OAAOqF,OAAO,CAACe,YAAf;IACD,CALM,CAAP;EAMD,CAzFD;AA0FD;;AACD,SAASC,uBAAT,QAKG;EAAA,IAL8B;IAC/BnC,mBAD+B;IAE/BJ,wBAF+B;IAG/BhE,UAH+B;IAI/BuF;EAJ+B,CAK9B;EACD,MAAMlB,SAAS,GAAG1F,MAAlB;EACA,IAAI0F,SAAS,CAAC9B,uBAAV,IAAqC8B,SAAS,CAACvF,yBAAnD,EACE,OAAO;IACLL,MAAM,EAAE4F,SAAS,CAAC9B,uBADb;IAEL3C,YAAY,EAAEyE,SAAS,CAACvF;EAFnB,CAAP;EAIF,IAAIyG,OAAO,CAACC,IAAR,KAAiB,QAArB,EAA+B,MAAM,IAAItF,KAAJ,CAAU,sBAAV,CAAN;EAC/BmE,SAAS,CAACvF,yBAAV,GAAsCuF,SAAS,CAACvF,yBAAV,IAAuC,EAA7E;EACAxC,uBAAuB,CAAC+H,SAAS,CAACvF,yBAAX,EAAsCyG,OAAO,CAACS,OAA9C,CAAvB;EACA,IAAIQ,OAAO,GAAG,eAAgB,IAAIC,GAAJ,EAA9B;EACAlB,OAAO,CAACiB,OAAR,EAAiBvD,OAAjB,CAA0ByD,KAAD,IAAW;IAClClJ,SAAS,CAACkJ,KAAK,CAACC,QAAP,EAAiB,wBAAjB,CAAT;;IACA,IAAI,CAACH,OAAO,CAACI,GAAR,CAAYF,KAAK,CAACC,QAAlB,CAAL,EAAkC;MAChCH,OAAO,CAACK,GAAR,CAAYH,KAAK,CAACC,QAAlB,EAA4B,EAA5B;IACD;;IACDH,OAAO,CAACM,GAAR,CAAYJ,KAAK,CAACC,QAAlB,GAA6BI,IAA7B,CAAkCL,KAAlC;EACD,CAND;EAOA,IAAIhG,MAAM,GAAG6E,OAAO,CAACS,OAAR,CAAgBgB,WAAhB,CAA4B,CAACC,QAAD,EAAWlB,KAAX,KAAqB;IAC5D,MAAMmB,KAAK,GAAGhB,6BAA6B,CACzCH,KADyC,EAEzCR,OAFyC,CAA3C;;IAIA,IAAI0B,QAAQ,CAACE,MAAT,GAAkB,CAAtB,EAAyB;MACvBD,KAAK,CAACE,QAAN,GAAiBH,QAAjB;MACA,IAAII,eAAe,GAAGb,OAAO,CAACM,GAAR,CAAYf,KAAK,CAACxB,EAAlB,CAAtB;;MACA,IAAI8C,eAAJ,EAAqB;QACnBH,KAAK,CAACE,QAAN,CAAeL,IAAf,CACE,GAAGM,eAAe,CAACC,GAAhB,CAAqBC,CAAD,IAAOrB,6BAA6B,CAACqB,CAAD,CAAxD,CADL;MAGD;IACF;;IACD,OAAO,CAACL,KAAD,CAAP;EACD,CAfY,EAeV,EAfU,CAAb;EAgBA7C,SAAS,CAAC9B,uBAAV,GAAoCrF,YAAY,CAAC;IAC/CwD,MAD+C;IAE/CV,UAF+C;IAG/CuB,QAAQ,EAAEgE,OAAO,CAAChE,QAH6B;IAI/CE,OAAO,EAAE5E,oBAAoB,EAJkB;IAK/CgE,aAAa,EAAExE,gBAAgB,CAAC;MAC9BkE,KAAK,EAAE;QACLO,UAAU,EAAEyE,OAAO,CAACzE,UADf;QAEL0G,UAAU,EAAEjC,OAAO,CAACiC,UAFf;QAGLhG,MAAM,EAAE+D,OAAO,CAAC/D;MAHX,CADuB;MAM9Bd,MAN8B;MAO9BO,YAAY,EAAGC,OAAD,IAAa;QACzB,IAAI6E,KAAK,GAAGR,OAAO,CAACS,OAAR,CAAgByB,IAAhB,CAAsBC,CAAD,IAAOA,CAAC,CAACnD,EAAF,KAASrD,OAArC,CAAZ;QACA1D,SAAS,CAACuI,KAAD,EAAQ,4BAAR,CAAT;QACA,OAAO;UACL5E,YAAY,EAAE4E,KAAK,CAAC5E,YADf;UAELH,SAAS,EAAE+E,KAAK,CAAC/E,SAFZ;UAGLI,kBAAkB,EAAE2E,KAAK,CAAC4B,sBAAN,IAAgC;QAH/C,CAAP;MAKD,CAf6B;MAgB9BrG,QAAQ,EAAEiE,OAAO,CAACjE,QAhBY;MAiB9BC,QAAQ,EAAEgE,OAAO,CAAChE,QAjBY;MAkB9BX,SAAS,EAAE;IAlBmB,CAAD,CALgB;;IAyB/C,MAAMsB,uBAAN,QAAgD;MAAA,IAAlB;QAAE0F,IAAF;QAAQC;MAAR,CAAkB;;MAC9C,IAAIC,eAAe,CAAClB,GAAhB,CAAoBgB,IAApB,CAAJ,EAA+B;QAC7B;MACD;;MACD,MAAMG,4BAA4B,CAChC,CAACH,IAAD,CADgC,EAEhC5D,wBAFgC,EAGhCI,mBAHgC,EAIhCyD,MAJgC,CAAlC;IAMD,CAnC8C;;IAoC/C;IACA7F,YAAY,EAAEgG,6BAA6B,CACzC,MAAM3D,SAAS,CAAC9B,uBADyB,EAEzC,IAFyC,EAGzCgD,OAAO,CAAChE,QAHiC,EAIzCyC,wBAJyC,EAKzCI,mBALyC;EArCI,CAAD,CAAhD;;EA6CA,IAAIC,SAAS,CAAC9B,uBAAV,CAAkChC,KAAlC,CAAwC6B,WAA5C,EAAyD;IACvDiC,SAAS,CAAC4D,mBAAV,GAAgC,IAAhC;;IACA5D,SAAS,CAAC9B,uBAAV,CAAkCF,UAAlC;EACD,CAHD,MAGO;IACLgC,SAAS,CAAC4D,mBAAV,GAAgC,KAAhC;EACD;;EACD,IAAIC,cAAc,GAAG,KAAK,CAA1B;;EACA7D,SAAS,CAAC9B,uBAAV,CAAkCgB,SAAlC,CAA4C,SAAgC;IAAA,IAA/B;MAAEzC,UAAF;MAAc0G;IAAd,CAA+B;;IAC1E,IAAIU,cAAc,KAAKpH,UAAvB,EAAmC;MACjCuD,SAAS,CAACK,gBAAV,GAA6B,CAACL,SAAS,CAACK,gBAAV,KAA+BL,SAAS,CAACK,gBAAV,GAA6B,CAA5D,CAAD,IAAmE,CAAhG;IACD;EACF,CAJD;;EAKAL,SAAS,CAAC9B,uBAAV,CAAkC4F,mBAAlC,GAAyDC,oBAAD,IAA0B;IAChF,MAAMC,SAAS,GAAG1J,MAAM,CAAC4D,uBAAP,CAA+B7B,MAAjD;IACA,MAAM4H,SAAS,GAAG,EAAlB;;IACA,SAASC,UAAT,CAAoBC,OAApB,EAA6B7B,QAA7B,EAAuC;MACrC,OAAO6B,OAAO,CAAClB,GAAR,CAAaJ,KAAD,IAAW;QAC5B,MAAMuB,WAAW,GAAGL,oBAAoB,CAACtB,GAArB,CAAyBI,KAAK,CAAC3C,EAA/B,CAApB;;QACA,IAAIkE,WAAJ,EAAiB;UACf,MAAM;YACJC,WADI;YAEJC,SAFI;YAGJC,YAHI;YAIJC,gBAJI;YAKJ7H;UALI,IAMFyH,WANJ;UAOA,MAAMK,QAAQ,GAAG5C,6BAA6B,CAAC;YAC7C6C,YAAY,EAAEL,WAAW,CAACK,YADmB;YAE7C5H,YAAY,EAAEuH,WAAW,CAACvH,YAFmB;YAG7C+B,OAAO,EAAEgE,KAAK,CAAChE,OAH8B;YAI7C8F,YAAY,EAAE9B,KAAK,CAAC8B,YAJyB;YAK7CC,MAAM,EAAE/B,KAAK,CAAC+B,MAL+B;YAM7CN,SAN6C;YAO7CC,YAP6C;YAQ7CC,gBAR6C;YAS7C7H,SAT6C;YAU7C2G,sBAAsB,EAAET,KAAK,CAACS,sBAVe;YAW7CpD,EAAE,EAAE2C,KAAK,CAAC3C,EAXmC;YAY7C2E,KAAK,EAAEhC,KAAK,CAACgC,KAZgC;YAa7CC,KAAK,EAAET,WAAW,CAACS,KAb0B;YAc7CC,IAAI,EAAEV,WAAW,CAACU,IAd2B;YAe7CzC,QAf6C;YAgB7CiB,IAAI,EAAEV,KAAK,CAACU,IAhBiC;YAiB7CyB,gBAAgB,EAAEX,WAAW,CAACW;UAjBe,CAAD,CAA9C;;UAmBA,IAAInC,KAAK,CAACE,QAAV,EAAoB;YAClB0B,QAAQ,CAAC1B,QAAT,GAAoBmB,UAAU,CAACrB,KAAK,CAACE,QAAP,EAAiBF,KAAK,CAAC3C,EAAvB,CAA9B;UACD;;UACD,OAAOuE,QAAP;QACD;;QACD,MAAMQ,YAAY,GAAG,EAAE,GAAGpC;QAAL,CAArB;;QACA,IAAIA,KAAK,CAACE,QAAV,EAAoB;UAClBkC,YAAY,CAAClC,QAAb,GAAwBmB,UAAU,CAACrB,KAAK,CAACE,QAAP,EAAiBF,KAAK,CAAC3C,EAAvB,CAAlC;QACD;;QACD,OAAO+E,YAAP;MACD,CAvCM,CAAP;IAwCD;;IACDhB,SAAS,CAACvB,IAAV,CACE,GAAGwB,UAAU,CAACF,SAAD,EAAY,KAAK,CAAjB,CADf;;IAGA1J,MAAM,CAAC4D,uBAAP,CAA+BgH,kBAA/B,CAAkDjB,SAAlD;EACD,CAjDD;;EAkDA,OAAO;IACL7J,MAAM,EAAE4F,SAAS,CAAC9B,uBADb;IAEL3C,YAAY,EAAEyE,SAAS,CAACvF;EAFnB,CAAP;AAID;;AACD,IAAI0K,qBAAqB,GAAGxM,aAAa,EAAzC;;AACA,SAASgL,6BAAT,CAAuCyB,SAAvC,EAAkD9I,GAAlD,EAAuDY,QAAvD,EAAiEyC,wBAAjE,EAA2FI,mBAA3F,EAAgH;EAC9G,IAAIpC,YAAY,GAAG3E,8BAA8B,CAC/CoM,SAD+C,EAE9C1D,KAAD,IAAW;IACT,IAAI2D,CAAC,GAAG3D,KAAR;IACA,OAAO;MACL/E,SAAS,EAAE0I,CAAC,CAACxC,KAAF,CAAQlG,SADd;MAEL2I,eAAe,EAAED,CAAC,CAACxC,KAAF,CAAQyC,eAFpB;MAGLf,YAAY,EAAEc,CAAC,CAACxC,KAAF,CAAQ0B,YAHjB;MAILD,SAAS,EAAEe,CAAC,CAACxC,KAAF,CAAQyB,SAJd;MAKLiB,eAAe,EAAEF,CAAC,CAACxC,KAAF,CAAQ0C,eALpB;MAMLC,mBAAmB,EAAEH,CAAC,CAACxC,KAAF,CAAQ2C;IANxB,CAAP;EAQD,CAZ8C,EAa/C;EACAC,uBAAuB,CAAC9F,wBAAD,EAA2BI,mBAA3B,CAdwB,EAe/CzD,GAf+C,EAgB/CY,QAhB+C,EAiB/C;EACA,IAlB+C,EAmB/C;EACA;EACA;EACCwE,KAAD,IAAW;IACT,IAAI2D,CAAC,GAAG3D,KAAR;IACA,OAAO2D,CAAC,CAACxC,KAAF,CAAQ0B,YAAR,IAAwB,CAACc,CAAC,CAACxC,KAAF,CAAQhE,OAAxC;EACD,CAzB8C,CAAjD;EA2BA,OAAO,MAAOsB,IAAP,IAAgBA,IAAI,CAACuF,mBAAL,CAAyB,YAAY;IAC1D,IAAIrK,OAAO,GAAG8E,IAAI,CAAC9E,OAAnB;IACAA,OAAO,CAACmH,GAAR,CAAY2C,qBAAZ,EAAmC,EAAnC;IACA,IAAIQ,OAAO,GAAG,MAAMhI,YAAY,CAACwC,IAAD,CAAhC;IACA,MAAMyF,kBAAkB,GAAG,eAAgB,IAAIxD,GAAJ,EAA3C;;IACA,KAAK,MAAMS,KAAX,IAAoBxH,OAAO,CAACoH,GAAR,CAAY0C,qBAAZ,CAApB,EAAwD;MACtD,IAAI,CAACS,kBAAkB,CAACrD,GAAnB,CAAuBM,KAAK,CAAC3C,EAA7B,CAAL,EAAuC;QACrC0F,kBAAkB,CAACpD,GAAnB,CAAuBK,KAAK,CAAC3C,EAA7B,EAAiC,EAAjC;MACD;;MACD0F,kBAAkB,CAACnD,GAAnB,CAAuBI,KAAK,CAAC3C,EAA7B,EAAiCwC,IAAjC,CAAsCG,KAAtC;IACD;;IACDrD,MAAM,CAACuB,eAAP,CAAuB,MAAM;MAC3B,KAAK,MAAMW,KAAX,IAAoBvB,IAAI,CAACwB,OAAzB,EAAkC;QAChC,MAAMkE,cAAc,GAAGD,kBAAkB,CAACnD,GAAnB,CAAuBf,KAAK,CAACmB,KAAN,CAAY3C,EAAnC,CAAvB;;QACA,IAAI2F,cAAJ,EAAoB;UAClB,KAAK,MAAMC,QAAX,IAAuBD,cAAvB,EAAuC;YACrCvL,MAAM,CAAC4D,uBAAP,CAA+B0D,WAA/B,CACEkE,QAAQ,CAACxD,QAAT,IAAqB,IADvB,EAEE,CAACT,6BAA6B,CAACiE,QAAD,CAA9B,CAFF,EAGE,IAHF;UAKD;QACF;MACF;IACF,CAbD;IAcA,OAAOH,OAAP;EACD,CA1BsB,CAAvB;AA2BD;;AACD,SAASF,uBAAT,CAAiC9F,wBAAjC,EAA2DI,mBAA3D,EAAgF;EAC9E,OAAO,OAAOI,IAAP,EAAajD,QAAb,EAAuB6I,kBAAvB,EAA2CC,YAA3C,KAA4D;IACjE,IAAI;MAAEC,OAAF;MAAW5K;IAAX,IAAuB8E,IAA3B;IACA,IAAI+F,GAAG,GAAGzM,cAAc,CAACwM,OAAO,CAACC,GAAT,EAAchJ,QAAd,EAAwB6I,kBAAxB,EAA4C,KAA5C,CAAxB;;IACA,IAAIE,OAAO,CAACtF,MAAR,KAAmB,KAAvB,EAA8B;MAC5BuF,GAAG,GAAGxM,eAAe,CAACwM,GAAD,CAArB;;MACA,IAAIF,YAAJ,EAAkB;QAChBE,GAAG,CAACC,YAAJ,CAAiB3D,GAAjB,CAAqB,SAArB,EAAgCwD,YAAY,CAACI,IAAb,CAAkB,GAAlB,CAAhC;MACD;IACF;;IACD,IAAIC,GAAG,GAAG,MAAMtG,mBAAmB,CACjC,IAAIS,OAAJ,CAAY0F,GAAZ,EAAiB,MAAMtN,iBAAiB,CAACqN,OAAD,CAAxC,CADiC,CAAnC;;IAGA,IAAII,GAAG,CAACC,MAAJ,IAAc,GAAd,IAAqB,CAACD,GAAG,CAACzF,OAAJ,CAAY2B,GAAZ,CAAgB,kBAAhB,CAA1B,EAA+D;MAC7D,MAAM,IAAIpK,iBAAJ,CAAsBkO,GAAG,CAACC,MAA1B,EAAkCD,GAAG,CAACE,UAAtC,EAAkD,MAAMF,GAAG,CAACG,IAAJ,EAAxD,CAAN;IACD;;IACDrN,SAAS,CAACkN,GAAG,CAAC3F,IAAL,EAAW,4BAAX,CAAT;;IACA,IAAI;MACF,MAAMQ,OAAO,GAAG,MAAMvB,wBAAwB,CAAC0G,GAAG,CAAC3F,IAAL,EAAW;QACvDJ,mBAAmB,EAAE,KAAK;MAD6B,CAAX,CAA9C;;MAGA,IAAIY,OAAO,CAACC,IAAR,KAAiB,UAArB,EAAiC;QAC/B,OAAO;UACLmF,MAAM,EAAED,GAAG,CAACC,MADP;UAELG,IAAI,EAAE;YACJC,QAAQ,EAAE;cACRA,QAAQ,EAAExF,OAAO,CAACjE,QADV;cAERmE,MAAM,EAAEF,OAAO,CAACE,MAFR;cAGRG,OAAO,EAAEL,OAAO,CAACK,OAHT;cAIRoF,UAAU,EAAE,KAJJ;cAKRL,MAAM,EAAEpF,OAAO,CAACoF;YALR;UADN;QAFD,CAAP;MAYD;;MACD,IAAIpF,OAAO,CAACC,IAAR,KAAiB,QAArB,EAA+B;QAC7B,MAAM,IAAItF,KAAJ,CAAU,yBAAV,CAAN;MACD;;MACDR,OAAO,CAACoH,GAAR,CAAY0C,qBAAZ,EAAmCzC,IAAnC,CAAwC,GAAGxB,OAAO,CAACS,OAAnD;MACA,IAAIgE,OAAO,GAAG;QAAEtJ,MAAM,EAAE;MAAV,CAAd;MACA,MAAMuK,OAAO,GAAGxN,gBAAgB,CAAC6M,OAAO,CAACtF,MAAT,CAAhB,GAAmC,YAAnC,GAAkD,YAAlE;;MACA,KAAK,IAAI,CAAC9D,OAAD,EAAU4J,IAAV,CAAT,IAA4B1E,MAAM,CAAC8E,OAAP,CAAe3F,OAAO,CAAC0F,OAAD,CAAP,IAAoB,EAAnC,CAA5B,EAAoE;QAClEjB,OAAO,CAACtJ,MAAR,CAAeQ,OAAf,IAA0B;UAAE4J;QAAF,CAA1B;MACD;;MACD,IAAIvF,OAAO,CAAC/D,MAAZ,EAAoB;QAClB,KAAK,IAAI,CAACN,OAAD,EAAUzB,KAAV,CAAT,IAA6B2G,MAAM,CAAC8E,OAAP,CAAe3F,OAAO,CAAC/D,MAAvB,CAA7B,EAA6D;UAC3DwI,OAAO,CAACtJ,MAAR,CAAeQ,OAAf,IAA0B;YAAEzB;UAAF,CAA1B;QACD;MACF;;MACD,OAAO;QAAEkL,MAAM,EAAED,GAAG,CAACC,MAAd;QAAsBG,IAAI,EAAEd;MAA5B,CAAP;IACD,CAjCD,CAiCE,OAAOvJ,CAAP,EAAU;MACV,MAAM,IAAIP,KAAJ,CAAU,+BAAV,CAAN;IACD;EACF,CApDD;AAqDD;;AACD,SAASiL,iBAAT,QAMG;EAAA,IANwB;IACzBnH,wBADyB;IAEzBG,KAAK,EAAEC,mBAAmB,GAAGD,KAFJ;IAGzBoB,OAHyB;IAIzBpD,cAAc,GAAG,OAJQ;IAKzBnC;EALyB,CAMxB;EACD,IAAIuF,OAAO,CAACC,IAAR,KAAiB,QAArB,EAA+B,MAAM,IAAItF,KAAJ,CAAU,sBAAV,CAAN;EAC/B,IAAI;IAAEzB,MAAM,EAAEmD,OAAV;IAAmBhC;EAAnB,IAAoCiE,MAAM,CAACuH,OAAP,CACtC,MAAM7E,uBAAuB,CAAC;IAC5BhB,OAD4B;IAE5BnB,mBAF4B;IAG5BpE,UAH4B;IAI5BgE;EAJ4B,CAAD,CADS,EAOtC,CAACA,wBAAD,EAA2BuB,OAA3B,EAAoCnB,mBAApC,EAAyDpE,UAAzD,CAPsC,CAAxC;EASA6D,MAAM,CAACd,SAAP,CAAiB,MAAM;IACrBnF,aAAa;EACd,CAFD,EAEG,EAFH;EAGAiG,MAAM,CAACP,eAAP,CAAuB,MAAM;IAC3B,MAAMe,SAAS,GAAG1F,MAAlB;;IACA,IAAI,CAAC0F,SAAS,CAAC4D,mBAAf,EAAoC;MAClC5D,SAAS,CAAC4D,mBAAV,GAAgC,IAAhC;;MACA5D,SAAS,CAAC9B,uBAAV,CAAkCF,UAAlC;IACD;EACF,CAND,EAMG,EANH;EAOA,IAAI,CAAC;IAAE3B,MAAF;IAAUH;EAAV,CAAD,EAAoB8K,QAApB,IAAgCxH,MAAM,CAAClB,QAAP,CAAgB,OAAO;IACzDjC,MAAM,EAAE4K,WAAW,CAAC1J,OAAO,CAAClB,MAAT,CADsC;IAEzDH,KAAK,EAAEqB,OAAO,CAACrB;EAF0C,CAAP,CAAhB,CAApC;EAIAsD,MAAM,CAACP,eAAP,CACE,MAAM1B,OAAO,CAAC2B,SAAR,CAAmBC,QAAD,IAAc;IACpC,IAAI+H,UAAU,CAAC3J,OAAO,CAAClB,MAAT,EAAiBA,MAAjB,CAAd,EACEmD,MAAM,CAACuB,eAAP,CAAuB,MAAM;MAC3BiG,QAAQ,CAAC;QACP3K,MAAM,EAAE4K,WAAW,CAAC1J,OAAO,CAAClB,MAAT,CADZ;QAEPH,KAAK,EAAEiD;MAFA,CAAD,CAAR;IAID,CALD;EAMH,CARK,CADR,EAUE,CAAC5B,OAAO,CAAC2B,SAAT,EAAoB7C,MAApB,EAA4BkB,OAA5B,CAVF;EAYA,MAAM4J,uBAAuB,GAAG3H,MAAM,CAACuH,OAAP,CAC9B,OAAO,EACL,GAAGxJ,OADE;IAELrB,KAFK;IAGLG;EAHK,CAAP,CAD8B,EAM9B,CAACkB,OAAD,EAAUlB,MAAV,EAAkBH,KAAlB,CAN8B,CAAhC;EAQAsD,MAAM,CAACd,SAAP,CAAiB,MAAM;IACrB,IAAIZ,cAAc,KAAK,MAAnB,IAA6B;IACjCxD,MAAM,CAAC8M,SAAP,EAAkBC,UAAlB,EAA8BC,QAA9B,KAA2C,IAD3C,EACiD;MAC/C;IACD;;IACD,SAASC,eAAT,CAAyBC,EAAzB,EAA6B;MAC3B,IAAIjE,IAAI,GAAGiE,EAAE,CAACC,OAAH,KAAe,MAAf,GAAwBD,EAAE,CAACE,YAAH,CAAgB,QAAhB,CAAxB,GAAoDF,EAAE,CAACE,YAAH,CAAgB,MAAhB,CAA/D;;MACA,IAAI,CAACnE,IAAL,EAAW;QACT;MACD;;MACD,IAAIoE,QAAQ,GAAGH,EAAE,CAACC,OAAH,KAAe,GAAf,GAAqBD,EAAE,CAACG,QAAxB,GAAmC,IAAIC,GAAJ,CAAQrE,IAAR,EAAcjJ,MAAM,CAAC2C,QAAP,CAAgB4K,MAA9B,EAAsCF,QAAxF;;MACA,IAAI,CAAClE,eAAe,CAAClB,GAAhB,CAAoBoF,QAApB,CAAL,EAAoC;QAClCG,SAAS,CAACC,GAAV,CAAcJ,QAAd;MACD;IACF;;IACD,eAAeK,YAAf,GAA8B;MAC5BpN,QAAQ,CAAC+D,gBAAT,CAA0B,uCAA1B,EAAmEC,OAAnE,CAA2E2I,eAA3E;MACA,IAAIU,KAAK,GAAGC,KAAK,CAACC,IAAN,CAAWL,SAAS,CAACM,IAAV,EAAX,EAA6BC,MAA7B,CAAqC9E,IAAD,IAAU;QACxD,IAAIE,eAAe,CAAClB,GAAhB,CAAoBgB,IAApB,CAAJ,EAA+B;UAC7BuE,SAAS,CAACQ,MAAV,CAAiB/E,IAAjB;UACA,OAAO,KAAP;QACD;;QACD,OAAO,IAAP;MACD,CANW,CAAZ;;MAOA,IAAI0E,KAAK,CAACnF,MAAN,KAAiB,CAArB,EAAwB;QACtB;MACD;;MACD,IAAI;QACF,MAAMY,4BAA4B,CAChCuE,KADgC,EAEhCtI,wBAFgC,EAGhCI,mBAHgC,CAAlC;MAKD,CAND,CAME,OAAO3D,CAAP,EAAU;QACVjB,OAAO,CAACC,KAAR,CAAc,kCAAd,EAAkDgB,CAAlD;MACD;IACF;;IACD,IAAImM,qBAAqB,GAAGC,QAAQ,CAACR,YAAD,EAAe,GAAf,CAApC;IACAA,YAAY;IACZ,IAAIS,QAAQ,GAAG,IAAIC,gBAAJ,CAAqB,MAAMH,qBAAqB,EAAhD,CAAf;IACAE,QAAQ,CAACE,OAAT,CAAiB/N,QAAQ,CAACgO,eAA1B,EAA2C;MACzCC,OAAO,EAAE,IADgC;MAEzCC,SAAS,EAAE,IAF8B;MAGzCC,UAAU,EAAE,IAH6B;MAIzCC,eAAe,EAAE,CAAC,eAAD,EAAkB,MAAlB,EAA0B,QAA1B;IAJwB,CAA3C;EAMD,CA9CD,EA8CG,CAAClL,cAAD,EAAiB6B,wBAAjB,EAA2CI,mBAA3C,CA9CH;EA+CA,MAAMkJ,gBAAgB,GAAG;IACvBzL,MAAM,EAAE;MACN;MACA;MACAE,aAAa,EAAE,KAHT;MAINwL,6BAA6B,EAAE,KAJzB;MAKNtL,uCAAuC,EAAE,IALnC,CAMN;;IANM,CADe;IASvBrB,SAAS,EAAE,KATY;IAUvBD,GAAG,EAAE,IAVkB;IAWvB8B,WAAW,EAAE,EAXU;IAYvB9C,QAAQ,EAAE;MACRe,MAAM,EAAE,EADA;MAER8M,OAAO,EAAE,GAFD;MAGRjD,GAAG,EAAE,EAHG;MAIRkD,KAAK,EAAE;QACLC,MAAM,EAAE,EADH;QAELC,OAAO,EAAE;MAFJ;IAJC,CAZa;IAqBvBxL,cAAc,EAAE;MAAEyL,IAAI,EAAE,MAAR;MAAgBC,YAAY,EAAE;IAA9B,CArBO;IAsBvBjO;EAtBuB,CAAzB;EAwBA,OAAO,eAAgBiE,MAAM,CAACxF,aAAP,CAAqB3B,gBAAgB,CAACgH,QAAtC,EAAgD;IAAEpD,KAAK,EAAE;EAAT,CAAhD,EAAiE,eAAgBuD,MAAM,CAACxF,aAAP,CAAqBlC,4BAArB,EAAmD;IAAEmF,QAAQ,EAAEf,KAAK,CAACe;EAAlB,CAAnD,EAAiF,eAAgBuC,MAAM,CAACxF,aAAP,CAAqB5B,gBAAgB,CAACiH,QAAtC,EAAgD;IAAEpD,KAAK,EAAEgN;EAAT,CAAhD,EAA6E,eAAgBzJ,MAAM,CAACxF,aAAP,CACpSzB,cADoS,EAEpS;IACE6B,MAAM,EAAE+M,uBADV;IAEElN,SAAS,EAAEwF,SAAS,CAACxF;EAFvB,CAFoS,CAA7F,CAAjG,CAAjF,CAAvB;AAOD;;AACD,SAAS4H,6BAAT,CAAuCH,KAAvC,EAA8CR,OAA9C,EAAuD;EACrD,IAAIuI,cAAc,GAAGvI,OAAO,IAAIQ,KAAK,CAACxB,EAAN,IAAYgB,OAAO,CAACzE,UAApD;EACA,IAAIiN,WAAW,GAAGxI,OAAO,EAAEzE,UAAT,CAAoBiF,KAAK,CAACxB,EAA1B,CAAlB;EACA,IAAIyJ,eAAe,GAAGzI,OAAO,EAAE/D,MAAT,IAAmBuE,KAAK,CAACxB,EAAN,IAAYgB,OAAO,CAAC/D,MAA7D;EACA,IAAIyM,YAAY,GAAG1I,OAAO,EAAE/D,MAAT,GAAkBuE,KAAK,CAACxB,EAAxB,CAAnB;EACA,IAAI2J,kBAAkB,GAAGnI,KAAK,CAAC5E,YAAN,EAAoBgN,OAApB,KAAgC,IAAhC,IAAwC,CAACpI,KAAK,CAAC/E,SAA/C,IAA4D;EACrF;EACA;EACA+E,KAAK,CAAC6C,YAAN,IAAsB,CAAC7C,KAAK,CAAC7C,OAH7B;EAIA1F,SAAS,CAACmB,MAAM,CAACG,yBAAR,CAAT;EACAxC,uBAAuB,CAACqC,MAAM,CAACG,yBAAR,EAAmCiH,KAAnC,CAAvB;EACA,IAAIqI,SAAS,GAAG;IACd7J,EAAE,EAAEwB,KAAK,CAACxB,EADI;IAEdrB,OAAO,EAAE6C,KAAK,CAAC7C,OAFD;IAGd8F,YAAY,EAAEjD,KAAK,CAACiD,YAHN;IAIdC,MAAM,EAAElD,KAAK,CAACkD,MAJA;IAKdJ,gBAAgB,EAAE9C,KAAK,CAAC8C,gBALV;IAMdlB,sBAAsB,EAAE5B,KAAK,CAAC4B,sBANhB;IAOduB,KAAK,EAAEnD,KAAK,CAACmD,KAPC;IAQdmF,MAAM,EAAEtI,KAAK,CAAC5E,YAAN,GAAqB,OAAOqD,IAAP,EAAa8J,WAAb,KAA6B;MACxD,IAAI;QACF,IAAIC,MAAM,GAAG,MAAMxI,KAAK,CAAC5E,YAAN,CAAmB,EACpC,GAAGqD,IADiC;UAEpCgK,YAAY,EAAE,MAAM;YAClBC,+BAA+B,CAC7B,QAD6B,EAE7B1I,KAAK,CAACxB,EAFuB,EAG7BwB,KAAK,CAAC/E,SAHuB,CAA/B;;YAKA,IAAIkN,kBAAJ,EAAwB;cACtB,IAAIJ,cAAJ,EAAoB;gBAClB,OAAOC,WAAP;cACD;;cACD,IAAIC,eAAJ,EAAqB;gBACnB,MAAMC,YAAN;cACD;YACF;;YACD,OAAOS,eAAe,CAACJ,WAAD,CAAtB;UACD;QAjBmC,CAAnB,CAAnB;QAmBA,OAAOC,MAAP;MACD,CArBD,SAqBU;QACRL,kBAAkB,GAAG,KAArB;MACD;IACF,CAzBO,GA0BN;IACA;IACA,CAACS,CAAD,EAAIL,WAAJ,KAAoBI,eAAe,CAACJ,WAAD,CApCvB;IAsCdM,MAAM,EAAE7I,KAAK,CAACgD,YAAN,GAAqB,CAACvE,IAAD,EAAO8J,WAAP,KAAuBvI,KAAK,CAACgD,YAAN,CAAmB,EACrE,GAAGvE,IADkE;MAErEqK,YAAY,EAAE,YAAY;QACxBJ,+BAA+B,CAC7B,QAD6B,EAE7B1I,KAAK,CAACxB,EAFuB,EAG7BwB,KAAK,CAAC/E,SAHuB,CAA/B;QAKA,OAAO,MAAM0N,eAAe,CAACJ,WAAD,CAA5B;MACD;IAToE,CAAnB,CAA5C,GAUHvI,KAAK,CAAC4C,SAAN,GAAkB,CAACgG,CAAD,EAAIL,WAAJ,KAAoBI,eAAe,CAACJ,WAAD,CAArD,GAAqE,MAAM;MAC9E,MAAM3Q,oBAAoB,CAAC,QAAD,EAAWoI,KAAK,CAACxB,EAAjB,CAA1B;IACD,CAlDa;IAmDdqD,IAAI,EAAE7B,KAAK,CAAC6B,IAnDE;IAoDdyB,gBAAgB,EAAEtD,KAAK,CAACsD,gBApDV;IAqDd;IACA;IACArI,SAAS,EAAE,IAvDG;IAwDd2I,eAAe,EAAE5D,KAAK,CAAC5E,YAAN,IAAsB,IAxDzB;IAyDdwH,SAAS,EAAE5C,KAAK,CAAC4C,SAzDH;IA0DdiB,eAAe,EAAE7D,KAAK,CAACgD,YAAN,IAAsB,IA1DzB;IA2Ddc,mBAAmB,EAAE9D,KAAK,CAACsD,gBAAN,IAA0B;EA3DjC,CAAhB;;EA6DA,IAAI,OAAO+E,SAAS,CAACC,MAAjB,KAA4B,UAAhC,EAA4C;IAC1CD,SAAS,CAACC,MAAV,CAAiBF,OAAjB,GAA2BtQ,wBAAwB,CACjDkI,KAAK,CAACxB,EAD2C,EAEjDwB,KAAK,CAAC5E,YAF2C,EAGjD4E,KAAK,CAAC/E,SAH2C,EAIjD,KAJiD,CAAnD;EAMD;;EACD,OAAOoN,SAAP;AACD;;AACD,SAASM,eAAT,CAAyBJ,WAAzB,EAAsC;EACpC9Q,SAAS,CAAC,OAAO8Q,WAAP,KAAuB,UAAxB,EAAoC,+BAApC,CAAT;EACA,OAAOA,WAAW,EAAlB;AACD;;AACD,SAASG,+BAAT,CAAyCjJ,IAAzC,EAA+CtE,OAA/C,EAAwD4N,UAAxD,EAAoE;EAClE,IAAI,CAACA,UAAL,EAAiB;IACf,IAAIC,EAAE,GAAGvJ,IAAI,KAAK,QAAT,GAAoB,gBAApB,GAAuC,gBAAhD;IACA,IAAIwJ,GAAG,GAAI,0BAAyBD,EAAG,2CAA0CvJ,IAAK,eAActE,OAAQ,IAA5G;IACA1B,OAAO,CAACC,KAAR,CAAcuP,GAAd;IACA,MAAM,IAAIxS,iBAAJ,CAAsB,GAAtB,EAA2B,aAA3B,EAA0C,IAAI0D,KAAJ,CAAU8O,GAAV,CAA1C,EAA0D,IAA1D,CAAN;EACD;AACF;;AACD,IAAI7C,SAAS,GAAG,eAAgB,IAAI8C,GAAJ,EAAhC;AACA,IAAIC,sBAAsB,GAAG,GAA7B;AACA,IAAIpH,eAAe,GAAG,eAAgB,IAAImH,GAAJ,EAAtC;AACA,IAAIE,SAAS,GAAG,IAAhB;;AACA,SAASC,cAAT,CAAwB9C,KAAxB,EAA+B;EAC7B,IAAIA,KAAK,CAACnF,MAAN,KAAiB,CAArB,EAAwB;IACtB,OAAO,IAAP;EACD;;EACD,IAAImF,KAAK,CAACnF,MAAN,KAAiB,CAArB,EAAwB;IACtB,OAAO,IAAI8E,GAAJ,CAAS,GAAEK,KAAK,CAAC,CAAD,CAAI,WAApB,EAAgC3N,MAAM,CAAC2C,QAAP,CAAgB4K,MAAhD,CAAP;EACD;;EACD,MAAM7H,SAAS,GAAG1F,MAAlB;EACA,IAAI4C,QAAQ,GAAG,CAAC8C,SAAS,CAAC9B,uBAAV,CAAkChB,QAAlC,IAA8C,EAA/C,EAAmDqE,OAAnD,CACb,UADa,EAEb,EAFa,CAAf;EAIA,IAAI2E,GAAG,GAAG,IAAI0B,GAAJ,CAAS,GAAE1K,QAAS,YAApB,EAAiC5C,MAAM,CAAC2C,QAAP,CAAgB4K,MAAjD,CAAV;EACA3B,GAAG,CAACC,YAAJ,CAAiB3D,GAAjB,CAAqB,OAArB,EAA8ByF,KAAK,CAAC+C,IAAN,GAAa5E,IAAb,CAAkB,GAAlB,CAA9B;EACA,OAAOF,GAAP;AACD;;AACD,eAAexC,4BAAf,CAA4CuE,KAA5C,EAAmDtI,wBAAnD,EAA6EI,mBAA7E,EAAkGyD,MAAlG,EAA0G;EACxG,IAAI0C,GAAG,GAAG6E,cAAc,CAAC9C,KAAD,CAAxB;;EACA,IAAI/B,GAAG,IAAI,IAAX,EAAiB;IACf;EACD;;EACD,IAAIA,GAAG,CAAC+E,QAAJ,GAAenI,MAAf,GAAwBgI,SAA5B,EAAuC;IACrChD,SAAS,CAACoD,KAAV;IACA;EACD;;EACD,IAAIpK,QAAQ,GAAG,MAAMf,mBAAmB,CAAC,IAAIS,OAAJ,CAAY0F,GAAZ,EAAiB;IAAE1C;EAAF,CAAjB,CAAD,CAAxC;;EACA,IAAI,CAAC1C,QAAQ,CAACJ,IAAV,IAAkBI,QAAQ,CAACwF,MAAT,GAAkB,GAApC,IAA2CxF,QAAQ,CAACwF,MAAT,IAAmB,GAAlE,EAAuE;IACrE,MAAM,IAAIzK,KAAJ,CAAU,mDAAV,CAAN;EACD;;EACD,IAAIqF,OAAO,GAAG,MAAMvB,wBAAwB,CAACmB,QAAQ,CAACJ,IAAV,EAAgB;IAC1DJ,mBAAmB,EAAE,KAAK;EADgC,CAAhB,CAA5C;;EAGA,IAAIY,OAAO,CAACC,IAAR,KAAiB,UAArB,EAAiC;IAC/B,MAAM,IAAItF,KAAJ,CAAU,wBAAV,CAAN;EACD;;EACDoM,KAAK,CAACrJ,OAAN,CAAeuM,CAAD,IAAOC,cAAc,CAACD,CAAD,EAAI1H,eAAJ,CAAnC;EACAjE,MAAM,CAACuB,eAAP,CAAuB,MAAM;IAC3BG,OAAO,CAACiB,OAAR,CAAgBvD,OAAhB,CAAyBuM,CAAD,IAAO;MAC7B7Q,MAAM,CAAC4D,uBAAP,CAA+B0D,WAA/B,CACEuJ,CAAC,CAAC7I,QAAF,IAAc,IADhB,EAEE,CAACT,6BAA6B,CAACsJ,CAAD,CAA9B,CAFF;IAID,CALD;EAMD,CAPD;AAQD;;AACD,SAASC,cAAT,CAAwB7H,IAAxB,EAA8B8H,KAA9B,EAAqC;EACnC,IAAIA,KAAK,CAACC,IAAN,IAAcT,sBAAlB,EAA0C;IACxC,IAAIU,KAAK,GAAGF,KAAK,CAACG,MAAN,GAAeC,IAAf,GAAsBxP,KAAlC;IACA,IAAI,OAAOsP,KAAP,KAAiB,QAArB,EAA+BF,KAAK,CAAC/C,MAAN,CAAaiD,KAAb;EAChC;;EACDF,KAAK,CAACtD,GAAN,CAAUxE,IAAV;AACD;;AACD,SAASiF,QAAT,CAAkBkD,QAAlB,EAA4BC,IAA5B,EAAkC;EAChC,IAAIC,SAAJ;EACA,OAAO,YAAa;IAAA,kCAATzL,IAAS;MAATA,IAAS;IAAA;;IAClB7F,MAAM,CAACuR,YAAP,CAAoBD,SAApB;IACAA,SAAS,GAAGtR,MAAM,CAACwR,UAAP,CAAkB,MAAMJ,QAAQ,CAAC,GAAGvL,IAAJ,CAAhC,EAA2CwL,IAA3C,CAAZ;EACD,CAHD;AAID;;AACD,SAAStK,kBAAT,CAA4BtC,SAA5B,EAAuC;EACrC,MAAMgN,WAAW,GAAG,IAAInE,GAAJ,CAAQ7I,SAAR,EAAmBzE,MAAM,CAAC2C,QAAP,CAAgBwD,IAAnC,CAApB;EACA,OAAOsL,WAAW,CAAClE,MAAZ,KAAuBvN,MAAM,CAAC2C,QAAP,CAAgB4K,MAA9C;AACD;;AACD,SAASZ,WAAT,CAAqB5K,MAArB,EAA6B;EAC3B,IAAI,CAACA,MAAL,EAAa,OAAO,KAAK,CAAZ;EACb,OAAOA,MAAM,CAAC4G,GAAP,CAAYJ,KAAD,KAAY,EAC5B,GAAGA,KADyB;IAE5BE,QAAQ,EAAEkE,WAAW,CAACpE,KAAK,CAACE,QAAP;EAFO,CAAZ,CAAX,CAAP;AAID;;AACD,SAASmE,UAAT,CAAoB8E,CAApB,EAAuBC,CAAvB,EAA0B;EACxB,IAAID,CAAC,CAAClJ,MAAF,KAAamJ,CAAC,CAACnJ,MAAnB,EAA2B,OAAO,IAAP;EAC3B,OAAOkJ,CAAC,CAACE,IAAF,CAAO,CAACrJ,KAAD,EAAQgC,KAAR,KAAkB;IAC9B,IAAIhC,KAAK,CAAChE,OAAN,KAAkBoN,CAAC,CAACpH,KAAD,CAAD,CAAShG,OAA/B,EAAwC,OAAO,IAAP;IACxC,IAAIgE,KAAK,CAAC8B,YAAN,KAAuBsH,CAAC,CAACpH,KAAD,CAAD,CAASF,YAApC,EACE,OAAO,IAAP;IACF,IAAI9B,KAAK,CAACS,sBAAN,KAAiC2I,CAAC,CAACpH,KAAD,CAAD,CAASvB,sBAA9C,EACE,OAAO,IAAP;IACF,IAAIT,KAAK,CAAC2B,gBAAN,KAA2ByH,CAAC,CAACpH,KAAD,CAAD,CAASL,gBAAxC,EACE,OAAO,IAAP;IACF,IAAI3B,KAAK,CAAClG,SAAN,KAAoBsP,CAAC,CAACpH,KAAD,CAAD,CAASlI,SAAjC,EAA4C,OAAO,IAAP;IAC5C,IAAIkG,KAAK,CAACyC,eAAN,KAA0B2G,CAAC,CAACpH,KAAD,CAAD,CAASS,eAAvC,EACE,OAAO,IAAP;IACF,IAAIzC,KAAK,CAACyB,SAAN,KAAoB2H,CAAC,CAACpH,KAAD,CAAD,CAASP,SAAjC,EAA4C,OAAO,IAAP;IAC5C,IAAIzB,KAAK,CAAC0C,eAAN,KAA0B0G,CAAC,CAACpH,KAAD,CAAD,CAASU,eAAvC,EACE,OAAO,IAAP;IACF,OAAO2B,UAAU,CAACrE,KAAK,CAACE,QAAN,IAAkB,EAAnB,EAAuBkJ,CAAC,CAACpH,KAAD,CAAD,CAAS9B,QAAT,IAAqB,EAA5C,CAAjB;EACD,CAfM,CAAP;AAgBD,C,CAED;;;AACA,SAASoJ,YAAT,GAAwB;EACtB,IAAIC,OAAO,GAAG,IAAIC,WAAJ,EAAd;EACA,IAAIC,gBAAgB,GAAG,IAAvB;EACA,IAAIC,SAAS,GAAG,IAAIC,cAAJ,CAAmB;IACjCC,KAAK,CAACC,UAAD,EAAa;MAChB,IAAI,OAAOpS,MAAP,KAAkB,WAAtB,EAAmC;QACjC;MACD;;MACD,IAAIqS,WAAW,GAAIC,KAAD,IAAW;QAC3B,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;UAC7BF,UAAU,CAACG,OAAX,CAAmBT,OAAO,CAACU,MAAR,CAAeF,KAAf,CAAnB;QACD,CAFD,MAEO;UACLF,UAAU,CAACG,OAAX,CAAmBD,KAAnB;QACD;MACF,CAND;;MAOAtS,MAAM,CAACyS,aAAP,KAAyBzS,MAAM,CAACyS,aAAP,GAAuB,EAAhD;;MACAzS,MAAM,CAACyS,aAAP,CAAqBnO,OAArB,CAA6B+N,WAA7B;;MACArS,MAAM,CAACyS,aAAP,CAAqBrK,IAArB,GAA6BkK,KAAD,IAAW;QACrCD,WAAW,CAACC,KAAD,CAAX;QACA,OAAO,CAAP;MACD,CAHD;;MAIAN,gBAAgB,GAAGI,UAAnB;IACD;;EAnBgC,CAAnB,CAAhB;;EAqBA,IAAI,OAAO9R,QAAP,KAAoB,WAApB,IAAmCA,QAAQ,CAACoS,UAAT,KAAwB,SAA/D,EAA0E;IACxEpS,QAAQ,CAACqS,gBAAT,CAA0B,kBAA1B,EAA8C,MAAM;MAClDX,gBAAgB,EAAEY,KAAlB;IACD,CAFD;EAGD,CAJD,MAIO;IACLZ,gBAAgB,EAAEY,KAAlB;EACD;;EACD,OAAOX,SAAP;AACD;;AACD,SACEpO,cADF,EAEErE,eAAe,IAAIvB,cAFrB,EAGEuO,iBAAiB,IAAIqG,0BAHvB,EAIEzN,gBAAgB,IAAI0N,yBAJtB,EAKEjB,YAAY,IAAIkB,qBALlB"},"metadata":{},"sourceType":"module"}