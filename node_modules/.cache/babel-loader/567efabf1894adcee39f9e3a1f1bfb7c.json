{"ast":null,"code":"import { GroupAnimation } from '../animation/GroupAnimation.mjs';\nimport { copyBoxInto } from '../projection/geometry/copy.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { HTMLProjectionNode } from '../projection/node/HTMLProjectionNode.mjs';\nimport { HTMLVisualElement } from '../render/html/HTMLVisualElement.mjs';\nimport { visualElementStore } from '../render/store.mjs';\nimport { resolveElements } from '../utils/resolve-elements.mjs';\nimport { frame } from '../frameloop/frame.mjs';\nconst layoutSelector = \"[data-layout], [data-layout-id]\";\n\nconst noop = () => {};\n\nfunction snapshotFromTarget(projection) {\n  const target = projection.targetWithTransforms || projection.target;\n  if (!target) return undefined;\n  const measuredBox = createBox();\n  const layoutBox = createBox();\n  copyBoxInto(measuredBox, target);\n  copyBoxInto(layoutBox, target);\n  return {\n    animationId: projection.root?.animationId ?? 0,\n    measuredBox,\n    layoutBox,\n    latestValues: projection.animationValues || projection.latestValues || {},\n    source: projection.id\n  };\n}\n\nclass LayoutAnimationBuilder {\n  constructor(scope, updateDom, defaultOptions) {\n    this.sharedTransitions = new Map();\n    this.notifyReady = noop;\n    this.rejectReady = noop;\n    this.scope = scope;\n    this.updateDom = updateDom;\n    this.defaultOptions = defaultOptions;\n    this.readyPromise = new Promise((resolve, reject) => {\n      this.notifyReady = resolve;\n      this.rejectReady = reject;\n    });\n    frame.postRender(() => {\n      this.start().then(this.notifyReady).catch(this.rejectReady);\n    });\n  }\n\n  shared(id, transition) {\n    this.sharedTransitions.set(id, transition);\n    return this;\n  }\n\n  then(resolve, reject) {\n    return this.readyPromise.then(resolve, reject);\n  }\n\n  async start() {\n    const beforeElements = collectLayoutElements(this.scope);\n    const beforeRecords = this.buildRecords(beforeElements);\n    beforeRecords.forEach(_ref => {\n      let {\n        projection\n      } = _ref;\n      const hasCurrentAnimation = Boolean(projection.currentAnimation);\n      const isSharedLayout = Boolean(projection.options.layoutId);\n\n      if (hasCurrentAnimation && isSharedLayout) {\n        const snapshot = snapshotFromTarget(projection);\n\n        if (snapshot) {\n          projection.snapshot = snapshot;\n        } else if (projection.snapshot) {\n          projection.snapshot = undefined;\n        }\n      } else if (projection.snapshot && (projection.currentAnimation || projection.isProjecting())) {\n        projection.snapshot = undefined;\n      }\n\n      projection.isPresent = true;\n      projection.willUpdate();\n    });\n    await this.updateDom();\n    const afterElements = collectLayoutElements(this.scope);\n    const afterRecords = this.buildRecords(afterElements);\n    this.handleExitingElements(beforeRecords, afterRecords);\n    afterRecords.forEach(_ref2 => {\n      let {\n        projection\n      } = _ref2;\n      const instance = projection.instance;\n      const resumeFromInstance = projection.resumeFrom?.instance;\n      if (!instance || !resumeFromInstance) return;\n      if (!(\"style\" in instance)) return;\n      const currentTransform = instance.style.transform;\n      const resumeFromTransform = resumeFromInstance.style.transform;\n\n      if (currentTransform && resumeFromTransform && currentTransform === resumeFromTransform) {\n        instance.style.transform = \"\";\n        instance.style.transformOrigin = \"\";\n      }\n    });\n    afterRecords.forEach(_ref3 => {\n      let {\n        projection\n      } = _ref3;\n      projection.isPresent = true;\n    });\n    const root = getProjectionRoot(afterRecords, beforeRecords);\n    root?.didUpdate();\n    await new Promise(resolve => {\n      frame.postRender(() => resolve());\n    });\n    const animations = collectAnimations(afterRecords);\n    const animation = new GroupAnimation(animations);\n    return animation;\n  }\n\n  buildRecords(elements) {\n    const records = [];\n    const recordMap = new Map();\n\n    for (const element of elements) {\n      const parentRecord = findParentRecord(element, recordMap, this.scope);\n      const {\n        layout,\n        layoutId\n      } = readLayoutAttributes(element);\n      const override = layoutId ? this.sharedTransitions.get(layoutId) : undefined;\n      const transition = override || this.defaultOptions;\n      const record = getOrCreateRecord(element, parentRecord?.projection, {\n        layout,\n        layoutId,\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        transition: transition\n      });\n      recordMap.set(element, record);\n      records.push(record);\n    }\n\n    return records;\n  }\n\n  handleExitingElements(beforeRecords, afterRecords) {\n    const afterElementsSet = new Set(afterRecords.map(record => record.element));\n    beforeRecords.forEach(record => {\n      if (afterElementsSet.has(record.element)) return; // For shared layout elements, relegate to set up resumeFrom\n      // so the remaining element animates from this position\n\n      if (record.projection.options.layoutId) {\n        record.projection.isPresent = false;\n        record.projection.relegate();\n      }\n\n      record.visualElement.unmount();\n      visualElementStore.delete(record.element);\n    }); // Clear resumeFrom on EXISTING nodes that point to unmounted projections\n    // This prevents crossfade animation when the source element was removed entirely\n    // But preserve resumeFrom for NEW nodes so they can animate from the old position\n    // Also preserve resumeFrom for lead nodes that were just promoted via relegate\n\n    const beforeElementsSet = new Set(beforeRecords.map(record => record.element));\n    afterRecords.forEach(_ref4 => {\n      let {\n        element,\n        projection\n      } = _ref4;\n\n      if (beforeElementsSet.has(element) && projection.resumeFrom && !projection.resumeFrom.instance && !projection.isLead()) {\n        projection.resumeFrom = undefined;\n        projection.snapshot = undefined;\n      }\n    });\n  }\n\n}\n\nfunction parseAnimateLayoutArgs(scopeOrUpdateDom, updateDomOrOptions, options) {\n  // animateLayout(updateDom)\n  if (typeof scopeOrUpdateDom === \"function\") {\n    return {\n      scope: document,\n      updateDom: scopeOrUpdateDom,\n      defaultOptions: updateDomOrOptions\n    };\n  } // animateLayout(scope, updateDom, options?)\n\n\n  const elements = resolveElements(scopeOrUpdateDom);\n  const scope = elements[0] || document;\n  return {\n    scope,\n    updateDom: updateDomOrOptions,\n    defaultOptions: options\n  };\n}\n\nfunction collectLayoutElements(scope) {\n  const elements = Array.from(scope.querySelectorAll(layoutSelector));\n\n  if (scope instanceof Element && scope.matches(layoutSelector)) {\n    if (!elements.includes(scope)) {\n      elements.unshift(scope);\n    }\n  }\n\n  return elements;\n}\n\nfunction readLayoutAttributes(element) {\n  const layoutId = element.getAttribute(\"data-layout-id\") || undefined;\n  const rawLayout = element.getAttribute(\"data-layout\");\n  let layout;\n\n  if (rawLayout === \"\" || rawLayout === \"true\") {\n    layout = true;\n  } else if (rawLayout) {\n    layout = rawLayout;\n  }\n\n  return {\n    layout,\n    layoutId\n  };\n}\n\nfunction createVisualState() {\n  return {\n    latestValues: {},\n    renderState: {\n      transform: {},\n      transformOrigin: {},\n      style: {},\n      vars: {}\n    }\n  };\n}\n\nfunction getOrCreateRecord(element, parentProjection, projectionOptions) {\n  const existing = visualElementStore.get(element);\n  const visualElement = existing ?? new HTMLVisualElement({\n    props: {},\n    presenceContext: null,\n    visualState: createVisualState()\n  }, {\n    allowProjection: true\n  });\n\n  if (!existing || !visualElement.projection) {\n    visualElement.projection = new HTMLProjectionNode(visualElement.latestValues, parentProjection);\n  }\n\n  visualElement.projection.setOptions({ ...projectionOptions,\n    visualElement\n  });\n\n  if (!visualElement.current) {\n    visualElement.mount(element);\n  } else if (!visualElement.projection.instance) {\n    // Mount projection if VisualElement is already mounted but projection isn't\n    // This happens when animate() was called before animateLayout()\n    visualElement.projection.mount(element);\n  }\n\n  if (!existing) {\n    visualElementStore.set(element, visualElement);\n  }\n\n  return {\n    element,\n    visualElement,\n    projection: visualElement.projection\n  };\n}\n\nfunction findParentRecord(element, recordMap, scope) {\n  let parent = element.parentElement;\n\n  while (parent) {\n    const record = recordMap.get(parent);\n    if (record) return record;\n    if (parent === scope) break;\n    parent = parent.parentElement;\n  }\n\n  return undefined;\n}\n\nfunction getProjectionRoot(afterRecords, beforeRecords) {\n  const record = afterRecords[0] || beforeRecords[0];\n  return record?.projection.root;\n}\n\nfunction collectAnimations(afterRecords) {\n  const animations = new Set();\n  afterRecords.forEach(record => {\n    const animation = record.projection.currentAnimation;\n    if (animation) animations.add(animation);\n  });\n  return Array.from(animations);\n}\n\nexport { LayoutAnimationBuilder, parseAnimateLayoutArgs };","map":{"version":3,"mappings":"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","names":["layoutSelector","noop","snapshotFromTarget","projection","target","targetWithTransforms","undefined","measuredBox","createBox","layoutBox","copyBoxInto","animationId","root","latestValues","animationValues","source","id","LayoutAnimationBuilder","constructor","scope","updateDom","defaultOptions","Map","notifyReady","rejectReady","readyPromise","Promise","resolve","reject","frame","postRender","start","then","catch","shared","transition","sharedTransitions","set","beforeElements","collectLayoutElements","beforeRecords","buildRecords","forEach","hasCurrentAnimation","Boolean","currentAnimation","isSharedLayout","options","layoutId","snapshot","isProjecting","isPresent","willUpdate","afterElements","afterRecords","handleExitingElements","instance","resumeFromInstance","resumeFrom","currentTransform","style","transform","resumeFromTransform","transformOrigin","getProjectionRoot","didUpdate","animations","collectAnimations","animation","GroupAnimation","elements","records","recordMap","element","parentRecord","findParentRecord","layout","readLayoutAttributes","override","get","record","getOrCreateRecord","animationType","push","afterElementsSet","Set","map","has","relegate","visualElement","unmount","visualElementStore","delete","beforeElementsSet","isLead","parseAnimateLayoutArgs","scopeOrUpdateDom","updateDomOrOptions","document","resolveElements","Array","from","querySelectorAll","Element","matches","includes","unshift","getAttribute","rawLayout","createVisualState","renderState","vars","parentProjection","projectionOptions","existing","HTMLVisualElement","props","presenceContext","visualState","allowProjection","HTMLProjectionNode","setOptions","current","mount","parent","parentElement","add"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\layout\\LayoutAnimationBuilder.ts"],"sourcesContent":["import type { Box } from \"motion-utils\"\nimport { GroupAnimation } from \"../animation/GroupAnimation\"\nimport type {\n    AnimationOptions,\n    AnimationPlaybackControls,\n    Transition,\n} from \"../animation/types\"\nimport { frame } from \"../frameloop\"\nimport { copyBoxInto } from \"../projection/geometry/copy\"\nimport { createBox } from \"../projection/geometry/models\"\nimport { HTMLProjectionNode } from \"../projection/node/HTMLProjectionNode\"\nimport type { IProjectionNode } from \"../projection/node/types\"\nimport { HTMLVisualElement } from \"../render/html/HTMLVisualElement\"\nimport { visualElementStore } from \"../render/store\"\nimport type { VisualElement } from \"../render/VisualElement\"\nimport { resolveElements, type ElementOrSelector } from \"../utils/resolve-elements\"\n\ntype LayoutAnimationScope = Element | Document\n\ninterface LayoutElementRecord {\n    element: Element\n    visualElement: VisualElement\n    projection: IProjectionNode\n}\n\ninterface LayoutAttributes {\n    layout?: boolean | \"position\" | \"size\" | \"preserve-aspect\"\n    layoutId?: string\n}\n\ntype LayoutBuilderResolve = (animation: GroupAnimation) => void\ntype LayoutBuilderReject = (error: unknown) => void\n\ninterface ProjectionOptions {\n    layout?: boolean | \"position\" | \"size\" | \"preserve-aspect\"\n    layoutId?: string\n    animationType?: \"size\" | \"position\" | \"both\" | \"preserve-aspect\"\n    transition?: Transition\n    crossfade?: boolean\n}\n\nconst layoutSelector = \"[data-layout], [data-layout-id]\"\nconst noop = () => {}\nfunction snapshotFromTarget(projection: IProjectionNode): LayoutElementRecord[\"projection\"][\"snapshot\"] {\n    const target = projection.targetWithTransforms || projection.target\n    if (!target) return undefined\n\n    const measuredBox = createBox()\n    const layoutBox = createBox()\n    copyBoxInto(measuredBox, target as Box)\n    copyBoxInto(layoutBox, target as Box)\n\n    return {\n        animationId: projection.root?.animationId ?? 0,\n        measuredBox,\n        layoutBox,\n        latestValues: projection.animationValues || projection.latestValues || {},\n        source: projection.id,\n    }\n}\n\nexport class LayoutAnimationBuilder {\n    private scope: LayoutAnimationScope\n    private updateDom: () => void | Promise<void>\n    private defaultOptions?: AnimationOptions\n    private sharedTransitions = new Map<string, AnimationOptions>()\n    private notifyReady: LayoutBuilderResolve = noop\n    private rejectReady: LayoutBuilderReject = noop\n    private readyPromise: Promise<GroupAnimation>\n\n    constructor(\n        scope: LayoutAnimationScope,\n        updateDom: () => void | Promise<void>,\n        defaultOptions?: AnimationOptions\n    ) {\n        this.scope = scope\n        this.updateDom = updateDom\n        this.defaultOptions = defaultOptions\n\n        this.readyPromise = new Promise<GroupAnimation>((resolve, reject) => {\n            this.notifyReady = resolve\n            this.rejectReady = reject\n        })\n\n        frame.postRender(() => {\n            this.start().then(this.notifyReady).catch(this.rejectReady)\n        })\n    }\n\n    shared(id: string, transition: AnimationOptions): this {\n        this.sharedTransitions.set(id, transition)\n        return this\n    }\n\n    then(\n        resolve: LayoutBuilderResolve,\n        reject?: LayoutBuilderReject\n    ): Promise<void> {\n        return this.readyPromise.then(resolve, reject)\n    }\n\n    private async start(): Promise<GroupAnimation> {\n        const beforeElements = collectLayoutElements(this.scope)\n        const beforeRecords = this.buildRecords(beforeElements)\n\n        beforeRecords.forEach(({ projection }) => {\n            const hasCurrentAnimation = Boolean(projection.currentAnimation)\n            const isSharedLayout = Boolean(projection.options.layoutId)\n            if (hasCurrentAnimation && isSharedLayout) {\n                const snapshot = snapshotFromTarget(projection)\n                if (snapshot) {\n                    projection.snapshot = snapshot\n                } else if (projection.snapshot) {\n                    projection.snapshot = undefined\n                }\n            } else if (\n                projection.snapshot &&\n                (projection.currentAnimation || projection.isProjecting())\n            ) {\n                projection.snapshot = undefined\n            }\n            projection.isPresent = true\n            projection.willUpdate()\n        })\n\n        await this.updateDom()\n\n        const afterElements = collectLayoutElements(this.scope)\n        const afterRecords = this.buildRecords(afterElements)\n        this.handleExitingElements(beforeRecords, afterRecords)\n\n        afterRecords.forEach(({ projection }) => {\n            const instance = projection.instance as HTMLElement | undefined\n            const resumeFromInstance = projection.resumeFrom\n                ?.instance as HTMLElement | undefined\n            if (!instance || !resumeFromInstance) return\n            if (!(\"style\" in instance)) return\n\n            const currentTransform = instance.style.transform\n            const resumeFromTransform = resumeFromInstance.style.transform\n\n            if (\n                currentTransform &&\n                resumeFromTransform &&\n                currentTransform === resumeFromTransform\n            ) {\n                instance.style.transform = \"\"\n                instance.style.transformOrigin = \"\"\n            }\n        })\n\n        afterRecords.forEach(({ projection }) => {\n            projection.isPresent = true\n        })\n\n        const root = getProjectionRoot(afterRecords, beforeRecords)\n        root?.didUpdate()\n\n        await new Promise<void>((resolve) => {\n            frame.postRender(() => resolve())\n        })\n\n        const animations = collectAnimations(afterRecords)\n        const animation = new GroupAnimation(animations)\n\n        return animation\n    }\n\n    private buildRecords(elements: Element[]): LayoutElementRecord[] {\n        const records: LayoutElementRecord[] = []\n        const recordMap = new Map<Element, LayoutElementRecord>()\n\n        for (const element of elements) {\n            const parentRecord = findParentRecord(element, recordMap, this.scope)\n            const { layout, layoutId } = readLayoutAttributes(element)\n            const override = layoutId\n                ? this.sharedTransitions.get(layoutId)\n                : undefined\n            const transition = override || this.defaultOptions\n            const record = getOrCreateRecord(element, parentRecord?.projection, {\n                layout,\n                layoutId,\n                animationType: typeof layout === \"string\" ? layout : \"both\",\n                transition: transition as Transition,\n            })\n            recordMap.set(element, record)\n            records.push(record)\n        }\n\n        return records\n    }\n\n    private handleExitingElements(\n        beforeRecords: LayoutElementRecord[],\n        afterRecords: LayoutElementRecord[]\n    ): void {\n        const afterElementsSet = new Set(afterRecords.map((record) => record.element))\n\n        beforeRecords.forEach((record) => {\n            if (afterElementsSet.has(record.element)) return\n\n            // For shared layout elements, relegate to set up resumeFrom\n            // so the remaining element animates from this position\n            if (record.projection.options.layoutId) {\n                record.projection.isPresent = false\n                record.projection.relegate()\n            }\n\n            record.visualElement.unmount()\n            visualElementStore.delete(record.element)\n        })\n\n        // Clear resumeFrom on EXISTING nodes that point to unmounted projections\n        // This prevents crossfade animation when the source element was removed entirely\n        // But preserve resumeFrom for NEW nodes so they can animate from the old position\n        // Also preserve resumeFrom for lead nodes that were just promoted via relegate\n        const beforeElementsSet = new Set(beforeRecords.map((record) => record.element))\n        afterRecords.forEach(({ element, projection }) => {\n            if (\n                beforeElementsSet.has(element) &&\n                projection.resumeFrom &&\n                !projection.resumeFrom.instance &&\n                !projection.isLead()\n            ) {\n                projection.resumeFrom = undefined\n                projection.snapshot = undefined\n            }\n        })\n    }\n}\n\nexport function parseAnimateLayoutArgs(\n    scopeOrUpdateDom: ElementOrSelector | (() => void),\n    updateDomOrOptions?: (() => void) | AnimationOptions,\n    options?: AnimationOptions\n): {\n    scope: Element | Document\n    updateDom: () => void\n    defaultOptions?: AnimationOptions\n} {\n    // animateLayout(updateDom)\n    if (typeof scopeOrUpdateDom === \"function\") {\n        return {\n            scope: document,\n            updateDom: scopeOrUpdateDom,\n            defaultOptions: updateDomOrOptions as AnimationOptions | undefined,\n        }\n    }\n\n    // animateLayout(scope, updateDom, options?)\n    const elements = resolveElements(scopeOrUpdateDom)\n    const scope = elements[0] || document\n\n    return {\n        scope,\n        updateDom: updateDomOrOptions as () => void,\n        defaultOptions: options,\n    }\n}\n\nfunction collectLayoutElements(scope: LayoutAnimationScope): Element[] {\n    const elements = Array.from(scope.querySelectorAll(layoutSelector))\n\n    if (scope instanceof Element && scope.matches(layoutSelector)) {\n        if (!elements.includes(scope)) {\n            elements.unshift(scope)\n        }\n    }\n\n    return elements\n}\n\nfunction readLayoutAttributes(element: Element): LayoutAttributes {\n    const layoutId = element.getAttribute(\"data-layout-id\") || undefined\n    const rawLayout = element.getAttribute(\"data-layout\")\n    let layout: LayoutAttributes[\"layout\"]\n\n    if (rawLayout === \"\" || rawLayout === \"true\") {\n        layout = true\n    } else if (rawLayout) {\n        layout = rawLayout as LayoutAttributes[\"layout\"]\n    }\n\n    return {\n        layout,\n        layoutId,\n    }\n}\n\nfunction createVisualState() {\n    return {\n        latestValues: {},\n        renderState: {\n            transform: {},\n            transformOrigin: {},\n            style: {},\n            vars: {},\n        },\n    }\n}\n\nfunction getOrCreateRecord(\n    element: Element,\n    parentProjection?: IProjectionNode,\n    projectionOptions?: ProjectionOptions\n): LayoutElementRecord {\n    const existing = visualElementStore.get(element) as VisualElement | undefined\n    const visualElement =\n        existing ??\n        new HTMLVisualElement(\n            {\n                props: {},\n                presenceContext: null,\n                visualState: createVisualState(),\n            },\n            { allowProjection: true }\n        )\n\n    if (!existing || !visualElement.projection) {\n        visualElement.projection = new HTMLProjectionNode(\n            visualElement.latestValues,\n            parentProjection\n        )\n    }\n\n    visualElement.projection.setOptions({\n        ...projectionOptions,\n        visualElement,\n    })\n\n    if (!visualElement.current) {\n        visualElement.mount(element as HTMLElement)\n    } else if (!visualElement.projection.instance) {\n        // Mount projection if VisualElement is already mounted but projection isn't\n        // This happens when animate() was called before animateLayout()\n        visualElement.projection.mount(element as HTMLElement)\n    }\n\n    if (!existing) {\n        visualElementStore.set(element, visualElement)\n    }\n\n    return {\n        element,\n        visualElement,\n        projection: visualElement.projection as IProjectionNode,\n    }\n}\n\nfunction findParentRecord(\n    element: Element,\n    recordMap: Map<Element, LayoutElementRecord>,\n    scope: LayoutAnimationScope\n) {\n    let parent = element.parentElement\n\n    while (parent) {\n        const record = recordMap.get(parent)\n        if (record) return record\n\n        if (parent === scope) break\n        parent = parent.parentElement\n    }\n\n    return undefined\n}\n\nfunction getProjectionRoot(\n    afterRecords: LayoutElementRecord[],\n    beforeRecords: LayoutElementRecord[]\n) {\n    const record = afterRecords[0] || beforeRecords[0]\n    return record?.projection.root\n}\n\nfunction collectAnimations(afterRecords: LayoutElementRecord[]) {\n    const animations = new Set<AnimationPlaybackControls>()\n\n    afterRecords.forEach((record) => {\n        const animation = record.projection.currentAnimation\n        if (animation) animations.add(animation)\n    })\n\n    return Array.from(animations)\n}\n"]},"metadata":{},"sourceType":"module"}