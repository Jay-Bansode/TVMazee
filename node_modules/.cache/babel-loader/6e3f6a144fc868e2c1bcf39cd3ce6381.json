{"ast":null,"code":"import { removeItem } from 'motion-utils';\nimport { microtask } from '../frameloop/microtask.mjs';\nimport { startViewAnimation } from './start.mjs';\nlet builders = [];\nlet current = null;\n\nfunction next() {\n  current = null;\n  const [nextBuilder] = builders;\n  if (nextBuilder) start(nextBuilder);\n}\n\nfunction start(builder) {\n  removeItem(builders, builder);\n  current = builder;\n  startViewAnimation(builder).then(animation => {\n    builder.notifyReady(animation);\n    animation.finished.finally(next);\n  });\n}\n\nfunction processQueue() {\n  /**\n   * Iterate backwards over the builders array. We can ignore the\n   * \"wait\" animations. If we have an interrupting animation in the\n   * queue then we need to batch all preceeding animations into it.\n   * Currently this only batches the update functions but will also\n   * need to batch the targets.\n   */\n  for (let i = builders.length - 1; i >= 0; i--) {\n    const builder = builders[i];\n    const {\n      interrupt\n    } = builder.options;\n\n    if (interrupt === \"immediate\") {\n      const batchedUpdates = builders.slice(0, i + 1).map(b => b.update);\n      const remaining = builders.slice(i + 1);\n\n      builder.update = () => {\n        batchedUpdates.forEach(update => update());\n      }; // Put the current builder at the front, followed by any \"wait\" builders\n\n\n      builders = [builder, ...remaining];\n      break;\n    }\n  }\n\n  if (!current || builders[0]?.options.interrupt === \"immediate\") {\n    next();\n  }\n}\n\nfunction addToQueue(builder) {\n  builders.push(builder);\n  microtask.render(processQueue);\n}\n\nexport { addToQueue };","map":{"version":3,"mappings":";;;AAKA,IAAIA,QAAQ,GAA4B,EAAxC;AAEA,IAAIC,OAAO,GAAiC,IAA5C;;AAEA,SAASC,IAAT,GAAa;EACTD,OAAO,GAAG,IAAV;EACA,MAAM,CAACE,WAAD,IAAgBH,QAAtB;EACA,IAAIG,WAAJ,EAAiBC,KAAK,CAACD,WAAD,CAAL;AACpB;;AAED,SAASC,KAAT,CAAeC,OAAf,EAA6C;EACzCC,UAAU,CAACN,QAAD,EAAWK,OAAX,CAAV;EACAJ,OAAO,GAAGI,OAAV;EACAE,kBAAkB,CAACF,OAAD,CAAlB,CAA4BG,IAA5B,CAAkCC,SAAD,IAAc;IAC3CJ,OAAO,CAACK,WAAR,CAAoBD,SAApB;IACAA,SAAS,CAACE,QAAV,CAAmBC,OAAnB,CAA2BV,IAA3B;EACH,CAHD;AAIH;;AAED,SAASW,YAAT,GAAqB;EACjB;;;;;;AAMG;EACH,KAAK,IAAIC,CAAC,GAAGd,QAAQ,CAACe,MAAT,GAAkB,CAA/B,EAAkCD,CAAC,IAAI,CAAvC,EAA0CA,CAAC,EAA3C,EAA+C;IAC3C,MAAMT,OAAO,GAAGL,QAAQ,CAACc,CAAD,CAAxB;IACA,MAAM;MAAEE;IAAF,IAAgBX,OAAO,CAACY,OAA9B;;IAEA,IAAID,SAAS,KAAK,WAAlB,EAA+B;MAC3B,MAAME,cAAc,GAAGlB,QAAQ,CAACmB,KAAT,CAAe,CAAf,EAAkBL,CAAC,GAAG,CAAtB,EAAyBM,GAAzB,CAA8BC,CAAD,IAAOA,CAAC,CAACC,MAAtC,CAAvB;MACA,MAAMC,SAAS,GAAGvB,QAAQ,CAACmB,KAAT,CAAeL,CAAC,GAAG,CAAnB,CAAlB;;MAEAT,OAAO,CAACiB,MAAR,GAAiB,MAAK;QAClBJ,cAAc,CAACM,OAAf,CAAwBF,MAAD,IAAYA,MAAM,EAAzC;MACH,CAFD,CAJ2B;;;MAS3BtB,QAAQ,GAAG,CAACK,OAAD,EAAU,GAAGkB,SAAb,CAAX;MAEA;IACH;EACJ;;EAED,IAAI,CAACtB,OAAD,IAAYD,QAAQ,CAAC,CAAD,CAAR,EAAaiB,OAAb,CAAqBD,SAArB,KAAmC,WAAnD,EAAgE;IAC5Dd,IAAI;EACP;AACJ;;AAEK,SAAUuB,UAAV,CAAqBpB,OAArB,EAAmD;EACrDL,QAAQ,CAAC0B,IAAT,CAAcrB,OAAd;EACAsB,SAAS,CAACC,MAAV,CAAiBf,YAAjB;AACJ","names":["builders","current","next","nextBuilder","start","builder","removeItem","startViewAnimation","then","animation","notifyReady","finished","finally","processQueue","i","length","interrupt","options","batchedUpdates","slice","map","b","update","remaining","forEach","addToQueue","push","microtask","render"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\view\\queue.ts"],"sourcesContent":["import { removeItem } from \"motion-utils\"\nimport type { ViewTransitionBuilder } from \".\"\nimport { microtask } from \"../frameloop/microtask\"\nimport { startViewAnimation } from \"./start\"\n\nlet builders: ViewTransitionBuilder[] = []\n\nlet current: ViewTransitionBuilder | null = null\n\nfunction next() {\n    current = null\n    const [nextBuilder] = builders\n    if (nextBuilder) start(nextBuilder)\n}\n\nfunction start(builder: ViewTransitionBuilder) {\n    removeItem(builders, builder)\n    current = builder\n    startViewAnimation(builder).then((animation) => {\n        builder.notifyReady(animation)\n        animation.finished.finally(next)\n    })\n}\n\nfunction processQueue() {\n    /**\n     * Iterate backwards over the builders array. We can ignore the\n     * \"wait\" animations. If we have an interrupting animation in the\n     * queue then we need to batch all preceeding animations into it.\n     * Currently this only batches the update functions but will also\n     * need to batch the targets.\n     */\n    for (let i = builders.length - 1; i >= 0; i--) {\n        const builder = builders[i]\n        const { interrupt } = builder.options\n\n        if (interrupt === \"immediate\") {\n            const batchedUpdates = builders.slice(0, i + 1).map((b) => b.update)\n            const remaining = builders.slice(i + 1)\n\n            builder.update = () => {\n                batchedUpdates.forEach((update) => update())\n            }\n\n            // Put the current builder at the front, followed by any \"wait\" builders\n            builders = [builder, ...remaining]\n\n            break\n        }\n    }\n\n    if (!current || builders[0]?.options.interrupt === \"immediate\") {\n        next()\n    }\n}\n\nexport function addToQueue(builder: ViewTransitionBuilder) {\n    builders.push(builder)\n    microtask.render(processQueue)\n}\n"]},"metadata":{},"sourceType":"module"}