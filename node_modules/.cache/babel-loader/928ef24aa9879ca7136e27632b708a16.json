{"ast":null,"code":"import { frame, isPrimaryPointer, cancelFrame, frameData } from 'motion-dom';\nimport { pipe, secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\nconst overflowStyles = /*#__PURE__*/new Set([\"auto\", \"scroll\"]);\n/**\n * @internal\n */\n\nclass PanSession {\n  constructor(event, handlers) {\n    let {\n      transformPagePoint,\n      contextWindow = window,\n      dragSnapToOrigin = false,\n      distanceThreshold = 3,\n      element\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    /**\n     * @internal\n     */\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n\n    this.handlers = {};\n    /**\n     * @internal\n     */\n\n    this.contextWindow = window;\n    /**\n     * Scroll positions of scrollable ancestors and window.\n     * @internal\n     */\n\n    this.scrollPositions = new Map();\n    /**\n     * Cleanup function for scroll listeners.\n     * @internal\n     */\n\n    this.removeScrollListeners = null;\n\n    this.onElementScroll = event => {\n      this.handleScroll(event.target);\n    };\n\n    this.onWindowScroll = () => {\n      this.handleScroll(window);\n    };\n\n    this.updatePoint = () => {\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n      const info = getPanInfo(this.lastMoveEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null; // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursor.\n\n      const isDistancePastThreshold = distance2D(info.offset, {\n        x: 0,\n        y: 0\n      }) >= this.distanceThreshold;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      const {\n        point\n      } = info;\n      const {\n        timestamp\n      } = frameData;\n      this.history.push({ ...point,\n        timestamp\n      });\n      const {\n        onStart,\n        onMove\n      } = this.handlers;\n\n      if (!isPanStarted) {\n        onStart && onStart(this.lastMoveEvent, info);\n        this.startEvent = this.lastMoveEvent;\n      }\n\n      onMove && onMove(this.lastMoveEvent, info);\n    };\n\n    this.handlePointerMove = (event, info) => {\n      this.lastMoveEvent = event;\n      this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint); // Throttle mouse move event to once per frame\n\n      frame.update(this.updatePoint, true);\n    };\n\n    this.handlePointerUp = (event, info) => {\n      this.end();\n      const {\n        onEnd,\n        onSessionEnd,\n        resumeAnimation\n      } = this.handlers; // Resume animation if dragSnapToOrigin is set OR if no drag started (user just clicked)\n      // This ensures constraint animations continue when interrupted by a click\n\n      if (this.dragSnapToOrigin || !this.startEvent) {\n        resumeAnimation && resumeAnimation();\n      }\n\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n      const panInfo = getPanInfo(event.type === \"pointercancel\" ? this.lastMoveEventInfo : transformPoint(info, this.transformPagePoint), this.history);\n\n      if (this.startEvent && onEnd) {\n        onEnd(event, panInfo);\n      }\n\n      onSessionEnd && onSessionEnd(event, panInfo);\n    }; // If we have more than one touch, don't start detecting this gesture\n\n\n    if (!isPrimaryPointer(event)) return;\n    this.dragSnapToOrigin = dragSnapToOrigin;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    this.distanceThreshold = distanceThreshold;\n    this.contextWindow = contextWindow || window;\n    const info = extractEventInfo(event);\n    const initialInfo = transformPoint(info, this.transformPagePoint);\n    const {\n      point\n    } = initialInfo;\n    const {\n      timestamp\n    } = frameData;\n    this.history = [{ ...point,\n      timestamp\n    }];\n    const {\n      onSessionStart\n    } = handlers;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp)); // Start scroll tracking if element provided\n\n    if (element) {\n      this.startScrollTracking(element);\n    }\n  }\n  /**\n   * Start tracking scroll on ancestors and window.\n   */\n\n\n  startScrollTracking(element) {\n    // Store initial scroll positions for scrollable ancestors\n    let current = element.parentElement;\n\n    while (current) {\n      const style = getComputedStyle(current);\n\n      if (overflowStyles.has(style.overflowX) || overflowStyles.has(style.overflowY)) {\n        this.scrollPositions.set(current, {\n          x: current.scrollLeft,\n          y: current.scrollTop\n        });\n      }\n\n      current = current.parentElement;\n    } // Track window scroll\n\n\n    this.scrollPositions.set(window, {\n      x: window.scrollX,\n      y: window.scrollY\n    }); // Capture listener catches element scroll events as they bubble\n\n    window.addEventListener(\"scroll\", this.onElementScroll, {\n      capture: true\n    }); // Direct window scroll listener (window scroll doesn't bubble)\n\n    window.addEventListener(\"scroll\", this.onWindowScroll);\n\n    this.removeScrollListeners = () => {\n      window.removeEventListener(\"scroll\", this.onElementScroll, {\n        capture: true\n      });\n      window.removeEventListener(\"scroll\", this.onWindowScroll);\n    };\n  }\n  /**\n   * Handle scroll compensation during drag.\n   *\n   * For element scroll: adjusts history origin since pageX/pageY doesn't change.\n   * For window scroll: adjusts lastMoveEventInfo since pageX/pageY would change.\n   */\n\n\n  handleScroll(target) {\n    const initial = this.scrollPositions.get(target);\n    if (!initial) return;\n    const isWindow = target === window;\n    const current = isWindow ? {\n      x: window.scrollX,\n      y: window.scrollY\n    } : {\n      x: target.scrollLeft,\n      y: target.scrollTop\n    };\n    const delta = {\n      x: current.x - initial.x,\n      y: current.y - initial.y\n    };\n    if (delta.x === 0 && delta.y === 0) return;\n\n    if (isWindow) {\n      // Window scroll: pageX/pageY changes, so update lastMoveEventInfo\n      if (this.lastMoveEventInfo) {\n        this.lastMoveEventInfo.point.x += delta.x;\n        this.lastMoveEventInfo.point.y += delta.y;\n      }\n    } else {\n      // Element scroll: pageX/pageY unchanged, so adjust history origin\n      if (this.history.length > 0) {\n        this.history[0].x -= delta.x;\n        this.history[0].y -= delta.y;\n      }\n    }\n\n    this.scrollPositions.set(target, current);\n    frame.update(this.updatePoint, true);\n  }\n\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n\n  end() {\n    this.removeListeners && this.removeListeners();\n    this.removeScrollListeners && this.removeScrollListeners();\n    this.scrollPositions.clear();\n    cancelFrame(this.updatePoint);\n  }\n\n}\n\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\n\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\n\nfunction getPanInfo(_ref, history) {\n  let {\n    point\n  } = _ref;\n  return {\n    point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\n\nfunction startDevicePoint(history) {\n  return history[0];\n}\n\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\n\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  /**\n   * If the selected point is the pointer-down origin (history[0]),\n   * there are better movement points available, and the time gap\n   * is suspiciously large (>2x timeDelta), use the next point instead.\n   * This prevents stale pointer-down points from diluting velocity\n   * in hold-then-flick gestures.\n   */\n\n\n  if (timestampedPoint === history[0] && history.length > 2 && lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta) * 2) {\n    timestampedPoint = history[1];\n  }\n\n  const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}\n\nexport { PanSession };","map":{"version":3,"mappings":"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","names":["overflowStyles","Set","PanSession","constructor","handlers","transformPagePoint","contextWindow","window","dragSnapToOrigin","distanceThreshold","element","startEvent","lastMoveEvent","lastMoveEventInfo","Map","removeScrollListeners","event","handleScroll","target","onWindowScroll","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","distance2D","offset","x","y","point","timestamp","frameData","push","onStart","onMove","transformPoint","frame","update","end","onEnd","onSessionEnd","resumeAnimation","panInfo","type","isPrimaryPointer","extractEventInfo","initialInfo","onSessionStart","removeListeners","pipe","addPointerEvent","handlePointerMove","handlePointerUp","startScrollTracking","current","parentElement","style","getComputedStyle","has","overflowX","overflowY","scrollPositions","set","scrollLeft","scrollTop","scrollX","scrollY","addEventListener","onElementScroll","capture","removeEventListener","initial","get","isWindow","delta","length","updateHandlers","clear","cancelFrame","subtractPoint","a","b","lastDevicePoint","startDevicePoint","velocity","getVelocity","timeDelta","i","timestampedPoint","lastPoint","secondsToMilliseconds","time","millisecondsToSeconds","currentVelocity","Infinity"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\gestures\\pan\\PanSession.ts"],"sourcesContent":["import type { EventInfo, PanHandler } from \"motion-dom\"\nimport { cancelFrame, frame, frameData, isPrimaryPointer } from \"motion-dom\"\nimport {\n    millisecondsToSeconds,\n    pipe,\n    Point,\n    secondsToMilliseconds,\n    TransformPoint,\n} from \"motion-utils\"\nimport { addPointerEvent } from \"../../events/add-pointer-event\"\nimport { extractEventInfo } from \"../../events/event-info\"\nimport { distance2D } from \"../../utils/distance\"\n\ninterface PanSessionHandlers {\n    onSessionStart: PanHandler\n    onStart: PanHandler\n    onMove: PanHandler\n    onEnd: PanHandler\n    onSessionEnd: PanHandler\n    resumeAnimation: () => void\n}\n\ninterface PanSessionOptions {\n    transformPagePoint?: TransformPoint\n    dragSnapToOrigin?: boolean\n    distanceThreshold?: number\n    contextWindow?: (Window & typeof globalThis) | null\n    /**\n     * Element being dragged. When provided, scroll events on its\n     * ancestors and window are compensated so the gesture continues\n     * smoothly during scroll.\n     */\n    element?: HTMLElement | null\n}\n\ninterface TimestampedPoint extends Point {\n    timestamp: number\n}\n\nconst overflowStyles = /*#__PURE__*/ new Set([\"auto\", \"scroll\"])\n\n/**\n * @internal\n */\nexport class PanSession {\n    /**\n     * @internal\n     */\n    private history: TimestampedPoint[]\n\n    /**\n     * @internal\n     */\n    private startEvent: PointerEvent | null = null\n\n    /**\n     * @internal\n     */\n    private lastMoveEvent: PointerEvent | null = null\n\n    /**\n     * @internal\n     */\n    private lastMoveEventInfo: EventInfo | null = null\n\n    /**\n     * @internal\n     */\n    private transformPagePoint?: TransformPoint\n\n    /**\n     * @internal\n     */\n    private handlers: Partial<PanSessionHandlers> = {}\n\n    /**\n     * @internal\n     */\n    private removeListeners: Function\n\n    /**\n     * For determining if an animation should resume after it is interupted\n     *\n     * @internal\n     */\n    private dragSnapToOrigin: boolean\n\n    /**\n     * The distance after which panning should start.\n     *\n     * @internal\n     */\n    private distanceThreshold: number\n\n    /**\n     * @internal\n     */\n    private contextWindow: PanSessionOptions[\"contextWindow\"] = window\n\n    /**\n     * Scroll positions of scrollable ancestors and window.\n     * @internal\n     */\n    private scrollPositions: Map<Element | Window, Point> = new Map()\n\n    /**\n     * Cleanup function for scroll listeners.\n     * @internal\n     */\n    private removeScrollListeners: (() => void) | null = null\n\n    constructor(\n        event: PointerEvent,\n        handlers: Partial<PanSessionHandlers>,\n        {\n            transformPagePoint,\n            contextWindow = window,\n            dragSnapToOrigin = false,\n            distanceThreshold = 3,\n            element,\n        }: PanSessionOptions = {}\n    ) {\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event)) return\n\n        this.dragSnapToOrigin = dragSnapToOrigin\n        this.handlers = handlers\n        this.transformPagePoint = transformPagePoint\n        this.distanceThreshold = distanceThreshold\n        this.contextWindow = contextWindow || window\n\n        const info = extractEventInfo(event)\n        const initialInfo = transformPoint(info, this.transformPagePoint)\n        const { point } = initialInfo\n\n        const { timestamp } = frameData\n\n        this.history = [{ ...point, timestamp }]\n\n        const { onSessionStart } = handlers\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history))\n\n        this.removeListeners = pipe(\n            addPointerEvent(\n                this.contextWindow,\n                \"pointermove\",\n                this.handlePointerMove\n            ),\n            addPointerEvent(\n                this.contextWindow,\n                \"pointerup\",\n                this.handlePointerUp\n            ),\n            addPointerEvent(\n                this.contextWindow,\n                \"pointercancel\",\n                this.handlePointerUp\n            )\n        )\n\n        // Start scroll tracking if element provided\n        if (element) {\n            this.startScrollTracking(element)\n        }\n    }\n\n    /**\n     * Start tracking scroll on ancestors and window.\n     */\n    private startScrollTracking(element: HTMLElement): void {\n        // Store initial scroll positions for scrollable ancestors\n        let current = element.parentElement\n        while (current) {\n            const style = getComputedStyle(current)\n            if (\n                overflowStyles.has(style.overflowX) ||\n                overflowStyles.has(style.overflowY)\n            ) {\n                this.scrollPositions.set(current, {\n                    x: current.scrollLeft,\n                    y: current.scrollTop,\n                })\n            }\n            current = current.parentElement\n        }\n\n        // Track window scroll\n        this.scrollPositions.set(window, {\n            x: window.scrollX,\n            y: window.scrollY,\n        })\n\n        // Capture listener catches element scroll events as they bubble\n        window.addEventListener(\"scroll\", this.onElementScroll, {\n            capture: true,\n        })\n\n        // Direct window scroll listener (window scroll doesn't bubble)\n        window.addEventListener(\"scroll\", this.onWindowScroll)\n\n        this.removeScrollListeners = () => {\n            window.removeEventListener(\"scroll\", this.onElementScroll, {\n                capture: true,\n            })\n            window.removeEventListener(\"scroll\", this.onWindowScroll)\n        }\n    }\n\n    private onElementScroll = (event: Event): void => {\n        this.handleScroll(event.target as Element)\n    }\n\n    private onWindowScroll = (): void => {\n        this.handleScroll(window)\n    }\n\n    /**\n     * Handle scroll compensation during drag.\n     *\n     * For element scroll: adjusts history origin since pageX/pageY doesn't change.\n     * For window scroll: adjusts lastMoveEventInfo since pageX/pageY would change.\n     */\n    private handleScroll(target: Element | Window): void {\n        const initial = this.scrollPositions.get(target)\n        if (!initial) return\n\n        const isWindow = target === window\n        const current = isWindow\n            ? { x: window.scrollX, y: window.scrollY }\n            : {\n                  x: (target as Element).scrollLeft,\n                  y: (target as Element).scrollTop,\n              }\n\n        const delta = { x: current.x - initial.x, y: current.y - initial.y }\n        if (delta.x === 0 && delta.y === 0) return\n\n        if (isWindow) {\n            // Window scroll: pageX/pageY changes, so update lastMoveEventInfo\n            if (this.lastMoveEventInfo) {\n                this.lastMoveEventInfo.point.x += delta.x\n                this.lastMoveEventInfo.point.y += delta.y\n            }\n        } else {\n            // Element scroll: pageX/pageY unchanged, so adjust history origin\n            if (this.history.length > 0) {\n                this.history[0].x -= delta.x\n                this.history[0].y -= delta.y\n            }\n        }\n\n        this.scrollPositions.set(target, current)\n        frame.update(this.updatePoint, true)\n    }\n\n    private updatePoint = () => {\n        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return\n\n        const info = getPanInfo(this.lastMoveEventInfo, this.history)\n        const isPanStarted = this.startEvent !== null\n\n        // Only start panning if the offset is larger than 3 pixels. If we make it\n        // any larger than this we'll want to reset the pointer history\n        // on the first update to avoid visual snapping to the cursor.\n        const isDistancePastThreshold =\n            distance2D(info.offset, { x: 0, y: 0 }) >= this.distanceThreshold\n\n        if (!isPanStarted && !isDistancePastThreshold) return\n\n        const { point } = info\n        const { timestamp } = frameData\n        this.history.push({ ...point, timestamp })\n\n        const { onStart, onMove } = this.handlers\n\n        if (!isPanStarted) {\n            onStart && onStart(this.lastMoveEvent, info)\n            this.startEvent = this.lastMoveEvent\n        }\n\n        onMove && onMove(this.lastMoveEvent, info)\n    }\n\n    private handlePointerMove = (event: PointerEvent, info: EventInfo) => {\n        this.lastMoveEvent = event\n        this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint)\n\n        // Throttle mouse move event to once per frame\n        frame.update(this.updatePoint, true)\n    }\n\n    private handlePointerUp = (event: PointerEvent, info: EventInfo) => {\n        this.end()\n\n        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers\n\n        // Resume animation if dragSnapToOrigin is set OR if no drag started (user just clicked)\n        // This ensures constraint animations continue when interrupted by a click\n        if (this.dragSnapToOrigin || !this.startEvent) {\n            resumeAnimation && resumeAnimation()\n        }\n        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return\n\n        const panInfo = getPanInfo(\n            event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint),\n            this.history\n        )\n\n        if (this.startEvent && onEnd) {\n            onEnd(event, panInfo)\n        }\n\n        onSessionEnd && onSessionEnd(event, panInfo)\n    }\n\n    updateHandlers(handlers: Partial<PanSessionHandlers>) {\n        this.handlers = handlers\n    }\n\n    end() {\n        this.removeListeners && this.removeListeners()\n        this.removeScrollListeners && this.removeScrollListeners()\n        this.scrollPositions.clear()\n        cancelFrame(this.updatePoint)\n    }\n}\n\nfunction transformPoint(\n    info: EventInfo,\n    transformPagePoint?: (point: Point) => Point\n) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info\n}\n\nfunction subtractPoint(a: Point, b: Point): Point {\n    return { x: a.x - b.x, y: a.y - b.y }\n}\n\nfunction getPanInfo({ point }: EventInfo, history: TimestampedPoint[]) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    }\n}\n\nfunction startDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n    return history[0]\n}\n\nfunction lastDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n    return history[history.length - 1]\n}\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n    if (history.length < 2) {\n        return { x: 0, y: 0 }\n    }\n\n    let i = history.length - 1\n    let timestampedPoint: TimestampedPoint | null = null\n    const lastPoint = lastDevicePoint(history)\n    while (i >= 0) {\n        timestampedPoint = history[i]\n        if (\n            lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)\n        ) {\n            break\n        }\n        i--\n    }\n\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 }\n    }\n\n    /**\n     * If the selected point is the pointer-down origin (history[0]),\n     * there are better movement points available, and the time gap\n     * is suspiciously large (>2x timeDelta), use the next point instead.\n     * This prevents stale pointer-down points from diluting velocity\n     * in hold-then-flick gestures.\n     */\n    if (\n        timestampedPoint === history[0] &&\n        history.length > 2 &&\n        lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta) * 2\n    ) {\n        timestampedPoint = history[1]\n    }\n\n    const time = millisecondsToSeconds(\n        lastPoint.timestamp - timestampedPoint.timestamp\n    )\n    if (time === 0) {\n        return { x: 0, y: 0 }\n    }\n\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    }\n\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0\n    }\n\n    return currentVelocity\n}\n"]},"metadata":{},"sourceType":"module"}