{"ast":null,"code":"import { pipe, warning } from 'motion-utils';\nimport { isCSSVariableToken } from '../../animation/utils/is-css-variable.mjs';\nimport { color } from '../../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\nimport { mixColor } from './color.mjs';\nimport { mixImmediate } from './immediate.mjs';\nimport { mixNumber as mixNumber$1 } from './number.mjs';\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\n\nfunction mixNumber(a, b) {\n  return p => mixNumber$1(a, b, p);\n}\n\nfunction getMixer(a) {\n  if (typeof a === \"number\") {\n    return mixNumber;\n  } else if (typeof a === \"string\") {\n    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;\n  } else if (Array.isArray(a)) {\n    return mixArray;\n  } else if (typeof a === \"object\") {\n    return color.test(a) ? mixColor : mixObject;\n  }\n\n  return mixImmediate;\n}\n\nfunction mixArray(a, b) {\n  const output = [...a];\n  const numValues = output.length;\n  const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n  return p => {\n    for (let i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](p);\n    }\n\n    return output;\n  };\n}\n\nfunction mixObject(a, b) {\n  const output = { ...a,\n    ...b\n  };\n  const blendValue = {};\n\n  for (const key in output) {\n    if (a[key] !== undefined && b[key] !== undefined) {\n      blendValue[key] = getMixer(a[key])(a[key], b[key]);\n    }\n  }\n\n  return v => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n\n    return output;\n  };\n}\n\nfunction matchOrder(origin, target) {\n  const orderedOrigin = [];\n  const pointers = {\n    color: 0,\n    var: 0,\n    number: 0\n  };\n\n  for (let i = 0; i < target.values.length; i++) {\n    const type = target.types[i];\n    const originIndex = origin.indexes[type][pointers[type]];\n    const originValue = origin.values[originIndex] ?? 0;\n    orderedOrigin[i] = originValue;\n    pointers[type]++;\n  }\n\n  return orderedOrigin;\n}\n\nconst mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyseComplexValue(origin);\n  const targetStats = analyseComplexValue(target);\n  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;\n\n  if (canInterpolate) {\n    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {\n      return mixVisibility(origin, target);\n    }\n\n    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n  } else {\n    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, \"complex-values-different\");\n    return mixImmediate(origin, target);\n  }\n};\n\nexport { getMixer, mixArray, mixComplex, mixObject };","map":{"version":3,"mappings":"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","names":["mixNumber","a","b","p","mixNumberImmediate","getMixer","isCSSVariableToken","mixImmediate","color","test","mixColor","mixComplex","Array","isArray","mixArray","mixObject","output","numValues","length","blendValue","map","v","i","key","undefined","matchOrder","origin","target","orderedOrigin","pointers","var","number","values","type","types","originIndex","indexes","originValue","template","complex","createTransformer","originStats","analyseComplexValue","targetStats","canInterpolate","invisibleValues","has","mixVisibility","pipe","warning"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\utils\\mix\\complex.ts"],"sourcesContent":["import { pipe, warning } from \"motion-utils\"\nimport { AnyResolvedKeyframe } from \"../../animation/types\"\nimport { isCSSVariableToken } from \"../../animation/utils/is-css-variable\"\nimport { color } from \"../../value/types/color\"\nimport {\n    analyseComplexValue,\n    complex,\n    ComplexValueInfo,\n    ComplexValues,\n} from \"../../value/types/complex\"\nimport { HSLA, RGBA } from \"../../value/types/types\"\nimport { mixColor } from \"./color\"\nimport { mixImmediate } from \"./immediate\"\nimport { mixNumber as mixNumberImmediate } from \"./number\"\nimport { invisibleValues, mixVisibility } from \"./visibility\"\n\ntype MixableArray = Array<number | RGBA | HSLA | string>\ninterface MixableObject {\n    [key: string]: AnyResolvedKeyframe | RGBA | HSLA\n}\n\nfunction mixNumber(a: number, b: number) {\n    return (p: number) => mixNumberImmediate(a, b, p)\n}\n\nexport function getMixer<T>(a: T) {\n    if (typeof a === \"number\") {\n        return mixNumber\n    } else if (typeof a === \"string\") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n            ? mixColor\n            : mixComplex\n    } else if (Array.isArray(a)) {\n        return mixArray\n    } else if (typeof a === \"object\") {\n        return color.test(a) ? mixColor : mixObject\n    }\n\n    return mixImmediate\n}\n\nexport function mixArray(a: MixableArray, b: MixableArray) {\n    const output = [...a]\n    const numValues = output.length\n\n    const blendValue = a.map((v, i) => getMixer(v)(v as any, b[i] as any))\n\n    return (p: number) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p) as any\n        }\n        return output\n    }\n}\n\nexport function mixObject(a: MixableObject, b: MixableObject) {\n    const output = { ...a, ...b }\n    const blendValue: { [key: string]: (v: number) => any } = {}\n\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(\n                a[key] as any,\n                b[key] as any\n            ) as any\n        }\n    }\n\n    return (v: number) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v)\n        }\n        return output\n    }\n}\n\nfunction matchOrder(\n    origin: ComplexValueInfo,\n    target: ComplexValueInfo\n): ComplexValues {\n    const orderedOrigin: ComplexValues = []\n\n    const pointers = { color: 0, var: 0, number: 0 }\n\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i]\n        const originIndex = origin.indexes[type][pointers[type]]\n        const originValue = origin.values[originIndex] ?? 0\n\n        orderedOrigin[i] = originValue\n\n        pointers[type]++\n    }\n\n    return orderedOrigin\n}\n\nexport const mixComplex = (\n    origin: AnyResolvedKeyframe,\n    target: AnyResolvedKeyframe\n) => {\n    const template = complex.createTransformer(target)\n    const originStats = analyseComplexValue(origin)\n    const targetStats = analyseComplexValue(target)\n    const canInterpolate =\n        originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length\n\n    if (canInterpolate) {\n        if (\n            (invisibleValues.has(origin as string) &&\n                !targetStats.values.length) ||\n            (invisibleValues.has(target as string) &&\n                !originStats.values.length)\n        ) {\n            return mixVisibility(origin as string, target as string)\n        }\n\n        return pipe(\n            mixArray(matchOrder(originStats, targetStats), targetStats.values),\n            template\n        )\n    } else {\n        warning(\n            true,\n            `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`,\n            \"complex-values-different\"\n        )\n\n        return mixImmediate(origin, target)\n    }\n}\n"]},"metadata":{},"sourceType":"module"}