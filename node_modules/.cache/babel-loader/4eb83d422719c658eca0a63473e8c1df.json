{"ast":null,"code":"/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */\nfunction calcNextTime(current, next, prev, labels) {\n  if (typeof next === \"number\") {\n    return next;\n  } else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n    return Math.max(0, current + parseFloat(next));\n  } else if (next === \"<\") {\n    return prev;\n  } else if (next.startsWith(\"<\")) {\n    return Math.max(0, prev + parseFloat(next.slice(1)));\n  } else {\n    return labels.get(next) ?? current;\n  }\n}\n\nexport { calcNextTime };","map":{"version":3,"mappings":"AAEA;;;AAGG;AACG,SAAUA,YAAV,CACFC,OADE,EAEFC,IAFE,EAGFC,IAHE,EAIFC,MAJE,EAIyB;EAE3B,IAAI,OAAOF,IAAP,KAAgB,QAApB,EAA8B;IAC1B,OAAOA,IAAP;EACH,CAFD,MAEO,IAAIA,IAAI,CAACG,UAAL,CAAgB,GAAhB,KAAwBH,IAAI,CAACG,UAAL,CAAgB,GAAhB,CAA5B,EAAkD;IACrD,OAAOC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYN,OAAO,GAAGO,UAAU,CAACN,IAAD,CAAhC,CAAP;EACH,CAFM,MAEA,IAAIA,IAAI,KAAK,GAAb,EAAkB;IACrB,OAAOC,IAAP;EACH,CAFM,MAEA,IAAID,IAAI,CAACG,UAAL,CAAgB,GAAhB,CAAJ,EAA0B;IAC7B,OAAOC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYJ,IAAI,GAAGK,UAAU,CAACN,IAAI,CAACO,KAAL,CAAW,CAAX,CAAD,CAA7B,CAAP;EACH,CAFM,MAEA;IACH,OAAOL,MAAM,CAACM,GAAP,CAAWR,IAAX,KAAoBD,OAA3B;EACH;AACL","names":["calcNextTime","current","next","prev","labels","startsWith","Math","max","parseFloat","slice","get"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\animation\\sequence\\utils\\calc-time.ts"],"sourcesContent":["import { SequenceTime } from \"../types\"\n\n/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */\nexport function calcNextTime(\n    current: number,\n    next: SequenceTime,\n    prev: number,\n    labels: Map<string, number>\n): number {\n    if (typeof next === \"number\") {\n        return next\n    } else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next))\n    } else if (next === \"<\") {\n        return prev\n    } else if (next.startsWith(\"<\")) {\n        return Math.max(0, prev + parseFloat(next.slice(1)))\n    } else {\n        return labels.get(next) ?? current\n    }\n}\n"]},"metadata":{},"sourceType":"module"}