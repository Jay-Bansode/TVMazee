{"ast":null,"code":"import { mixNumber } from '../../utils/mix/number.mjs';\nimport { percent, px } from '../../value/types/numbers/units.mjs';\nimport { progress, circOut, noop } from 'motion-utils';\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nconst numBorders = borders.length;\n\nconst asNumber = value => typeof value === \"string\" ? parseFloat(value) : value;\n\nconst isPx = value => typeof value === \"number\" || px.test(value);\n\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n  if (shouldCrossfadeOpacity) {\n    target.opacity = mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress));\n    target.opacityExit = mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress));\n  } else if (isOnlyMember) {\n    target.opacity = mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress);\n  }\n  /**\n   * Mix border radius\n   */\n\n\n  for (let i = 0; i < numBorders; i++) {\n    const borderLabel = `border${borders[i]}Radius`;\n    let followRadius = getRadius(follow, borderLabel);\n    let leadRadius = getRadius(lead, borderLabel);\n    if (followRadius === undefined && leadRadius === undefined) continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n\n    if (canMix) {\n      target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n\n      if (percent.test(leadRadius) || percent.test(followRadius)) {\n        target[borderLabel] += \"%\";\n      }\n    } else {\n      target[borderLabel] = leadRadius;\n    }\n  }\n  /**\n   * Mix rotation\n   */\n\n\n  if (follow.rotate || lead.rotate) {\n    target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);\n  }\n}\n\nfunction getRadius(values, radiusName) {\n  return values[radiusName] !== undefined ? values[radiusName] : values.borderRadius;\n}\n\nconst easeCrossfadeIn = /*@__PURE__*/compress(0, 0.5, circOut);\nconst easeCrossfadeOut = /*@__PURE__*/compress(0.5, 0.95, noop);\n\nfunction compress(min, max, easing) {\n  return p => {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\n\nexport { mixValues };","map":{"version":3,"mappings":"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","names":["borders","numBorders","length","asNumber","value","parseFloat","isPx","px","test","target","follow","lead","progress","shouldCrossfadeOpacity","isOnlyMember","opacity","mixNumber","easeCrossfadeIn","opacityExit","easeCrossfadeOut","i","borderLabel","followRadius","getRadius","leadRadius","undefined","canMix","Math","max","percent","rotate","values","radiusName","borderRadius","compress","circOut","noop","min","easing","p","calcProgress"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\projection\\animation\\mix-values.ts"],"sourcesContent":["import { mixNumber } from \"../../utils/mix/number\"\nimport { percent, px } from \"../../value/types/numbers/units\"\nimport type { AnyResolvedKeyframe } from \"../../animation/types\"\nimport {\n    progress as calcProgress,\n    circOut,\n    EasingFunction,\n    noop,\n} from \"motion-utils\"\nimport type { ResolvedValues } from \"../../node/types\"\n\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"]\nconst numBorders = borders.length\n\nconst asNumber = (value: AnyResolvedKeyframe) =>\n    typeof value === \"string\" ? parseFloat(value) : value\n\nconst isPx = (value: AnyResolvedKeyframe) =>\n    typeof value === \"number\" || px.test(value)\n\nexport function mixValues(\n    target: ResolvedValues,\n    follow: ResolvedValues,\n    lead: ResolvedValues,\n    progress: number,\n    shouldCrossfadeOpacity: boolean,\n    isOnlyMember: boolean\n) {\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mixNumber(\n            0,\n            (lead.opacity as number) ?? 1,\n            easeCrossfadeIn(progress)\n        )\n        target.opacityExit = mixNumber(\n            (follow.opacity as number) ?? 1,\n            0,\n            easeCrossfadeOut(progress)\n        )\n    } else if (isOnlyMember) {\n        target.opacity = mixNumber(\n            (follow.opacity as number) ?? 1,\n            (lead.opacity as number) ?? 1,\n            progress\n        )\n    }\n\n    /**\n     * Mix border radius\n     */\n    for (let i = 0; i < numBorders; i++) {\n        const borderLabel = `border${borders[i]}Radius`\n        let followRadius = getRadius(follow, borderLabel)\n        let leadRadius = getRadius(lead, borderLabel)\n\n        if (followRadius === undefined && leadRadius === undefined) continue\n\n        followRadius ||= 0\n        leadRadius ||= 0\n\n        const canMix =\n            followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius)\n\n        if (canMix) {\n            target[borderLabel] = Math.max(\n                mixNumber(\n                    asNumber(followRadius),\n                    asNumber(leadRadius),\n                    progress\n                ),\n                0\n            )\n\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += \"%\"\n            }\n        } else {\n            target[borderLabel] = leadRadius\n        }\n    }\n\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mixNumber(\n            (follow.rotate as number) || 0,\n            (lead.rotate as number) || 0,\n            progress\n        )\n    }\n}\n\nfunction getRadius(values: ResolvedValues, radiusName: string) {\n    return values[radiusName] !== undefined\n        ? values[radiusName]\n        : values.borderRadius\n}\n\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut)\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop)\n\nfunction compress(\n    min: number,\n    max: number,\n    easing: EasingFunction\n): EasingFunction {\n    return (p: number) => {\n        // Could replace ifs with clamp\n        if (p < min) return 0\n        if (p > max) return 1\n        return easing(calcProgress(min, max, p))\n    }\n}\n"]},"metadata":{},"sourceType":"module"}