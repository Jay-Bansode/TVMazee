{"ast":null,"code":"import { motionValue } from './index.mjs';\nimport { JSAnimation } from '../animation/JSAnimation.mjs';\nimport { isMotionValue } from './utils/is-motion-value.mjs';\nimport { frame } from '../frameloop/frame.mjs';\n/**\n * Create a `MotionValue` that animates to its latest value using any transition type.\n * Can either be a value or track another `MotionValue`.\n *\n * ```jsx\n * const x = motionValue(0)\n * const y = followValue(x, { type: \"spring\", stiffness: 300 })\n * // or with tween\n * const z = followValue(x, { type: \"tween\", duration: 0.5, ease: \"easeOut\" })\n * ```\n *\n * @param source - Initial value or MotionValue to track\n * @param options - Animation transition options\n * @returns `MotionValue`\n *\n * @public\n */\n\nfunction followValue(source, options) {\n  const initialValue = isMotionValue(source) ? source.get() : source;\n  const value = motionValue(initialValue);\n  attachFollow(value, source, options);\n  return value;\n}\n/**\n * Attach an animation to a MotionValue that will animate whenever the value changes.\n * Similar to attachSpring but supports any transition type (spring, tween, inertia, etc.)\n *\n * @param value - The MotionValue to animate\n * @param source - Initial value or MotionValue to track\n * @param options - Animation transition options\n * @returns Cleanup function\n *\n * @public\n */\n\n\nfunction attachFollow(value, source) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const initialValue = value.get();\n  let activeAnimation = null;\n  let latestValue = initialValue;\n  let latestSetter;\n  const unit = typeof initialValue === \"string\" ? initialValue.replace(/[\\d.-]/g, \"\") : undefined;\n\n  const stopAnimation = () => {\n    if (activeAnimation) {\n      activeAnimation.stop();\n      activeAnimation = null;\n    }\n  };\n\n  const startAnimation = () => {\n    stopAnimation();\n    const currentValue = asNumber(value.get());\n    const targetValue = asNumber(latestValue); // Don't animate if we're already at the target\n\n    if (currentValue === targetValue) {\n      return;\n    }\n\n    activeAnimation = new JSAnimation({\n      keyframes: [currentValue, targetValue],\n      velocity: value.getVelocity(),\n      // Default to spring if no type specified (matches useSpring behavior)\n      type: \"spring\",\n      restDelta: 0.001,\n      restSpeed: 0.01,\n      ...options,\n      onUpdate: latestSetter\n    });\n  };\n\n  value.attach((v, set) => {\n    latestValue = v;\n\n    latestSetter = latest => set(parseValue(latest, unit));\n\n    frame.postRender(() => {\n      startAnimation();\n      value[\"events\"].animationStart?.notify();\n      activeAnimation?.then(() => {\n        value[\"events\"].animationComplete?.notify();\n      });\n    });\n  }, stopAnimation);\n\n  if (isMotionValue(source)) {\n    const removeSourceOnChange = source.on(\"change\", v => value.set(parseValue(v, unit)));\n    const removeValueOnDestroy = value.on(\"destroy\", removeSourceOnChange);\n    return () => {\n      removeSourceOnChange();\n      removeValueOnDestroy();\n    };\n  }\n\n  return stopAnimation;\n}\n\nfunction parseValue(v, unit) {\n  return unit ? v + unit : v;\n}\n\nfunction asNumber(v) {\n  return typeof v === \"number\" ? v : parseFloat(v);\n}\n\nexport { attachFollow, followValue };","map":{"version":3,"mappings":"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","names":["source","options","initialValue","isMotionValue","get","value","motionValue","attachFollow","activeAnimation","latestValue","latestSetter","unit","replace","undefined","stopAnimation","stop","startAnimation","currentValue","asNumber","targetValue","JSAnimation","keyframes","velocity","getVelocity","type","restDelta","restSpeed","onUpdate","attach","v","set","latest","parseValue","frame","postRender","animationStart","notify","then","animationComplete","removeSourceOnChange","on","removeValueOnDestroy","parseFloat"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\value\\follow-value.ts"],"sourcesContent":["import { MotionValue, motionValue } from \".\"\nimport { JSAnimation } from \"../animation/JSAnimation\"\nimport { AnyResolvedKeyframe, ValueAnimationTransition } from \"../animation/types\"\nimport { frame } from \"../frameloop\"\nimport { isMotionValue } from \"./utils/is-motion-value\"\n\n/**\n * Options for useFollowValue hook, extending ValueAnimationTransition\n * but excluding lifecycle callbacks that don't make sense for the hook pattern.\n */\nexport type FollowValueOptions = Omit<\n    ValueAnimationTransition,\n    \"onUpdate\" | \"onComplete\" | \"onPlay\" | \"onRepeat\" | \"onStop\"\n>\n\n/**\n * Create a `MotionValue` that animates to its latest value using any transition type.\n * Can either be a value or track another `MotionValue`.\n *\n * ```jsx\n * const x = motionValue(0)\n * const y = followValue(x, { type: \"spring\", stiffness: 300 })\n * // or with tween\n * const z = followValue(x, { type: \"tween\", duration: 0.5, ease: \"easeOut\" })\n * ```\n *\n * @param source - Initial value or MotionValue to track\n * @param options - Animation transition options\n * @returns `MotionValue`\n *\n * @public\n */\nexport function followValue<T extends AnyResolvedKeyframe>(\n    source: T | MotionValue<T>,\n    options?: FollowValueOptions\n) {\n    const initialValue = isMotionValue(source) ? source.get() : source\n    const value = motionValue(initialValue)\n\n    attachFollow(value, source, options)\n\n    return value\n}\n\n/**\n * Attach an animation to a MotionValue that will animate whenever the value changes.\n * Similar to attachSpring but supports any transition type (spring, tween, inertia, etc.)\n *\n * @param value - The MotionValue to animate\n * @param source - Initial value or MotionValue to track\n * @param options - Animation transition options\n * @returns Cleanup function\n *\n * @public\n */\nexport function attachFollow<T extends AnyResolvedKeyframe>(\n    value: MotionValue<T>,\n    source: T | MotionValue<T>,\n    options: FollowValueOptions = {}\n): VoidFunction {\n    const initialValue = value.get()\n\n    let activeAnimation: JSAnimation<number> | null = null\n    let latestValue = initialValue\n    let latestSetter: (v: T) => void\n\n    const unit =\n        typeof initialValue === \"string\"\n            ? initialValue.replace(/[\\d.-]/g, \"\")\n            : undefined\n\n    const stopAnimation = () => {\n        if (activeAnimation) {\n            activeAnimation.stop()\n            activeAnimation = null\n        }\n    }\n\n    const startAnimation = () => {\n        stopAnimation()\n\n        const currentValue = asNumber(value.get())\n        const targetValue = asNumber(latestValue)\n\n        // Don't animate if we're already at the target\n        if (currentValue === targetValue) {\n            return\n        }\n\n        activeAnimation = new JSAnimation({\n            keyframes: [currentValue, targetValue],\n            velocity: value.getVelocity(),\n            // Default to spring if no type specified (matches useSpring behavior)\n            type: \"spring\",\n            restDelta: 0.001,\n            restSpeed: 0.01,\n            ...options,\n            onUpdate: latestSetter,\n        })\n    }\n\n    value.attach((v, set) => {\n        latestValue = v\n        latestSetter = (latest) => set(parseValue(latest, unit) as T)\n\n        frame.postRender(() => {\n            startAnimation()\n            value[\"events\"].animationStart?.notify()\n            activeAnimation?.then(() => {\n                value[\"events\"].animationComplete?.notify()\n            })\n        })\n    }, stopAnimation)\n\n    if (isMotionValue(source)) {\n        const removeSourceOnChange = source.on(\"change\", (v) =>\n            value.set(parseValue(v, unit) as T)\n        )\n\n        const removeValueOnDestroy = value.on(\"destroy\", removeSourceOnChange)\n\n        return () => {\n            removeSourceOnChange()\n            removeValueOnDestroy()\n        }\n    }\n\n    return stopAnimation\n}\n\nfunction parseValue(v: AnyResolvedKeyframe, unit?: string) {\n    return unit ? v + unit : v\n}\n\nfunction asNumber(v: AnyResolvedKeyframe) {\n    return typeof v === \"number\" ? v : parseFloat(v)\n}\n"]},"metadata":{},"sourceType":"module"}