{"ast":null,"code":"import { resolveElements, getValueTransition, getAnimationMap, animationMapKey, getComputedStyle, fillWildcards, applyPxDefaults, NativeAnimation } from 'motion-dom';\nimport { invariant, secondsToMilliseconds } from 'motion-utils';\n\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n  // Gracefully handle null/undefined elements (e.g., from querySelector returning null)\n  if (elementOrSelector == null) {\n    return [];\n  }\n\n  const elements = resolveElements(elementOrSelector, scope);\n  const numElements = elements.length;\n  invariant(Boolean(numElements), \"No valid elements provided.\", \"no-valid-elements\");\n  /**\n   * WAAPI doesn't support interrupting animations.\n   *\n   * Therefore, starting animations requires a three-step process:\n   * 1. Stop existing animations (write styles to DOM)\n   * 2. Resolve keyframes (read styles from DOM)\n   * 3. Create new animations (write styles to DOM)\n   *\n   * The hybrid `animate()` function uses AsyncAnimation to resolve\n   * keyframes before creating new animations, which removes style\n   * thrashing. Here, we have much stricter filesize constraints.\n   * Therefore we do this in a synchronous way that ensures that\n   * at least within `animate()` calls there is no style thrashing.\n   *\n   * In the motion-native-animate-mini-interrupt benchmark this\n   * was 80% faster than a single loop.\n   */\n\n  const animationDefinitions = [];\n  /**\n   * Step 1: Build options and stop existing animations (write)\n   */\n\n  for (let i = 0; i < numElements; i++) {\n    const element = elements[i];\n    const elementTransition = { ...options\n    };\n    /**\n     * Resolve stagger function if provided.\n     */\n\n    if (typeof elementTransition.delay === \"function\") {\n      elementTransition.delay = elementTransition.delay(i, numElements);\n    }\n\n    for (const valueName in keyframes) {\n      let valueKeyframes = keyframes[valueName];\n\n      if (!Array.isArray(valueKeyframes)) {\n        valueKeyframes = [valueKeyframes];\n      }\n\n      const valueOptions = { ...getValueTransition(elementTransition, valueName)\n      };\n      valueOptions.duration && (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));\n      valueOptions.delay && (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));\n      /**\n       * If there's an existing animation playing on this element then stop it\n       * before creating a new one.\n       */\n\n      const map = getAnimationMap(element);\n      const key = animationMapKey(valueName, valueOptions.pseudoElement || \"\");\n      const currentAnimation = map.get(key);\n      currentAnimation && currentAnimation.stop();\n      animationDefinitions.push({\n        map,\n        key,\n        unresolvedKeyframes: valueKeyframes,\n        options: { ...valueOptions,\n          element,\n          name: valueName,\n          allowFlatten: !elementTransition.type && !elementTransition.ease\n        }\n      });\n    }\n  }\n  /**\n   * Step 2: Resolve keyframes (read)\n   */\n\n\n  for (let i = 0; i < animationDefinitions.length; i++) {\n    const {\n      unresolvedKeyframes,\n      options: animationOptions\n    } = animationDefinitions[i];\n    const {\n      element,\n      name,\n      pseudoElement\n    } = animationOptions;\n\n    if (!pseudoElement && unresolvedKeyframes[0] === null) {\n      unresolvedKeyframes[0] = getComputedStyle(element, name);\n    }\n\n    fillWildcards(unresolvedKeyframes);\n    applyPxDefaults(unresolvedKeyframes, name);\n    /**\n     * If we only have one keyframe, explicitly read the initial keyframe\n     * from the computed style. This is to ensure consistency with WAAPI behaviour\n     * for restarting animations, for instance .play() after finish, when it\n     * has one vs two keyframes.\n     */\n\n    if (!pseudoElement && unresolvedKeyframes.length < 2) {\n      unresolvedKeyframes.unshift(getComputedStyle(element, name));\n    }\n\n    animationOptions.keyframes = unresolvedKeyframes;\n  }\n  /**\n   * Step 3: Create new animations (write)\n   */\n\n\n  const animations = [];\n\n  for (let i = 0; i < animationDefinitions.length; i++) {\n    const {\n      map,\n      key,\n      options: animationOptions\n    } = animationDefinitions[i];\n    const animation = new NativeAnimation(animationOptions);\n    map.set(key, animation);\n    animation.finished.finally(() => map.delete(key));\n    animations.push(animation);\n  }\n\n  return animations;\n}\n\nexport { animateElements };","map":{"version":3,"mappings":"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","names":["animateElements","elementOrSelector","keyframes","options","scope","elements","resolveElements","numElements","length","invariant","Boolean","animationDefinitions","i","element","elementTransition","delay","valueName","valueKeyframes","Array","isArray","valueOptions","getValueTransition","duration","secondsToMilliseconds","map","getAnimationMap","key","animationMapKey","pseudoElement","currentAnimation","get","stop","push","unresolvedKeyframes","name","allowFlatten","type","ease","animationOptions","getComputedStyle","fillWildcards","applyPxDefaults","unshift","animations","animation","NativeAnimation","set","finished","finally","delete"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\animation\\animators\\waapi\\animate-elements.ts"],"sourcesContent":["import {\n    animationMapKey,\n    AnimationPlaybackControls,\n    AnimationScope,\n    applyPxDefaults,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    ElementOrSelector,\n    fillWildcards,\n    getAnimationMap,\n    getComputedStyle,\n    getValueTransition,\n    NativeAnimation,\n    NativeAnimationOptions,\n    resolveElements,\n    UnresolvedValueKeyframe,\n    ValueKeyframe,\n} from \"motion-dom\"\nimport { invariant, secondsToMilliseconds } from \"motion-utils\"\n\ninterface AnimationDefinition {\n    map: Map<string, NativeAnimation<any>>\n    key: string\n    unresolvedKeyframes: UnresolvedValueKeyframe[]\n    options: Omit<NativeAnimationOptions, \"keyframes\"> & {\n        keyframes?: ValueKeyframe[]\n    }\n}\n\nexport function animateElements(\n    elementOrSelector: ElementOrSelector,\n    keyframes: DOMKeyframesDefinition,\n    options?: DynamicAnimationOptions,\n    scope?: AnimationScope\n) {\n    // Gracefully handle null/undefined elements (e.g., from querySelector returning null)\n    if (elementOrSelector == null) {\n        return []\n    }\n\n    const elements = resolveElements(elementOrSelector, scope) as Array<\n        HTMLElement | SVGElement\n    >\n    const numElements = elements.length\n\n    invariant(\n        Boolean(numElements),\n        \"No valid elements provided.\",\n        \"no-valid-elements\"\n    )\n\n    /**\n     * WAAPI doesn't support interrupting animations.\n     *\n     * Therefore, starting animations requires a three-step process:\n     * 1. Stop existing animations (write styles to DOM)\n     * 2. Resolve keyframes (read styles from DOM)\n     * 3. Create new animations (write styles to DOM)\n     *\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\n     * keyframes before creating new animations, which removes style\n     * thrashing. Here, we have much stricter filesize constraints.\n     * Therefore we do this in a synchronous way that ensures that\n     * at least within `animate()` calls there is no style thrashing.\n     *\n     * In the motion-native-animate-mini-interrupt benchmark this\n     * was 80% faster than a single loop.\n     */\n    const animationDefinitions: AnimationDefinition[] = []\n\n    /**\n     * Step 1: Build options and stop existing animations (write)\n     */\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i]\n        const elementTransition: DynamicAnimationOptions = { ...options }\n\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof elementTransition.delay === \"function\") {\n            elementTransition.delay = elementTransition.delay(i, numElements)\n        }\n\n        for (const valueName in keyframes) {\n            let valueKeyframes = keyframes[valueName as keyof typeof keyframes]!\n\n            if (!Array.isArray(valueKeyframes)) {\n                valueKeyframes = [valueKeyframes]\n            }\n\n            const valueOptions = {\n                ...getValueTransition(elementTransition as any, valueName),\n            }\n\n            valueOptions.duration &&= secondsToMilliseconds(\n                valueOptions.duration\n            )\n\n            valueOptions.delay &&= secondsToMilliseconds(valueOptions.delay)\n\n            /**\n             * If there's an existing animation playing on this element then stop it\n             * before creating a new one.\n             */\n            const map = getAnimationMap(element)\n            const key = animationMapKey(\n                valueName,\n                valueOptions.pseudoElement || \"\"\n            )\n            const currentAnimation = map.get(key)\n            currentAnimation && currentAnimation.stop()\n\n            animationDefinitions.push({\n                map,\n                key,\n                unresolvedKeyframes: valueKeyframes,\n                options: {\n                    ...valueOptions,\n                    element,\n                    name: valueName,\n                    allowFlatten:\n                        !elementTransition.type && !elementTransition.ease,\n                },\n            })\n        }\n    }\n\n    /**\n     * Step 2: Resolve keyframes (read)\n     */\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { unresolvedKeyframes, options: animationOptions } =\n            animationDefinitions[i]\n\n        const { element, name, pseudoElement } = animationOptions\n        if (!pseudoElement && unresolvedKeyframes[0] === null) {\n            unresolvedKeyframes[0] = getComputedStyle(element, name)\n        }\n\n        fillWildcards(unresolvedKeyframes)\n        applyPxDefaults(unresolvedKeyframes, name)\n\n        /**\n         * If we only have one keyframe, explicitly read the initial keyframe\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\n         * for restarting animations, for instance .play() after finish, when it\n         * has one vs two keyframes.\n         */\n        if (!pseudoElement && unresolvedKeyframes.length < 2) {\n            unresolvedKeyframes.unshift(getComputedStyle(element, name))\n        }\n\n        animationOptions.keyframes = unresolvedKeyframes as ValueKeyframe[]\n    }\n\n    /**\n     * Step 3: Create new animations (write)\n     */\n    const animations: AnimationPlaybackControls[] = []\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { map, key, options: animationOptions } = animationDefinitions[i]\n        const animation = new NativeAnimation(\n            animationOptions as NativeAnimationOptions\n        )\n\n        map.set(key, animation)\n        animation.finished.finally(() => map.delete(key))\n\n        animations.push(animation)\n    }\n\n    return animations\n}\n"]},"metadata":{},"sourceType":"module"}