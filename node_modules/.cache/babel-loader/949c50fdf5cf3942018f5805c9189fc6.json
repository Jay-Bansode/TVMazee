{"ast":null,"code":"import { warnOnce, SubscriptionManager, velocityPerSecond } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { frame } from '../frameloop/frame.mjs';\n/**\n * Maximum time between the value of two frames, beyond which we\n * assume the velocity has since been 0.\n */\n\nconst MAX_VELOCITY_DELTA = 30;\n\nconst isFloat = value => {\n  return !isNaN(parseFloat(value));\n};\n\nconst collectMotionValues = {\n  current: undefined\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\n\nclass MotionValue {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   */\n  constructor(init) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n    this.canTrackVelocity = null;\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n\n    this.events = {};\n\n    this.updateAndNotify = v => {\n      const currentTime = time.now();\n      /**\n       * If we're updating the value during another frame or eventloop\n       * than the previous frame, then the we set the previous frame value\n       * to current.\n       */\n\n      if (this.updatedAt !== currentTime) {\n        this.setPrevFrameValue();\n      }\n\n      this.prev = this.current;\n      this.setCurrent(v); // Update update subscribers\n\n      if (this.current !== this.prev) {\n        this.events.change?.notify(this.current);\n\n        if (this.dependents) {\n          for (const dependent of this.dependents) {\n            dependent.dirty();\n          }\n        }\n      }\n    };\n\n    this.hasAnimated = false;\n    this.setCurrent(init);\n    this.owner = options.owner;\n  }\n\n  setCurrent(current) {\n    this.current = current;\n    this.updatedAt = time.now();\n\n    if (this.canTrackVelocity === null && current !== undefined) {\n      this.canTrackVelocity = isFloat(this.current);\n    }\n  }\n\n  setPrevFrameValue() {\n    let prevFrameValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.current;\n    this.prevFrameValue = prevFrameValue;\n    this.prevUpdatedAt = this.updatedAt;\n  }\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.on(\"change\", updateOpacity)\n   *     const unsubscribeY = y.on(\"change\", updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @deprecated\n   */\n\n\n  onChange(subscription) {\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n    }\n\n    return this.on(\"change\", subscription);\n  }\n\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n\n    const unsubscribe = this.events[eventName].add(callback);\n\n    if (eventName === \"change\") {\n      return () => {\n        unsubscribe();\n        /**\n         * If we have no more change listeners by the start\n         * of the next frame, stop active animations.\n         */\n\n        frame.read(() => {\n          if (!this.events.change.getSize()) {\n            this.stop();\n          }\n        });\n      };\n    }\n\n    return unsubscribe;\n  }\n\n  clearListeners() {\n    for (const eventManagers in this.events) {\n      this.events[eventManagers].clear();\n    }\n  }\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   */\n\n\n  attach(passiveEffect, stopPassiveEffect) {\n    this.passiveEffect = passiveEffect;\n    this.stopPassiveEffect = stopPassiveEffect;\n  }\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n\n\n  set(v) {\n    if (!this.passiveEffect) {\n      this.updateAndNotify(v);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  }\n\n  setWithVelocity(prev, current, delta) {\n    this.set(current);\n    this.prev = undefined;\n    this.prevFrameValue = prev;\n    this.prevUpdatedAt = this.updatedAt - delta;\n  }\n  /**\n   * Set the state of the `MotionValue`, stopping any active animations,\n   * effects, and resets velocity to `0`.\n   */\n\n\n  jump(v) {\n    let endAnimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.updateAndNotify(v);\n    this.prev = v;\n    this.prevUpdatedAt = this.prevFrameValue = undefined;\n    endAnimation && this.stop();\n    if (this.stopPassiveEffect) this.stopPassiveEffect();\n  }\n\n  dirty() {\n    this.events.change?.notify(this.current);\n  }\n\n  addDependent(dependent) {\n    if (!this.dependents) {\n      this.dependents = new Set();\n    }\n\n    this.dependents.add(dependent);\n  }\n\n  removeDependent(dependent) {\n    if (this.dependents) {\n      this.dependents.delete(dependent);\n    }\n  }\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n\n\n  get() {\n    if (collectMotionValues.current) {\n      collectMotionValues.current.push(this);\n    }\n\n    return this.current;\n  }\n  /**\n   * @public\n   */\n\n\n  getPrevious() {\n    return this.prev;\n  }\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n\n\n  getVelocity() {\n    const currentTime = time.now();\n\n    if (!this.canTrackVelocity || this.prevFrameValue === undefined || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {\n      return 0;\n    }\n\n    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA); // Casts because of parseFloat's poor typing\n\n    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);\n  }\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   */\n\n\n  start(startAnimation) {\n    this.stop();\n    return new Promise(resolve => {\n      this.hasAnimated = true;\n      this.animation = startAnimation(resolve);\n\n      if (this.events.animationStart) {\n        this.events.animationStart.notify();\n      }\n    }).then(() => {\n      if (this.events.animationComplete) {\n        this.events.animationComplete.notify();\n      }\n\n      this.clearAnimation();\n    });\n  }\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n\n\n  stop() {\n    if (this.animation) {\n      this.animation.stop();\n\n      if (this.events.animationCancel) {\n        this.events.animationCancel.notify();\n      }\n    }\n\n    this.clearAnimation();\n  }\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n\n\n  isAnimating() {\n    return !!this.animation;\n  }\n\n  clearAnimation() {\n    delete this.animation;\n  }\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n\n\n  destroy() {\n    this.dependents?.clear();\n    this.events.destroy?.notify();\n    this.clearListeners();\n    this.stop();\n\n    if (this.stopPassiveEffect) {\n      this.stopPassiveEffect();\n    }\n  }\n\n}\n\nfunction motionValue(init, options) {\n  return new MotionValue(init, options);\n}\n\nexport { MotionValue, collectMotionValues, motionValue };","map":{"version":3,"mappings":"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","names":["MAX_VELOCITY_DELTA","isFloat","value","isNaN","parseFloat","current","undefined","MotionValue","constructor","options","canTrackVelocity","events","v","currentTime","time","now","updatedAt","setPrevFrameValue","prev","setCurrent","change","notify","dependents","dependent","dirty","hasAnimated","init","owner","prevFrameValue","prevUpdatedAt","onChange","subscription","process","env","NODE_ENV","warnOnce","on","eventName","callback","SubscriptionManager","unsubscribe","add","frame","read","getSize","stop","clearListeners","eventManagers","clear","attach","passiveEffect","stopPassiveEffect","set","updateAndNotify","setWithVelocity","delta","jump","endAnimation","addDependent","Set","removeDependent","delete","get","collectMotionValues","push","getPrevious","getVelocity","Math","min","velocityPerSecond","start","startAnimation","Promise","resolve","animation","animationStart","then","animationComplete","clearAnimation","animationCancel","isAnimating","destroy"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\value\\index.ts"],"sourcesContent":["import {\n    EasingFunction,\n    SubscriptionManager,\n    velocityPerSecond,\n    warnOnce,\n} from \"motion-utils\"\nimport {\n    AnimationPlaybackControlsWithThen,\n    AnyResolvedKeyframe,\n    TransformProperties,\n} from \"../animation/types\"\nimport { frame } from \"../frameloop\"\nimport { time } from \"../frameloop/sync-time\"\n\n/**\n * @public\n */\nexport type Subscriber<T> = (v: T) => void\n\n/**\n * @public\n */\nexport type PassiveEffect<T> = (v: T, safeSetter: (v: T) => void) => void\n\nexport type StartAnimation = (\n    complete: () => void\n) => AnimationPlaybackControlsWithThen | undefined\n\nexport interface MotionValueEventCallbacks<V> {\n    animationStart: () => void\n    animationComplete: () => void\n    animationCancel: () => void\n    change: (latestValue: V) => void\n    destroy: () => void\n}\n\n/**\n * Maximum time between the value of two frames, beyond which we\n * assume the velocity has since been 0.\n */\nconst MAX_VELOCITY_DELTA = 30\n\nconst isFloat = (value: any): value is string => {\n    return !isNaN(parseFloat(value))\n}\n\ninterface ResolvedValues {\n    [key: string]: AnyResolvedKeyframe\n}\n\nexport interface Owner {\n    current: HTMLElement | unknown\n    getProps: () => {\n        onUpdate?: (latest: ResolvedValues) => void\n        transformTemplate?: (\n            transform: TransformProperties,\n            generatedTransform: string\n        ) => string\n    }\n}\n\nexport interface AccelerateConfig {\n    factory: (animation: AnimationPlaybackControlsWithThen) => VoidFunction\n    times: number[]\n    keyframes: any[]\n    ease?: EasingFunction | EasingFunction[]\n    duration: number\n    isTransformed?: boolean\n}\n\nexport interface MotionValueOptions {\n    owner?: Owner\n}\n\nexport const collectMotionValues: { current: MotionValue[] | undefined } = {\n    current: undefined,\n}\n\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nexport class MotionValue<V = any> {\n    /**\n     * If a MotionValue has an owner, it was created internally within Motion\n     * and therefore has no external listeners. It is therefore safe to animate via WAAPI.\n     */\n    owner?: Owner\n\n    /**\n     * The current state of the `MotionValue`.\n     */\n    private current: V | undefined\n\n    /**\n     * The previous state of the `MotionValue`.\n     */\n    private prev: V | undefined\n\n    /**\n     * The previous state of the `MotionValue` at the end of the previous frame.\n     */\n    private prevFrameValue: V | undefined\n\n    /**\n     * The last time the `MotionValue` was updated.\n     */\n    updatedAt: number\n\n    /**\n     * The time `prevFrameValue` was updated.\n     */\n    prevUpdatedAt: number | undefined\n\n    /**\n     * Add a passive effect to this `MotionValue`.\n     *\n     * A passive effect intercepts calls to `set`. For instance, `useSpring` adds\n     * a passive effect that attaches a `spring` to the latest\n     * set value. Hypothetically there could be a `useSmooth` that attaches an input smoothing effect.\n     *\n     * @internal\n     */\n    private passiveEffect?: PassiveEffect<V>\n    private stopPassiveEffect?: VoidFunction\n\n    /**\n     * Whether the passive effect is active.\n     */\n    isEffectActive?: boolean\n\n    /**\n     * A reference to the currently-controlling animation.\n     */\n    animation?: AnimationPlaybackControlsWithThen\n\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n    private canTrackVelocity: boolean | null = null\n\n    /**\n     * A list of MotionValues whose values are computed from this one.\n     * This is a rough start to a proper signal-like dirtying system.\n     */\n    private dependents: Set<MotionValue> | undefined\n\n    /**\n     * Tracks whether this value should be removed\n     */\n    liveStyle?: boolean\n\n    /**\n     * Scroll timeline acceleration metadata. When set, VisualElement\n     * can create a native WAAPI animation attached to a scroll timeline\n     * instead of driving updates through JS.\n     */\n    accelerate?: AccelerateConfig\n\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     */\n    constructor(init: V, options: MotionValueOptions = {}) {\n        this.setCurrent(init)\n        this.owner = options.owner\n    }\n\n    setCurrent(current: V) {\n        this.current = current\n        this.updatedAt = time.now()\n\n        if (this.canTrackVelocity === null && current !== undefined) {\n            this.canTrackVelocity = isFloat(this.current)\n        }\n    }\n\n    setPrevFrameValue(prevFrameValue: V | undefined = this.current) {\n        this.prevFrameValue = prevFrameValue\n        this.prevUpdatedAt = this.updatedAt\n    }\n\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.on(\"change\", updateOpacity)\n     *     const unsubscribeY = y.on(\"change\", updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @deprecated\n     */\n    onChange(subscription: Subscriber<V>): () => void {\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(\n                false,\n                `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`\n            )\n        }\n        return this.on(\"change\", subscription)\n    }\n\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    private events: {\n        [key: string]: SubscriptionManager<any>\n    } = {}\n\n    on<EventName extends keyof MotionValueEventCallbacks<V>>(\n        eventName: EventName,\n        callback: MotionValueEventCallbacks<V>[EventName]\n    ) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager()\n        }\n\n        const unsubscribe = this.events[eventName].add(callback)\n\n        if (eventName === \"change\") {\n            return () => {\n                unsubscribe()\n\n                /**\n                 * If we have no more change listeners by the start\n                 * of the next frame, stop active animations.\n                 */\n                frame.read(() => {\n                    if (!this.events.change.getSize()) {\n                        this.stop()\n                    }\n                })\n            }\n        }\n\n        return unsubscribe\n    }\n\n    clearListeners() {\n        for (const eventManagers in this.events) {\n            this.events[eventManagers].clear()\n        }\n    }\n\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     */\n    attach(passiveEffect: PassiveEffect<V>, stopPassiveEffect: VoidFunction) {\n        this.passiveEffect = passiveEffect\n        this.stopPassiveEffect = stopPassiveEffect\n    }\n\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    set(v: V) {\n        if (!this.passiveEffect) {\n            this.updateAndNotify(v)\n        } else {\n            this.passiveEffect(v, this.updateAndNotify)\n        }\n    }\n\n    setWithVelocity(prev: V, current: V, delta: number) {\n        this.set(current)\n        this.prev = undefined\n        this.prevFrameValue = prev\n        this.prevUpdatedAt = this.updatedAt - delta\n    }\n\n    /**\n     * Set the state of the `MotionValue`, stopping any active animations,\n     * effects, and resets velocity to `0`.\n     */\n    jump(v: V, endAnimation = true) {\n        this.updateAndNotify(v)\n        this.prev = v\n        this.prevUpdatedAt = this.prevFrameValue = undefined\n        endAnimation && this.stop()\n        if (this.stopPassiveEffect) this.stopPassiveEffect()\n    }\n\n    dirty() {\n        this.events.change?.notify(this.current)\n    }\n\n    addDependent(dependent: MotionValue) {\n        if (!this.dependents) {\n            this.dependents = new Set()\n        }\n        this.dependents.add(dependent)\n    }\n\n    removeDependent(dependent: MotionValue) {\n        if (this.dependents) {\n            this.dependents.delete(dependent)\n        }\n    }\n\n    updateAndNotify = (v: V) => {\n        const currentTime = time.now()\n\n        /**\n         * If we're updating the value during another frame or eventloop\n         * than the previous frame, then the we set the previous frame value\n         * to current.\n         */\n        if (this.updatedAt !== currentTime) {\n            this.setPrevFrameValue()\n        }\n\n        this.prev = this.current\n\n        this.setCurrent(v)\n\n        // Update update subscribers\n        if (this.current !== this.prev) {\n            this.events.change?.notify(this.current)\n\n            if (this.dependents) {\n                for (const dependent of this.dependents) {\n                    dependent.dirty()\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    get() {\n        if (collectMotionValues.current) {\n            collectMotionValues.current.push(this)\n        }\n\n        return this.current!\n    }\n\n    /**\n     * @public\n     */\n    getPrevious() {\n        return this.prev\n    }\n\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    getVelocity() {\n        const currentTime = time.now()\n\n        if (\n            !this.canTrackVelocity ||\n            this.prevFrameValue === undefined ||\n            currentTime - this.updatedAt > MAX_VELOCITY_DELTA\n        ) {\n            return 0\n        }\n\n        const delta = Math.min(\n            this.updatedAt - this.prevUpdatedAt!,\n            MAX_VELOCITY_DELTA\n        )\n\n        // Casts because of parseFloat's poor typing\n        return velocityPerSecond(\n            parseFloat(this.current as any) -\n                parseFloat(this.prevFrameValue as any),\n            delta\n        )\n    }\n\n    hasAnimated = false\n\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     */\n    start(startAnimation: StartAnimation) {\n        this.stop()\n\n        return new Promise<void>((resolve) => {\n            this.hasAnimated = true\n            this.animation = startAnimation(resolve)\n\n            if (this.events.animationStart) {\n                this.events.animationStart.notify()\n            }\n        }).then(() => {\n            if (this.events.animationComplete) {\n                this.events.animationComplete.notify()\n            }\n            this.clearAnimation()\n        })\n    }\n\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    stop() {\n        if (this.animation) {\n            this.animation.stop()\n            if (this.events.animationCancel) {\n                this.events.animationCancel.notify()\n            }\n        }\n        this.clearAnimation()\n    }\n\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    isAnimating() {\n        return !!this.animation\n    }\n\n    private clearAnimation() {\n        delete this.animation\n    }\n\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    destroy() {\n        this.dependents?.clear()\n        this.events.destroy?.notify()\n        this.clearListeners()\n        this.stop()\n\n        if (this.stopPassiveEffect) {\n            this.stopPassiveEffect()\n        }\n    }\n}\n\nexport function motionValue<V>(init: V, options?: MotionValueOptions) {\n    return new MotionValue<V>(init, options)\n}\n"]},"metadata":{},"sourceType":"module"}