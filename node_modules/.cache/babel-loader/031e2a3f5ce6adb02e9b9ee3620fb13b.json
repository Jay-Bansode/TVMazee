{"ast":null,"code":"import { Feature, addDomEvent } from 'motion-dom';\nimport { pipe } from 'motion-utils';\n\nclass FocusGesture extends Feature {\n  constructor() {\n    super(...arguments);\n    this.isActive = false;\n  }\n\n  onFocus() {\n    let isFocusVisible = false;\n    /**\n     * If this element doesn't match focus-visible then don't\n     * apply whileHover. But, if matches throws that focus-visible\n     * is not a valid selector then in that browser outline styles will be applied\n     * to the element by default and we want to match that behaviour with whileFocus.\n     */\n\n    try {\n      isFocusVisible = this.node.current.matches(\":focus-visible\");\n    } catch (e) {\n      isFocusVisible = true;\n    }\n\n    if (!isFocusVisible || !this.node.animationState) return;\n    this.node.animationState.setActive(\"whileFocus\", true);\n    this.isActive = true;\n  }\n\n  onBlur() {\n    if (!this.isActive || !this.node.animationState) return;\n    this.node.animationState.setActive(\"whileFocus\", false);\n    this.isActive = false;\n  }\n\n  mount() {\n    this.unmount = pipe(addDomEvent(this.node.current, \"focus\", () => this.onFocus()), addDomEvent(this.node.current, \"blur\", () => this.onBlur()));\n  }\n\n  unmount() {}\n\n}\n\nexport { FocusGesture };","map":{"version":3,"mappings":";;;AAGM,MAAOA,YAAP,SAA4BC,OAA5B,CAA4C;EAAlDC;;IACY,KAAQC,QAAR,GAAW,KAAX;EAqCX;;EAnCGC,OAAO;IACH,IAAIC,cAAc,GAAG,KAArB;IAEA;;;;;AAKG;;IACH,IAAI;MACAA,cAAc,GAAG,KAAKC,IAAL,CAAUC,OAAV,CAAmBC,OAAnB,CAA2B,gBAA3B,CAAjB;IACH,CAFD,CAEE,OAAOC,CAAP,EAAU;MACRJ,cAAc,GAAG,IAAjB;IACH;;IAED,IAAI,CAACA,cAAD,IAAmB,CAAC,KAAKC,IAAL,CAAUI,cAAlC,EAAkD;IAElD,KAAKJ,IAAL,CAAUI,cAAV,CAAyBC,SAAzB,CAAmC,YAAnC,EAAiD,IAAjD;IACA,KAAKR,QAAL,GAAgB,IAAhB;EACH;;EAEDS,MAAM;IACF,IAAI,CAAC,KAAKT,QAAN,IAAkB,CAAC,KAAKG,IAAL,CAAUI,cAAjC,EAAiD;IACjD,KAAKJ,IAAL,CAAUI,cAAV,CAAyBC,SAAzB,CAAmC,YAAnC,EAAiD,KAAjD;IACA,KAAKR,QAAL,GAAgB,KAAhB;EACH;;EAEDU,KAAK;IACD,KAAKC,OAAL,GAAeC,IAAI,CACfC,WAAW,CAAC,KAAKV,IAAL,CAAUC,OAAX,EAAqB,OAArB,EAA8B,MAAM,KAAKH,OAAL,EAApC,CADI,EAEfY,WAAW,CAAC,KAAKV,IAAL,CAAUC,OAAX,EAAqB,MAArB,EAA6B,MAAM,KAAKK,MAAL,EAAnC,CAFI,CAAnB;EAIH;;EAEDE,OAAO,IAAK;;AArCkC","names":["FocusGesture","Feature","constructor","isActive","onFocus","isFocusVisible","node","current","matches","e","animationState","setActive","onBlur","mount","unmount","pipe","addDomEvent"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\gestures\\focus.ts"],"sourcesContent":["import { Feature, addDomEvent } from \"motion-dom\"\nimport { pipe } from \"motion-utils\"\n\nexport class FocusGesture extends Feature<Element> {\n    private isActive = false\n\n    onFocus() {\n        let isFocusVisible = false\n\n        /**\n         * If this element doesn't match focus-visible then don't\n         * apply whileHover. But, if matches throws that focus-visible\n         * is not a valid selector then in that browser outline styles will be applied\n         * to the element by default and we want to match that behaviour with whileFocus.\n         */\n        try {\n            isFocusVisible = this.node.current!.matches(\":focus-visible\")\n        } catch (e) {\n            isFocusVisible = true\n        }\n\n        if (!isFocusVisible || !this.node.animationState) return\n\n        this.node.animationState.setActive(\"whileFocus\", true)\n        this.isActive = true\n    }\n\n    onBlur() {\n        if (!this.isActive || !this.node.animationState) return\n        this.node.animationState.setActive(\"whileFocus\", false)\n        this.isActive = false\n    }\n\n    mount() {\n        this.unmount = pipe(\n            addDomEvent(this.node.current!, \"focus\", () => this.onFocus()),\n            addDomEvent(this.node.current!, \"blur\", () => this.onBlur())\n        ) as VoidFunction\n    }\n\n    unmount() {}\n}\n"]},"metadata":{},"sourceType":"module"}