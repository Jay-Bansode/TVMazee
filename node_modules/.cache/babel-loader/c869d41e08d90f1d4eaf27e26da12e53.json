{"ast":null,"code":"import * as React from 'react';\n/**\n * Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\n\nfunction setRef(ref, value) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\n\n\nfunction composeRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  return node => {\n    let hasCleanup = false;\n    const cleanups = refs.map(ref => {\n      const cleanup = setRef(ref, node);\n\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n\n      return cleanup;\n    }); // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\n\n\nfunction useComposedRefs() {\n  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    refs[_key2] = arguments[_key2];\n  }\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { useComposedRefs };","map":{"version":3,"mappings":";AAAA;;AAEG;;AAKH;;;AAGG;;AACH,SAASA,MAAT,CAAmBC,GAAnB,EAAwCC,KAAxC,EAAgD;EAC5C,IAAI,OAAOD,GAAP,KAAe,UAAnB,EAA+B;IAC3B,OAAOA,GAAG,CAACC,KAAD,CAAV;EACH,CAFD,MAEO,IAAID,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAKE,SAA5B,EAAuC;IACxCF,GAAiC,CAACG,OAAlC,GAA4CF,KAA5C;EACL;AACJ;AAED;;;AAGG;;;AACH,SAASG,WAAT,GAAiD;EAAA,kCAAtBC,IAAsB;IAAtBA,IAAsB;EAAA;;EAC7C,OAAQC,IAAD,IAAS;IACZ,IAAIC,UAAU,GAAG,KAAjB;IACA,MAAMC,QAAQ,GAAGH,IAAI,CAACI,GAAL,CAAUT,GAAD,IAAQ;MAC9B,MAAMU,OAAO,GAAGX,MAAM,CAACC,GAAD,EAAMM,IAAN,CAAtB;;MACA,IAAI,CAACC,UAAD,IAAe,OAAOG,OAAP,KAAmB,UAAtC,EAAkD;QAC9CH,UAAU,GAAG,IAAb;MACH;;MACD,OAAOG,OAAP;IACH,CANgB,CAAjB,CAFY;;;;;IAaZ,IAAIH,UAAJ,EAAgB;MACZ,OAAO,MAAK;QACR,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,QAAQ,CAACI,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;UACtC,MAAMD,OAAO,GAAGF,QAAQ,CAACG,CAAD,CAAxB;;UACA,IAAI,OAAOD,OAAP,KAAmB,UAAvB,EAAmC;YAC/BA,OAAO;UACV,CAFD,MAEO;YACHX,MAAM,CAACM,IAAI,CAACM,CAAD,CAAL,EAAU,IAAV,CAAN;UACH;QACJ;MACJ,CATD;IAUH;EACJ,CAzBD;AA0BH;AAED;;;AAGG;;;AACH,SAASE,eAAT,GAAqD;EAAA,mCAAtBR,IAAsB;IAAtBA,IAAsB;EAAA;;;EAEjD,OAAOS,KAAK,CAACC,WAAN,CAAkBX,WAAW,CAAC,GAAGC,IAAJ,CAA7B,EAAwCA,IAAxC,CAAP;AACJ","names":["setRef","ref","value","undefined","current","composeRefs","refs","node","hasCleanup","cleanups","map","cleanup","i","length","useComposedRefs","React","useCallback"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\utils\\use-composed-ref.ts"],"sourcesContent":["/**\n * Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\nimport * as React from \"react\"\n\ntype PossibleRef<T> = React.Ref<T> | undefined\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T): void | (() => void) {\n    if (typeof ref === \"function\") {\n        return ref(value)\n    } else if (ref !== null && ref !== undefined) {\n        ;(ref as React.MutableRefObject<T>).current = value\n    }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    return (node) => {\n        let hasCleanup = false\n        const cleanups = refs.map((ref) => {\n            const cleanup = setRef(ref, node)\n            if (!hasCleanup && typeof cleanup === \"function\") {\n                hasCleanup = true\n            }\n            return cleanup\n        })\n        // React <19 will log an error to the console if a callback ref returns a\n        // value. We don't use ref cleanups internally so this will only happen if a\n        // user's ref callback returns a value, which we only expect if they are\n        // using the cleanup functionality added in React 19.\n        if (hasCleanup) {\n            return () => {\n                for (let i = 0; i < cleanups.length; i++) {\n                    const cleanup = cleanups[i]\n                    if (typeof cleanup === \"function\") {\n                        cleanup()\n                    } else {\n                        setRef(refs[i], null)\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return React.useCallback(composeRefs(...refs), refs)\n}\n\nexport { useComposedRefs }\n"]},"metadata":{},"sourceType":"module"}