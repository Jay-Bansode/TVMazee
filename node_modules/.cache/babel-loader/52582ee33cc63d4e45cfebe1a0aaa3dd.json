{"ast":null,"code":"import { millisecondsToSeconds, secondsToMilliseconds, clamp } from 'motion-utils';\nimport { generateLinearEasing } from '../../waapi/utils/linear.mjs';\nimport { calcGeneratorDuration, maxGeneratorDuration } from '../utils/calc-duration.mjs';\nimport { createGeneratorEasing } from '../utils/create-generator-easing.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { springDefaults } from './defaults.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\n\nfunction isSpringType(options, keys) {\n  return keys.some(key => options[key] !== undefined);\n}\n\nfunction getSpringOptions(options) {\n  let springOptions = {\n    velocity: springDefaults.velocity,\n    stiffness: springDefaults.stiffness,\n    damping: springDefaults.damping,\n    mass: springDefaults.mass,\n    isResolvedFromDuration: false,\n    ...options\n  }; // stiffness/damping/mass overrides duration/bounce\n\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    // Time-defined springs should ignore inherited velocity.\n    // Velocity from interrupted animations can cause findSpring()\n    // to compute wildly different spring parameters, leading to\n    // massive oscillation on small-range animations.\n    springOptions.velocity = 0;\n\n    if (options.visualDuration) {\n      const visualDuration = options.visualDuration;\n      const root = 2 * Math.PI / (visualDuration * 1.2);\n      const stiffness = root * root;\n      const damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);\n      springOptions = { ...springOptions,\n        mass: springDefaults.mass,\n        stiffness,\n        damping\n      };\n    } else {\n      const derived = findSpring({ ...options,\n        velocity: 0\n      });\n      springOptions = { ...springOptions,\n        ...derived,\n        mass: springDefaults.mass\n      };\n      springOptions.isResolvedFromDuration = true;\n    }\n  }\n\n  return springOptions;\n}\n\nfunction spring() {\n  let optionsOrVisualDuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : springDefaults.visualDuration;\n  let bounce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : springDefaults.bounce;\n  const options = typeof optionsOrVisualDuration !== \"object\" ? {\n    visualDuration: optionsOrVisualDuration,\n    keyframes: [0, 1],\n    bounce\n  } : optionsOrVisualDuration;\n  let {\n    restSpeed,\n    restDelta\n  } = options;\n  const origin = options.keyframes[0];\n  const target = options.keyframes[options.keyframes.length - 1];\n  /**\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n   * to reduce GC during animation.\n   */\n\n  const state = {\n    done: false,\n    value: origin\n  };\n  const {\n    stiffness,\n    damping,\n    mass,\n    duration,\n    velocity,\n    isResolvedFromDuration\n  } = getSpringOptions({ ...options,\n    velocity: -millisecondsToSeconds(options.velocity || 0)\n  });\n  const initialVelocity = velocity || 0.0;\n  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n  const initialDelta = target - origin;\n  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n  /**\n   * If we're working on a granular scale, use smaller defaults for determining\n   * when the spring is finished.\n   *\n   * These defaults have been selected emprically based on what strikes a good\n   * ratio between feeling good and finishing as soon as changes are imperceptible.\n   */\n\n  const isGranularScale = Math.abs(initialDelta) < 5;\n  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);\n  restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);\n  let resolveSpring;\n\n  if (dampingRatio < 1) {\n    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio); // Underdamped spring\n\n    resolveSpring = t => {\n      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n    };\n  } else if (dampingRatio === 1) {\n    // Critically damped spring\n    resolveSpring = t => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n  } else {\n    // Overdamped spring\n    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n\n    resolveSpring = t => {\n      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t); // When performing sinh or cosh values can hit Infinity so we cap them here\n\n      const freqForT = Math.min(dampedAngularFreq * t, 300);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n    };\n  }\n\n  const generator = {\n    calculatedDuration: isResolvedFromDuration ? duration || null : null,\n    next: t => {\n      const current = resolveSpring(t);\n\n      if (!isResolvedFromDuration) {\n        let currentVelocity = t === 0 ? initialVelocity : 0.0;\n        /**\n         * We only need to calculate velocity for under-damped springs\n         * as over- and critically-damped springs can't overshoot, so\n         * checking only for displacement is enough.\n         */\n\n        if (dampingRatio < 1) {\n          currentVelocity = t === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);\n        }\n\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n\n      state.value = state.done ? target : current;\n      return state;\n    },\n    toString: () => {\n      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n      const easing = generateLinearEasing(progress => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n      return calculatedDuration + \"ms \" + easing;\n    },\n    toTransition: () => {}\n  };\n  return generator;\n}\n\nspring.applyToOptions = options => {\n  const generatorOptions = createGeneratorEasing(options, 100, spring);\n  options.ease = generatorOptions.ease;\n  options.duration = secondsToMilliseconds(generatorOptions.duration);\n  options.type = \"keyframes\";\n  return options;\n};\n\nexport { spring };","map":{"version":3,"mappings":"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","names":["durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","velocity","springDefaults","stiffness","damping","mass","isResolvedFromDuration","visualDuration","root","Math","PI","clamp","bounce","sqrt","derived","findSpring","spring","optionsOrVisualDuration","keyframes","restSpeed","restDelta","origin","target","length","state","done","value","duration","millisecondsToSeconds","initialVelocity","dampingRatio","initialDelta","undampedAngularFreq","isGranularScale","abs","granular","default","resolveSpring","angularFreq","calcAngularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","generator","calculatedDuration","next","current","currentVelocity","secondsToMilliseconds","calcGeneratorVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","toString","calcGeneratorDuration","maxGeneratorDuration","easing","generateLinearEasing","progress","toTransition","applyToOptions","generatorOptions","createGeneratorEasing","ease","type"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\animation\\generators\\spring\\index.ts"],"sourcesContent":["import {\n    clamp,\n    millisecondsToSeconds,\n    secondsToMilliseconds,\n} from \"motion-utils\"\nimport {\n    AnimationState,\n    KeyframeGenerator,\n    SpringOptions,\n    Transition,\n    ValueAnimationOptions,\n} from \"../../types\"\nimport { generateLinearEasing } from \"../../waapi/utils/linear\"\nimport {\n    calcGeneratorDuration,\n    maxGeneratorDuration,\n} from \"../utils/calc-duration\"\nimport { createGeneratorEasing } from \"../utils/create-generator-easing\"\nimport { calcGeneratorVelocity } from \"../utils/velocity\"\nimport { springDefaults } from \"./defaults\"\nimport { calcAngularFreq, findSpring } from \"./find\"\n\nconst durationKeys = [\"duration\", \"bounce\"]\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"]\n\nfunction isSpringType(options: SpringOptions, keys: string[]) {\n    return keys.some((key) => (options as any)[key] !== undefined)\n}\n\nfunction getSpringOptions(options: SpringOptions) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    }\n    // stiffness/damping/mass overrides duration/bounce\n    if (\n        !isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)\n    ) {\n        // Time-defined springs should ignore inherited velocity.\n        // Velocity from interrupted animations can cause findSpring()\n        // to compute wildly different spring parameters, leading to\n        // massive oscillation on small-range animations.\n        springOptions.velocity = 0\n\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration\n            const root = (2 * Math.PI) / (visualDuration * 1.2)\n            const stiffness = root * root\n            const damping =\n                2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness)\n\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            }\n        } else {\n            const derived = findSpring({ ...options, velocity: 0 })\n\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            }\n            springOptions.isResolvedFromDuration = true\n        }\n    }\n\n    return springOptions\n}\n\nfunction spring(\n    optionsOrVisualDuration:\n        | ValueAnimationOptions<number>\n        | number = springDefaults.visualDuration,\n    bounce = springDefaults.bounce\n): KeyframeGenerator<number> {\n    const options =\n        typeof optionsOrVisualDuration !== \"object\"\n            ? ({\n                  visualDuration: optionsOrVisualDuration,\n                  keyframes: [0, 1],\n                  bounce,\n              } as ValueAnimationOptions<number>)\n            : optionsOrVisualDuration\n\n    let { restSpeed, restDelta } = options\n\n    const origin = options.keyframes[0]\n    const target = options.keyframes[options.keyframes.length - 1]\n\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state: AnimationState<number> = { done: false, value: origin }\n\n    const {\n        stiffness,\n        damping,\n        mass,\n        duration,\n        velocity,\n        isResolvedFromDuration,\n    } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    })\n\n    const initialVelocity = velocity || 0.0\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass))\n\n    const initialDelta = target - origin\n    const undampedAngularFreq = millisecondsToSeconds(\n        Math.sqrt(stiffness / mass)\n    )\n\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5\n    restSpeed ||= isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default\n    restDelta ||= isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default\n\n    let resolveSpring: (v: number) => number\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio)\n\n        // Underdamped spring\n        resolveSpring = (t: number) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t)\n\n            return (\n                target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t))\n            )\n        }\n    } else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t: number) =>\n            target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t)\n    } else {\n        // Overdamped spring\n        const dampedAngularFreq =\n            undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1)\n\n        resolveSpring = (t: number) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t)\n\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300)\n\n            return (\n                target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq\n            )\n        }\n    }\n\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t: number) => {\n            const current = resolveSpring(t)\n\n            if (!isResolvedFromDuration) {\n                let currentVelocity = t === 0 ? initialVelocity : 0.0\n\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current)\n                }\n\n                const isBelowVelocityThreshold =\n                    Math.abs(currentVelocity) <= restSpeed!\n                const isBelowDisplacementThreshold =\n                    Math.abs(target - current) <= restDelta!\n\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold\n            } else {\n                state.done = t >= duration!\n            }\n\n            state.value = state.done ? target : current\n\n            return state\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(\n                calcGeneratorDuration(generator),\n                maxGeneratorDuration\n            )\n\n            const easing = generateLinearEasing(\n                (progress: number) =>\n                    generator.next(calculatedDuration * progress).value,\n                calculatedDuration,\n                30\n            )\n\n            return calculatedDuration + \"ms \" + easing\n        },\n        toTransition: () => {},\n    }\n\n    return generator\n}\n\nspring.applyToOptions = (options: Transition) => {\n    const generatorOptions = createGeneratorEasing(options as any, 100, spring)\n\n    options.ease = generatorOptions.ease\n    options.duration = secondsToMilliseconds(generatorOptions.duration)\n    options.type = \"keyframes\"\n    return options\n}\n\nexport { spring }\n"]},"metadata":{},"sourceType":"module"}