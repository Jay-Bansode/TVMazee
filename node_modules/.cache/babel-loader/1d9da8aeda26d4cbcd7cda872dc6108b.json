{"ast":null,"code":"import { interpolate, defaultOffset } from 'motion-dom';\nimport { clamp } from 'motion-utils';\nimport { calcInset } from './inset.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { ScrollOffset } from './presets.mjs';\nconst point = {\n  x: 0,\n  y: 0\n};\n\nfunction getTargetSize(target) {\n  return \"getBBox\" in target && target.tagName !== \"svg\" ? target.getBBox() : {\n    width: target.clientWidth,\n    height: target.clientHeight\n  };\n}\n\nfunction resolveOffsets(container, info, options) {\n  const {\n    offset: offsetDefinition = ScrollOffset.All\n  } = options;\n  const {\n    target = container,\n    axis = \"y\"\n  } = options;\n  const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  const inset = target !== container ? calcInset(target, container) : point;\n  /**\n   * Measure the target and container. If they're the same thing then we\n   * use the container's scrollWidth/Height as the target, from there\n   * all other calculations can remain the same.\n   */\n\n  const targetSize = target === container ? {\n    width: container.scrollWidth,\n    height: container.scrollHeight\n  } : getTargetSize(target);\n  const containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  /**\n   * Reset the length of the resolved offset array rather than creating a new one.\n   * TODO: More reusable data structures for targetSize/containerSize would also be good.\n   */\n\n  info[axis].offset.length = 0;\n  /**\n   * Populate the offset array by resolving the user's offset definition into\n   * a list of pixel scroll offets.\n   */\n\n  let hasChanged = !info[axis].interpolate;\n  const numOffsets = offsetDefinition.length;\n\n  for (let i = 0; i < numOffsets; i++) {\n    const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n\n    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n      hasChanged = true;\n    }\n\n    info[axis].offset[i] = offset;\n  }\n  /**\n   * If the pixel scroll offsets have changed, create a new interpolator function\n   * to map scroll value into a progress.\n   */\n\n\n  if (hasChanged) {\n    info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), {\n      clamp: false\n    });\n    info[axis].interpolatorOffsets = [...info[axis].offset];\n  }\n\n  info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));\n}\n\nexport { resolveOffsets };","map":{"version":3,"mappings":";;;;;AAOA,MAAMA,KAAK,GAAG;EAAEC,CAAC,EAAE,CAAL;EAAQC,CAAC,EAAE;AAAX,CAAd;;AAEA,SAASC,aAAT,CAAuBC,MAAvB,EAAsC;EAClC,OAAO,aAAaA,MAAb,IAAuBA,MAAM,CAACC,OAAP,KAAmB,KAA1C,GACAD,MAA6B,CAACE,OAA9B,EADA,GAED;IAAEC,KAAK,EAAEH,MAAM,CAACI,WAAhB;IAA6BC,MAAM,EAAEL,MAAM,CAACM;EAA5C,CAFN;AAGH;;SAEeC,eACZC,WACAC,MACAC,SAA0B;EAE1B,MAAM;IAAEC,MAAM,EAAEC,gBAAgB,GAAGC,YAAY,CAACC;EAA1C,IAAkDJ,OAAxD;EACA,MAAM;IAAEV,MAAM,GAAGQ,SAAX;IAAsBO,IAAI,GAAG;EAA7B,IAAqCL,OAA3C;EACA,MAAMM,WAAW,GAAGD,IAAI,KAAK,GAAT,GAAe,QAAf,GAA0B,OAA9C;EAEA,MAAME,KAAK,GAAGjB,MAAM,KAAKQ,SAAX,GAAuBU,SAAS,CAAClB,MAAD,EAASQ,SAAT,CAAhC,GAAsDZ,KAApE;EAEA;;;;AAIG;;EACH,MAAMuB,UAAU,GACZnB,MAAM,KAAKQ,SAAX,GACM;IAAEL,KAAK,EAAEK,SAAS,CAACY,WAAnB;IAAgCf,MAAM,EAAEG,SAAS,CAACa;EAAlD,CADN,GAEMtB,aAAa,CAACC,MAAD,CAHvB;EAKA,MAAMsB,aAAa,GAAG;IAClBnB,KAAK,EAAEK,SAAS,CAACJ,WADC;IAElBC,MAAM,EAAEG,SAAS,CAACF;EAFA,CAAtB;EAKA;;;AAGG;;EACHG,IAAI,CAACM,IAAD,CAAJ,CAAWJ,MAAX,CAAkBY,MAAlB,GAA2B,CAA3B;EAEA;;;AAGG;;EACH,IAAIC,UAAU,GAAG,CAACf,IAAI,CAACM,IAAD,CAAJ,CAAWU,WAA7B;EAEA,MAAMC,UAAU,GAAGd,gBAAgB,CAACW,MAApC;;EACA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,UAApB,EAAgCC,CAAC,EAAjC,EAAqC;IACjC,MAAMhB,MAAM,GAAGiB,aAAa,CACxBhB,gBAAgB,CAACe,CAAD,CADQ,EAExBL,aAAa,CAACN,WAAD,CAFW,EAGxBG,UAAU,CAACH,WAAD,CAHc,EAIxBC,KAAK,CAACF,IAAD,CAJmB,CAA5B;;IAOA,IAAI,CAACS,UAAD,IAAeb,MAAM,KAAKF,IAAI,CAACM,IAAD,CAAJ,CAAWc,mBAAX,CAAgCF,CAAhC,CAA9B,EAAkE;MAC9DH,UAAU,GAAG,IAAb;IACH;;IAEDf,IAAI,CAACM,IAAD,CAAJ,CAAWJ,MAAX,CAAkBgB,CAAlB,IAAuBhB,MAAvB;EACH;EAED;;;AAGG;;;EACH,IAAIa,UAAJ,EAAgB;IACZf,IAAI,CAACM,IAAD,CAAJ,CAAWU,WAAX,GAAyBA,WAAW,CAChChB,IAAI,CAACM,IAAD,CAAJ,CAAWJ,MADqB,EAEhCmB,aAAa,CAAClB,gBAAD,CAFmB,EAGhC;MAAEmB,KAAK,EAAE;IAAT,CAHgC,CAApC;IAMAtB,IAAI,CAACM,IAAD,CAAJ,CAAWc,mBAAX,GAAiC,CAAC,GAAGpB,IAAI,CAACM,IAAD,CAAJ,CAAWJ,MAAf,CAAjC;EACH;;EAEDF,IAAI,CAACM,IAAD,CAAJ,CAAWiB,QAAX,GAAsBD,KAAK,CACvB,CADuB,EAEvB,CAFuB,EAGvBtB,IAAI,CAACM,IAAD,CAAJ,CAAWU,WAAX,CAAwBhB,IAAI,CAACM,IAAD,CAAJ,CAAWkB,OAAnC,CAHuB,CAA3B;AAKJ","names":["point","x","y","getTargetSize","target","tagName","getBBox","width","clientWidth","height","clientHeight","resolveOffsets","container","info","options","offset","offsetDefinition","ScrollOffset","All","axis","lengthLabel","inset","calcInset","targetSize","scrollWidth","scrollHeight","containerSize","length","hasChanged","interpolate","numOffsets","i","resolveOffset","interpolatorOffsets","defaultOffset","clamp","progress","current"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\render\\dom\\scroll\\offsets\\index.ts"],"sourcesContent":["import { defaultOffset, interpolate } from \"motion-dom\"\nimport { clamp } from \"motion-utils\"\nimport { ScrollInfo, ScrollInfoOptions } from \"../types\"\nimport { calcInset } from \"./inset\"\nimport { resolveOffset } from \"./offset\"\nimport { ScrollOffset } from \"./presets\"\n\nconst point = { x: 0, y: 0 }\n\nfunction getTargetSize(target: Element) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? (target as SVGGraphicsElement).getBBox()\n        : { width: target.clientWidth, height: target.clientHeight }\n}\n\nexport function resolveOffsets(\n    container: Element,\n    info: ScrollInfo,\n    options: ScrollInfoOptions\n) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options\n    const { target = container, axis = \"y\" } = options\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\"\n\n    const inset = target !== container ? calcInset(target, container) : point\n\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize =\n        target === container\n            ? { width: container.scrollWidth, height: container.scrollHeight }\n            : getTargetSize(target)\n\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    }\n\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0\n\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate\n\n    const numOffsets = offsetDefinition.length\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(\n            offsetDefinition[i],\n            containerSize[lengthLabel],\n            targetSize[lengthLabel],\n            inset[axis]\n        )\n\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets![i]) {\n            hasChanged = true\n        }\n\n        info[axis].offset[i] = offset\n    }\n\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(\n            info[axis].offset,\n            defaultOffset(offsetDefinition),\n            { clamp: false }\n        )\n\n        info[axis].interpolatorOffsets = [...info[axis].offset]\n    }\n\n    info[axis].progress = clamp(\n        0,\n        1,\n        info[axis].interpolate!(info[axis].current)\n    )\n}\n"]},"metadata":{},"sourceType":"module"}