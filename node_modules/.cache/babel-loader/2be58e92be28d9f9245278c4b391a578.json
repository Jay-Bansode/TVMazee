{"ast":null,"code":"import { clamp } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { NativeAnimation } from './NativeAnimation.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { replaceStringEasing } from './waapi/utils/unsupported-easing.mjs';\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\n\nconst sampleDelta = 10; //ms\n\nclass NativeAnimationExtended extends NativeAnimation {\n  constructor(options) {\n    /**\n     * The base NativeAnimation function only supports a subset\n     * of Motion easings, and WAAPI also only supports some\n     * easing functions via string/cubic-bezier definitions.\n     *\n     * This function replaces those unsupported easing functions\n     * with a JS easing function. This will later get compiled\n     * to a linear() easing function.\n     */\n    replaceStringEasing(options);\n    /**\n     * Ensure we replace the transition type with a generator function\n     * before passing to WAAPI.\n     *\n     * TODO: Does this have a better home? It could be shared with\n     * JSAnimation.\n     */\n\n    replaceTransitionType(options);\n    super(options);\n\n    if (options.startTime !== undefined) {\n      this.startTime = options.startTime;\n    }\n\n    this.options = options;\n  }\n  /**\n   * WAAPI doesn't natively have any interruption capabilities.\n   *\n   * Rather than read committed styles back out of the DOM, we can\n   * create a renderless JS animation and sample it twice to calculate\n   * its current value, \"previous\" value, and therefore allow\n   * Motion to calculate velocity for any subsequent animation.\n   */\n\n\n  updateMotionValue(value) {\n    const {\n      motionValue,\n      onUpdate,\n      onComplete,\n      element,\n      ...options\n    } = this.options;\n    if (!motionValue) return;\n\n    if (value !== undefined) {\n      motionValue.set(value);\n      return;\n    }\n\n    const sampleAnimation = new JSAnimation({ ...options,\n      autoplay: false\n    });\n    /**\n     * Use wall-clock elapsed time for sampling.\n     * Under CPU load, WAAPI's currentTime may not reflect actual\n     * elapsed time, causing incorrect sampling and visual jumps.\n     */\n\n    const sampleTime = Math.max(sampleDelta, time.now() - this.startTime);\n    const delta = clamp(0, sampleDelta, sampleTime - sampleDelta);\n    motionValue.setWithVelocity(sampleAnimation.sample(Math.max(0, sampleTime - delta)).value, sampleAnimation.sample(sampleTime).value, delta);\n    sampleAnimation.stop();\n  }\n\n}\n\nexport { NativeAnimationExtended };","map":{"version":3,"mappings":";;;;;;AAWA;;;;AAIG;;AACH,MAAMA,WAAW,GAAG,EAApB,C,CAAsB;;AAEhB,MAAOC,uBAAP,SAEIC,eAFJ,CAEsB;EAGxBC,YAAYC,OAAZ,EAAsD;IAClD;;;;;;;;AAQG;IACHC,mBAAmB,CAACD,OAAD,CAAnB;IAEA;;;;;;AAMG;;IACHE,qBAAqB,CAACF,OAAD,CAArB;IAEA,MAAMA,OAAN;;IAEA,IAAIA,OAAO,CAACG,SAAR,KAAsBC,SAA1B,EAAqC;MACjC,KAAKD,SAAL,GAAiBH,OAAO,CAACG,SAAzB;IACH;;IAED,KAAKH,OAAL,GAAeA,OAAf;EACH;EAED;;;;;;;AAOG;;;EACHK,iBAAiB,CAACC,KAAD,EAAU;IACvB,MAAM;MAAEC,WAAF;MAAeC,QAAf;MAAyBC,UAAzB;MAAqCC,OAArC;MAA8C,GAAGV;IAAjD,IACF,KAAKA,OADT;IAGA,IAAI,CAACO,WAAL,EAAkB;;IAElB,IAAID,KAAK,KAAKF,SAAd,EAAyB;MACrBG,WAAW,CAACI,GAAZ,CAAgBL,KAAhB;MACA;IACH;;IAED,MAAMM,eAAe,GAAG,IAAIC,WAAJ,CAAgB,EACpC,GAAGb,OADiC;MAEpCc,QAAQ,EAAE;IAF0B,CAAhB,CAAxB;IAKA;;;;AAIG;;IACH,MAAMC,UAAU,GAAGC,IAAI,CAACC,GAAL,CAASrB,WAAT,EAAsBsB,IAAI,CAACC,GAAL,KAAa,KAAKhB,SAAxC,CAAnB;IACA,MAAMiB,KAAK,GAAGC,KAAK,CAAC,CAAD,EAAIzB,WAAJ,EAAiBmB,UAAU,GAAGnB,WAA9B,CAAnB;IAEAW,WAAW,CAACe,eAAZ,CACIV,eAAe,CAACW,MAAhB,CAAuBP,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYF,UAAU,GAAGK,KAAzB,CAAvB,EAAwDd,KAD5D,EAEIM,eAAe,CAACW,MAAhB,CAAuBR,UAAvB,EAAmCT,KAFvC,EAGIc,KAHJ;IAMAR,eAAe,CAACY,IAAhB;EACH;;AAxEuB","names":["sampleDelta","NativeAnimationExtended","NativeAnimation","constructor","options","replaceStringEasing","replaceTransitionType","startTime","undefined","updateMotionValue","value","motionValue","onUpdate","onComplete","element","set","sampleAnimation","JSAnimation","autoplay","sampleTime","Math","max","time","now","delta","clamp","setWithVelocity","sample","stop"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\animation\\NativeAnimationExtended.ts"],"sourcesContent":["import { clamp } from \"motion-utils\"\nimport { time } from \"../frameloop/sync-time\"\nimport { JSAnimation } from \"./JSAnimation\"\nimport { NativeAnimation, NativeAnimationOptions } from \"./NativeAnimation\"\nimport { AnyResolvedKeyframe, ValueAnimationOptions } from \"./types\"\nimport { replaceTransitionType } from \"./utils/replace-transition-type\"\nimport { replaceStringEasing } from \"./waapi/utils/unsupported-easing\"\n\nexport type NativeAnimationOptionsExtended<T extends AnyResolvedKeyframe> =\n    NativeAnimationOptions & ValueAnimationOptions<T> & NativeAnimationOptions\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10 //ms\n\nexport class NativeAnimationExtended<\n    T extends AnyResolvedKeyframe\n> extends NativeAnimation<T> {\n    options: NativeAnimationOptionsExtended<T>\n\n    constructor(options: NativeAnimationOptionsExtended<T>) {\n        /**\n         * The base NativeAnimation function only supports a subset\n         * of Motion easings, and WAAPI also only supports some\n         * easing functions via string/cubic-bezier definitions.\n         *\n         * This function replaces those unsupported easing functions\n         * with a JS easing function. This will later get compiled\n         * to a linear() easing function.\n         */\n        replaceStringEasing(options)\n\n        /**\n         * Ensure we replace the transition type with a generator function\n         * before passing to WAAPI.\n         *\n         * TODO: Does this have a better home? It could be shared with\n         * JSAnimation.\n         */\n        replaceTransitionType(options)\n\n        super(options)\n\n        if (options.startTime !== undefined) {\n            this.startTime = options.startTime\n        }\n\n        this.options = options\n    }\n\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * Rather than read committed styles back out of the DOM, we can\n     * create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to calculate velocity for any subsequent animation.\n     */\n    updateMotionValue(value?: T) {\n        const { motionValue, onUpdate, onComplete, element, ...options } =\n            this.options\n\n        if (!motionValue) return\n\n        if (value !== undefined) {\n            motionValue.set(value)\n            return\n        }\n\n        const sampleAnimation = new JSAnimation({\n            ...options,\n            autoplay: false,\n        })\n\n        /**\n         * Use wall-clock elapsed time for sampling.\n         * Under CPU load, WAAPI's currentTime may not reflect actual\n         * elapsed time, causing incorrect sampling and visual jumps.\n         */\n        const sampleTime = Math.max(sampleDelta, time.now() - this.startTime)\n        const delta = clamp(0, sampleDelta, sampleTime - sampleDelta)\n\n        motionValue.setWithVelocity(\n            sampleAnimation.sample(Math.max(0, sampleTime - delta)).value,\n            sampleAnimation.sample(sampleTime).value,\n            delta\n        )\n\n        sampleAnimation.stop()\n    }\n}\n"]},"metadata":{},"sourceType":"module"}