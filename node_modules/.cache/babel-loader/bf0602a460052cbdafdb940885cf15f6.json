{"ast":null,"code":"import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { calcChildStagger } from '../utils/calc-child-stagger.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\n\nfunction animateVariant(visualElement, variant) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const resolved = resolveVariant(visualElement, variant, options.type === \"exit\" ? visualElement.presenceContext?.custom : undefined);\n  let {\n    transition = visualElement.getDefaultTransition() || {}\n  } = resolved || {};\n\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n\n  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? function () {\n    let forwardDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const {\n      delayChildren = 0,\n      staggerChildren,\n      staggerDirection\n    } = transition;\n    return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);\n  } : () => Promise.resolve();\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n\n  const {\n    when\n  } = transition;\n\n  if (when) {\n    const [first, last] = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];\n    return first().then(() => last());\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\n\nfunction animateChildren(visualElement, variant) {\n  let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let delayChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let staggerChildren = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let staggerDirection = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n  let options = arguments.length > 6 ? arguments[6] : undefined;\n  const animations = [];\n\n  for (const child of visualElement.variantChildren) {\n    child.notify(\"AnimationStart\", variant);\n    animations.push(animateVariant(child, variant, { ...options,\n      delay: delay + (typeof delayChildren === \"function\" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)\n    }).then(() => child.notify(\"AnimationComplete\", variant)));\n  }\n\n  return Promise.all(animations);\n}\n\nexport { animateVariant };","map":{"version":3,"mappings":";;;;AAOM,SAAUA,cAAV,CACFC,aADE,EAEFC,OAFE,EAGyC;EAAA,IAA3CC,OAA2C,uEAAF,EAAE;EAE3C,MAAMC,QAAQ,GAAGC,cAAc,CAC3BJ,aAD2B,EAE3BC,OAF2B,EAG3BC,OAAO,CAACG,IAAR,KAAiB,MAAjB,GACML,aAAa,CAACM,eAAd,EAA+BC,MADrC,GAEMC,SALqB,CAA/B;EAQA,IAAI;IAAEC,UAAU,GAAGT,aAAa,CAACU,oBAAd,MAAwC;EAAvD,IACAP,QAAQ,IAAI,EADhB;;EAGA,IAAID,OAAO,CAACS,kBAAZ,EAAgC;IAC5BF,UAAU,GAAGP,OAAO,CAACS,kBAArB;EACH;EAED;;;AAGG;;;EACH,MAAMC,YAAY,GAAuBT,QAAQ,GAC3C,MAAMU,OAAO,CAACC,GAAR,CAAYC,aAAa,CAACf,aAAD,EAAgBG,QAAhB,EAA0BD,OAA1B,CAAzB,CADqC,GAE3C,MAAMW,OAAO,CAACG,OAAR,EAFZ;EAIA;;;AAGG;;EACH,MAAMC,kBAAkB,GACpBjB,aAAa,CAACkB,eAAd,IAAiClB,aAAa,CAACkB,eAAd,CAA8BC,IAA/D,GACM,YAAqB;IAAA,IAApBC,YAAoB,uEAAL,CAAK;IACjB,MAAM;MACFC,aAAa,GAAG,CADd;MAEFC,eAFE;MAGFC;IAHE,IAIFd,UAJJ;IAMA,OAAOe,eAAe,CAClBxB,aADkB,EAElBC,OAFkB,EAGlBmB,YAHkB,EAIlBC,aAJkB,EAKlBC,eALkB,EAMlBC,gBANkB,EAOlBrB,OAPkB,CAAtB;EASH,CAjBP,GAkBM,MAAMW,OAAO,CAACG,OAAR,EAnBhB;EAqBA;;;AAGG;;EACH,MAAM;IAAES;EAAF,IAAWhB,UAAjB;;EACA,IAAIgB,IAAJ,EAAU;IACN,MAAM,CAACC,KAAD,EAAQC,IAAR,IACFF,IAAI,KAAK,gBAAT,GACM,CAACb,YAAD,EAAeK,kBAAf,CADN,GAEM,CAACA,kBAAD,EAAqBL,YAArB,CAHV;IAKA,OAAOc,KAAK,GAAGE,IAAR,CAAa,MAAMD,IAAI,EAAvB,CAAP;EACH,CAPD,MAOO;IACH,OAAOd,OAAO,CAACC,GAAR,CAAY,CAACF,YAAY,EAAb,EAAiBK,kBAAkB,CAACf,OAAO,CAAC2B,KAAT,CAAnC,CAAZ,CAAP;EACH;AACJ;;AAED,SAASL,eAAT,CACIxB,aADJ,EAEIC,OAFJ,EAO0C;EAAA,IAJtC4B,KAIsC,uEAJtB,CAIsB;EAAA,IAHtCR,aAGsC,uEAHU,CAGV;EAAA,IAFtCC,eAEsC,uEAFpB,CAEoB;EAAA,IADtCC,gBACsC,uEADnB,CACmB;EAAA,IAAtCrB,OAAsC;EAEtC,MAAM4B,UAAU,GAAmB,EAAnC;;EAEA,KAAK,MAAMC,KAAX,IAAoB/B,aAAa,CAACkB,eAAlC,EAAoD;IAChDa,KAAK,CAACC,MAAN,CAAa,gBAAb,EAA+B/B,OAA/B;IACA6B,UAAU,CAACG,IAAX,CACIlC,cAAc,CAACgC,KAAD,EAAQ9B,OAAR,EAAiB,EAC3B,GAAGC,OADwB;MAE3B2B,KAAK,EACDA,KAAK,IACJ,OAAOR,aAAP,KAAyB,UAAzB,GAAsC,CAAtC,GAA0CA,aADtC,CAAL,GAEAa,gBAAgB,CACZlC,aAAa,CAACkB,eADF,EAEZa,KAFY,EAGZV,aAHY,EAIZC,eAJY,EAKZC,gBALY;IALO,CAAjB,CAAd,CAYGK,IAZH,CAYQ,MAAMG,KAAK,CAACC,MAAN,CAAa,mBAAb,EAAkC/B,OAAlC,CAZd,CADJ;EAeH;;EAED,OAAOY,OAAO,CAACC,GAAR,CAAYgB,UAAZ,CAAP;AACJ","names":["animateVariant","visualElement","variant","options","resolved","resolveVariant","type","presenceContext","custom","undefined","transition","getDefaultTransition","transitionOverride","getAnimation","Promise","all","animateTarget","resolve","getChildAnimations","variantChildren","size","forwardDelay","delayChildren","staggerChildren","staggerDirection","animateChildren","when","first","last","then","delay","animations","child","notify","push","calcChildStagger"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\animation\\interfaces\\visual-element-variant.ts"],"sourcesContent":["import { resolveVariant } from \"../../render/utils/resolve-dynamic-variants\"\nimport { calcChildStagger } from \"../utils/calc-child-stagger\"\nimport type { VisualElementAnimationOptions } from \"./types\"\nimport { animateTarget } from \"./visual-element-target\"\nimport type { DynamicOption } from \"../types\"\nimport type { VisualElement } from \"../../render/VisualElement\"\n\nexport function animateVariant(\n    visualElement: VisualElement,\n    variant: string,\n    options: VisualElementAnimationOptions = {}\n): Promise<any> {\n    const resolved = resolveVariant(\n        visualElement,\n        variant,\n        options.type === \"exit\"\n            ? visualElement.presenceContext?.custom\n            : undefined\n    )\n\n    let { transition = visualElement.getDefaultTransition() || {} } =\n        resolved || {}\n\n    if (options.transitionOverride) {\n        transition = options.transitionOverride\n    }\n\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation: () => Promise<any> = resolved\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\n        : () => Promise.resolve()\n\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations =\n        visualElement.variantChildren && visualElement.variantChildren.size\n            ? (forwardDelay = 0) => {\n                  const {\n                      delayChildren = 0,\n                      staggerChildren,\n                      staggerDirection,\n                  } = transition\n\n                  return animateChildren(\n                      visualElement,\n                      variant,\n                      forwardDelay,\n                      delayChildren,\n                      staggerChildren,\n                      staggerDirection,\n                      options\n                  )\n              }\n            : () => Promise.resolve()\n\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition\n    if (when) {\n        const [first, last] =\n            when === \"beforeChildren\"\n                ? [getAnimation, getChildAnimations]\n                : [getChildAnimations, getAnimation]\n\n        return first().then(() => last())\n    } else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)])\n    }\n}\n\nfunction animateChildren(\n    visualElement: VisualElement,\n    variant: string,\n    delay: number = 0,\n    delayChildren: number | DynamicOption<number> = 0,\n    staggerChildren = 0,\n    staggerDirection = 1,\n    options: VisualElementAnimationOptions\n) {\n    const animations: Promise<any>[] = []\n\n    for (const child of visualElement.variantChildren!) {\n        child.notify(\"AnimationStart\", variant)\n        animations.push(\n            animateVariant(child, variant, {\n                ...options,\n                delay:\n                    delay +\n                    (typeof delayChildren === \"function\" ? 0 : delayChildren) +\n                    calcChildStagger(\n                        visualElement.variantChildren!,\n                        child,\n                        delayChildren,\n                        staggerChildren,\n                        staggerDirection\n                    ),\n            }).then(() => child.notify(\"AnimationComplete\", variant))\n        )\n    }\n\n    return Promise.all(animations)\n}\n"]},"metadata":{},"sourceType":"module"}