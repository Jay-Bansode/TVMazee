{"ast":null,"code":"import { animateVisualElement, setTarget } from 'motion-dom';\nimport { invariant } from 'motion-utils';\n\nfunction stopAnimation(visualElement) {\n  visualElement.values.forEach(value => value.stop());\n}\n\nfunction setVariants(visualElement, variantLabels) {\n  const reversedLabels = [...variantLabels].reverse();\n  reversedLabels.forEach(key => {\n    const variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n\n    if (visualElement.variantChildren) {\n      visualElement.variantChildren.forEach(child => {\n        setVariants(child, variantLabels);\n      });\n    }\n  });\n}\n\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\n/**\n * @public\n */\n\n\nfunction animationControls() {\n  /**\n   * Track whether the host component has mounted.\n   */\n  let hasMounted = false;\n  /**\n   * A collection of linked component animation controls.\n   */\n\n  const subscribers = new Set();\n  const controls = {\n    subscribe(visualElement) {\n      subscribers.add(visualElement);\n      return () => void subscribers.delete(visualElement);\n    },\n\n    start(definition, transitionOverride) {\n      invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      const animations = [];\n      subscribers.forEach(visualElement => {\n        animations.push(animateVisualElement(visualElement, definition, {\n          transitionOverride\n        }));\n      });\n      return Promise.all(animations);\n    },\n\n    set(definition) {\n      invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach(visualElement => {\n        setValues(visualElement, definition);\n      });\n    },\n\n    stop() {\n      subscribers.forEach(visualElement => {\n        stopAnimation(visualElement);\n      });\n    },\n\n    mount() {\n      hasMounted = true;\n      return () => {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n\n  };\n  return controls;\n}\n\nexport { animationControls, setValues };","map":{"version":3,"mappings":";;;AASA,SAASA,aAAT,CAAuBC,aAAvB,EAAmD;EAC/CA,aAAa,CAACC,MAAd,CAAqBC,OAArB,CAA8BC,KAAD,IAAWA,KAAK,CAACC,IAAN,EAAxC;AACH;;AAED,SAASC,WAAT,CAAqBL,aAArB,EAAmDM,aAAnD,EAA0E;EACtE,MAAMC,cAAc,GAAG,CAAC,GAAGD,aAAJ,EAAmBE,OAAnB,EAAvB;EAEAD,cAAc,CAACL,OAAf,CAAwBO,GAAD,IAAQ;IAC3B,MAAMC,OAAO,GAAGV,aAAa,CAACW,UAAd,CAAyBF,GAAzB,CAAhB;IACAC,OAAO,IAAIE,SAAS,CAACZ,aAAD,EAAgBU,OAAhB,CAApB;;IAEA,IAAIV,aAAa,CAACa,eAAlB,EAAmC;MAC/Bb,aAAa,CAACa,eAAd,CAA8BX,OAA9B,CAAuCY,KAAD,IAAU;QAC5CT,WAAW,CAACS,KAAD,EAAQR,aAAR,CAAX;MACH,CAFD;IAGH;EACJ,CATD;AAUH;;AAEe,mBACZN,aADY,EAEZe,UAFY,EAEmB;EAE/B,IAAIC,KAAK,CAACC,OAAN,CAAcF,UAAd,CAAJ,EAA+B;IAC3B,OAAOV,WAAW,CAACL,aAAD,EAAgBe,UAAhB,CAAlB;EACH,CAFD,MAEO,IAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;IACvC,OAAOV,WAAW,CAACL,aAAD,EAAgB,CAACe,UAAD,CAAhB,CAAlB;EACH,CAFM,MAEA;IACHH,SAAS,CAACZ,aAAD,EAAgBe,UAAhB,CAAT;EACH;AACJ;AAED;;AAEG;;;SACaG,oBAAiB;EAC7B;;AAEG;EACH,IAAIC,UAAU,GAAG,KAAjB;EAEA;;AAEG;;EACH,MAAMC,WAAW,GAAG,IAAIC,GAAJ,EAApB;EAEA,MAAMC,QAAQ,GAA4B;IACtCC,SAAS,CAACvB,aAAD,EAAc;MACnBoB,WAAW,CAACI,GAAZ,CAAgBxB,aAAhB;MACA,OAAO,MAAM,KAAKoB,WAAW,CAACK,MAAZ,CAAmBzB,aAAnB,CAAlB;IACH,CAJqC;;IAMtC0B,KAAK,CAACX,UAAD,EAAaY,kBAAb,EAA+B;MAChCC,SAAS,CACLT,UADK,EAEL,iHAFK,CAAT;MAKA,MAAMU,UAAU,GAAwB,EAAxC;MACAT,WAAW,CAAClB,OAAZ,CAAqBF,aAAD,IAAkB;QAClC6B,UAAU,CAACC,IAAX,CACIC,oBAAoB,CAAC/B,aAAD,EAAgBe,UAAhB,EAA4B;UAC5CY;QAD4C,CAA5B,CADxB;MAKH,CAND;MAQA,OAAOK,OAAO,CAACC,GAAR,CAAYJ,UAAZ,CAAP;IACH,CAtBqC;;IAwBtCK,GAAG,CAACnB,UAAD,EAAW;MACVa,SAAS,CACLT,UADK,EAEL,+GAFK,CAAT;MAKA,OAAOC,WAAW,CAAClB,OAAZ,CAAqBF,aAAD,IAAkB;QACzCmC,SAAS,CAACnC,aAAD,EAAgBe,UAAhB,CAAT;MACH,CAFM,CAAP;IAGH,CAjCqC;;IAmCtCX,IAAI;MACAgB,WAAW,CAAClB,OAAZ,CAAqBF,aAAD,IAAkB;QAClCD,aAAa,CAACC,aAAD,CAAb;MACH,CAFD;IAGH,CAvCqC;;IAyCtCoC,KAAK;MACDjB,UAAU,GAAG,IAAb;MAEA,OAAO,MAAK;QACRA,UAAU,GAAG,KAAb;QACAG,QAAQ,CAAClB,IAAT;MACH,CAHD;IAIH;;EAhDqC,CAA1C;EAmDA,OAAOkB,QAAP;AACJ","names":["stopAnimation","visualElement","values","forEach","value","stop","setVariants","variantLabels","reversedLabels","reverse","key","variant","getVariant","setTarget","variantChildren","child","definition","Array","isArray","animationControls","hasMounted","subscribers","Set","controls","subscribe","add","delete","start","transitionOverride","invariant","animations","push","animateVisualElement","Promise","all","set","setValues","mount"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\animation\\hooks\\animation-controls.ts"],"sourcesContent":["import {\n    animateVisualElement,\n    setTarget,\n    type AnimationDefinition,\n    type LegacyAnimationControls,\n    type VisualElement,\n} from \"motion-dom\"\nimport { invariant } from \"motion-utils\"\n\nfunction stopAnimation(visualElement: VisualElement) {\n    visualElement.values.forEach((value) => value.stop())\n}\n\nfunction setVariants(visualElement: VisualElement, variantLabels: string[]) {\n    const reversedLabels = [...variantLabels].reverse()\n\n    reversedLabels.forEach((key) => {\n        const variant = visualElement.getVariant(key)\n        variant && setTarget(visualElement, variant)\n\n        if (visualElement.variantChildren) {\n            visualElement.variantChildren.forEach((child) => {\n                setVariants(child, variantLabels)\n            })\n        }\n    })\n}\n\nexport function setValues(\n    visualElement: VisualElement,\n    definition: AnimationDefinition\n) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition)\n    } else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition])\n    } else {\n        setTarget(visualElement, definition as any)\n    }\n}\n\n/**\n * @public\n */\nexport function animationControls(): LegacyAnimationControls {\n    /**\n     * Track whether the host component has mounted.\n     */\n    let hasMounted = false\n\n    /**\n     * A collection of linked component animation controls.\n     */\n    const subscribers = new Set<VisualElement>()\n\n    const controls: LegacyAnimationControls = {\n        subscribe(visualElement) {\n            subscribers.add(visualElement)\n            return () => void subscribers.delete(visualElement)\n        },\n\n        start(definition, transitionOverride) {\n            invariant(\n                hasMounted,\n                \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\"\n            )\n\n            const animations: Array<Promise<any>> = []\n            subscribers.forEach((visualElement) => {\n                animations.push(\n                    animateVisualElement(visualElement, definition, {\n                        transitionOverride,\n                    })\n                )\n            })\n\n            return Promise.all(animations)\n        },\n\n        set(definition) {\n            invariant(\n                hasMounted,\n                \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\"\n            )\n\n            return subscribers.forEach((visualElement) => {\n                setValues(visualElement, definition)\n            })\n        },\n\n        stop() {\n            subscribers.forEach((visualElement) => {\n                stopAnimation(visualElement)\n            })\n        },\n\n        mount() {\n            hasMounted = true\n\n            return () => {\n                hasMounted = false\n                controls.stop()\n            }\n        },\n    }\n\n    return controls\n}\n"]},"metadata":{},"sourceType":"module"}