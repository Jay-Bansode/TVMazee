{"ast":null,"code":"import { positionalKeys } from '../../render/utils/keys-position.mjs';\nimport { findDimensionValueType } from '../../value/types/dimensions.mjs';\nimport { getVariableValue } from '../utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken, containsCSSVariable } from '../utils/is-css-variable.mjs';\nimport { KeyframeResolver } from './KeyframesResolver.mjs';\nimport { isNone } from './utils/is-none.mjs';\nimport { makeNoneKeyframesAnimatable } from './utils/make-none-animatable.mjs';\nimport { positionalValues, isNumOrPxType } from './utils/unit-conversion.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n  constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n    super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n  }\n\n  readKeyframes() {\n    const {\n      unresolvedKeyframes,\n      element,\n      name\n    } = this;\n    if (!element || !element.current) return;\n    super.readKeyframes();\n    /**\n     * If any keyframe is a CSS variable, we need to find its value by sampling the element\n     */\n\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      let keyframe = unresolvedKeyframes[i];\n\n      if (typeof keyframe === \"string\") {\n        keyframe = keyframe.trim();\n\n        if (isCSSVariableToken(keyframe)) {\n          const resolved = getVariableValue(keyframe, element.current);\n\n          if (resolved !== undefined) {\n            unresolvedKeyframes[i] = resolved;\n          }\n\n          if (i === unresolvedKeyframes.length - 1) {\n            this.finalKeyframe = keyframe;\n          }\n        }\n      }\n    }\n    /**\n     * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n     * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n     * have a far bigger performance impact.\n     */\n\n\n    this.resolveNoneKeyframes();\n    /**\n     * Check to see if unit type has changed. If so schedule jobs that will\n     * temporarily set styles to the destination keyframes.\n     * Skip if we have more than two keyframes or this isn't a positional value.\n     * TODO: We can throw if there are multiple keyframes and the value type changes.\n     */\n\n    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n      return;\n    }\n\n    const [origin, target] = unresolvedKeyframes;\n    const originType = findDimensionValueType(origin);\n    const targetType = findDimensionValueType(target);\n    /**\n     * If one keyframe contains embedded CSS variables (e.g. in calc()) and the other\n     * doesn't, we need to measure to convert to pixels. This handles GitHub issue #3410.\n     */\n\n    const originHasVar = containsCSSVariable(origin);\n    const targetHasVar = containsCSSVariable(target);\n\n    if (originHasVar !== targetHasVar && positionalValues[name]) {\n      this.needsMeasurement = true;\n      return;\n    }\n    /**\n     * Either we don't recognise these value types or we can animate between them.\n     */\n\n\n    if (originType === targetType) return;\n    /**\n     * If both values are numbers or pixels, we can animate between them by\n     * converting them to numbers.\n     */\n\n    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n      for (let i = 0; i < unresolvedKeyframes.length; i++) {\n        const value = unresolvedKeyframes[i];\n\n        if (typeof value === \"string\") {\n          unresolvedKeyframes[i] = parseFloat(value);\n        }\n      }\n    } else if (positionalValues[name]) {\n      /**\n       * Else, the only way to resolve this is by measuring the element.\n       */\n      this.needsMeasurement = true;\n    }\n  }\n\n  resolveNoneKeyframes() {\n    const {\n      unresolvedKeyframes,\n      name\n    } = this;\n    const noneKeyframeIndexes = [];\n\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      if (unresolvedKeyframes[i] === null || isNone(unresolvedKeyframes[i])) {\n        noneKeyframeIndexes.push(i);\n      }\n    }\n\n    if (noneKeyframeIndexes.length) {\n      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n    }\n  }\n\n  measureInitialState() {\n    const {\n      element,\n      unresolvedKeyframes,\n      name\n    } = this;\n    if (!element || !element.current) return;\n\n    if (name === \"height\") {\n      this.suspendedScrollY = window.pageYOffset;\n    }\n\n    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n    unresolvedKeyframes[0] = this.measuredOrigin; // Set final key frame to measure after next render\n\n    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n\n    if (measureKeyframe !== undefined) {\n      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n    }\n  }\n\n  measureEndState() {\n    const {\n      element,\n      name,\n      unresolvedKeyframes\n    } = this;\n    if (!element || !element.current) return;\n    const value = element.getValue(name);\n    value && value.jump(this.measuredOrigin, false);\n    const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n\n    if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n      this.finalKeyframe = finalKeyframe;\n    } // If we removed transform values, reapply them before the next render\n\n\n    if (this.removedTransforms?.length) {\n      this.removedTransforms.forEach(_ref => {\n        let [unsetTransformName, unsetTransformValue] = _ref;\n        element.getValue(unsetTransformName).set(unsetTransformValue);\n      });\n    }\n\n    this.resolveNoneKeyframes();\n  }\n\n}\n\nexport { DOMKeyframesResolver };","map":{"version":3,"mappings":"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","names":["DOMKeyframesResolver","KeyframeResolver","constructor","onComplete","name","motionValue","element","unresolvedKeyframes","readKeyframes","current","i","length","keyframe","trim","isCSSVariableToken","resolved","getVariableValue","undefined","finalKeyframe","resolveNoneKeyframes","positionalKeys","has","origin","target","originType","findDimensionValueType","targetType","originHasVar","containsCSSVariable","targetHasVar","positionalValues","needsMeasurement","isNumOrPxType","value","parseFloat","noneKeyframeIndexes","isNone","push","makeNoneKeyframesAnimatable","measureInitialState","suspendedScrollY","window","pageYOffset","measuredOrigin","measureViewportBox","getComputedStyle","measureKeyframe","getValue","jump","measureEndState","finalKeyframeIndex","removedTransforms","forEach","unsetTransformName","unsetTransformValue","set"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\animation\\keyframes\\DOMKeyframesResolver.ts"],"sourcesContent":["import { positionalKeys } from \"../../render/utils/keys-position\"\nimport { MotionValue } from \"../../value\"\nimport { findDimensionValueType } from \"../../value/types/dimensions\"\nimport { AnyResolvedKeyframe } from \"../types\"\nimport { getVariableValue } from \"../utils/css-variables-conversion\"\nimport {\n    containsCSSVariable,\n    isCSSVariableToken,\n} from \"../utils/is-css-variable\"\nimport {\n    KeyframeResolver,\n    OnKeyframesResolved,\n    UnresolvedKeyframes,\n} from \"./KeyframesResolver\"\nimport { WithRender } from \"./types\"\nimport { isNone } from \"./utils/is-none\"\nimport { makeNoneKeyframesAnimatable } from \"./utils/make-none-animatable\"\nimport { isNumOrPxType, positionalValues } from \"./utils/unit-conversion\"\n\nexport class DOMKeyframesResolver<\n    T extends AnyResolvedKeyframe\n> extends KeyframeResolver<T> {\n    name: string\n    element?: WithRender\n\n    private removedTransforms?: [string, AnyResolvedKeyframe][]\n    private measuredOrigin?: AnyResolvedKeyframe\n\n    constructor(\n        unresolvedKeyframes: UnresolvedKeyframes<AnyResolvedKeyframe>,\n        onComplete: OnKeyframesResolved<T>,\n        name?: string,\n        motionValue?: MotionValue<T>,\n        element?: WithRender\n    ) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true)\n    }\n\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this\n\n        if (!element || !element.current) return\n\n        super.readKeyframes()\n\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i]\n\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim()\n\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current)\n\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved as T\n                    }\n\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe as T\n                    }\n                }\n            }\n        }\n\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes()\n\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return\n        }\n\n        const [origin, target] = unresolvedKeyframes\n        const originType = findDimensionValueType(origin)\n        const targetType = findDimensionValueType(target)\n\n        /**\n         * If one keyframe contains embedded CSS variables (e.g. in calc()) and the other\n         * doesn't, we need to measure to convert to pixels. This handles GitHub issue #3410.\n         */\n        const originHasVar = containsCSSVariable(origin)\n        const targetHasVar = containsCSSVariable(target)\n\n        if (originHasVar !== targetHasVar && positionalValues[name]) {\n            this.needsMeasurement = true\n            return\n        }\n\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType) return\n\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i]\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value as string)\n                }\n            }\n        } else if (positionalValues[name]) {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true\n        }\n    }\n\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this\n\n        const noneKeyframeIndexes: number[] = []\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (\n                unresolvedKeyframes[i] === null ||\n                isNone(unresolvedKeyframes[i])\n            ) {\n                noneKeyframeIndexes.push(i)\n            }\n        }\n\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(\n                unresolvedKeyframes,\n                noneKeyframeIndexes,\n                name\n            )\n        }\n    }\n\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this\n\n        if (!element || !element.current) return\n\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset\n        }\n\n        this.measuredOrigin = positionalValues[name](\n            element.measureViewportBox(),\n            window.getComputedStyle(element.current)\n        )\n\n        unresolvedKeyframes[0] = this.measuredOrigin\n\n        // Set final key frame to measure after next render\n        const measureKeyframe =\n            unresolvedKeyframes[unresolvedKeyframes.length - 1]\n\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false)\n        }\n    }\n\n    measureEndState() {\n        const { element, name, unresolvedKeyframes } = this\n\n        if (!element || !element.current) return\n\n        const value = element.getValue(name)\n        value && value.jump(this.measuredOrigin, false)\n\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex]\n\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](\n            element.measureViewportBox(),\n            window.getComputedStyle(element.current)\n        ) as any\n\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe as T\n        }\n\n        // If we removed transform values, reapply them before the next render\n        if (this.removedTransforms?.length) {\n            this.removedTransforms.forEach(\n                ([unsetTransformName, unsetTransformValue]) => {\n                    element\n                        .getValue(unsetTransformName)!\n                        .set(unsetTransformValue)\n                }\n            )\n        }\n\n        this.resolveNoneKeyframes()\n    }\n}\n"]},"metadata":{},"sourceType":"module"}