{"ast":null,"code":"import { memo } from 'motion-utils';\n/**\n * A list of values that can be hardware-accelerated.\n */\n\nconst acceleratedValues = new Set([\"opacity\", \"clipPath\", \"filter\", \"transform\" // TODO: Could be re-enabled now we have support for linear() easing\n// \"background-color\"\n]);\nconst supportsWaapi = /*@__PURE__*/memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n\nfunction supportsBrowserAnimation(options) {\n  const {\n    motionValue,\n    name,\n    repeatDelay,\n    repeatType,\n    damping,\n    type\n  } = options;\n  const subject = motionValue?.owner?.current;\n  /**\n   * We use this check instead of isHTMLElement() because we explicitly\n   * **don't** want elements in different timing contexts (i.e. popups)\n   * to be accelerated, as it's not possible to sync these animations\n   * properly with those driven from the main window frameloop.\n   */\n\n  if (!(subject instanceof HTMLElement)) {\n    return false;\n  }\n\n  const {\n    onUpdate,\n    transformTemplate\n  } = motionValue.owner.getProps();\n  return supportsWaapi() && name && acceleratedValues.has(name) && (name !== \"transform\" || !transformTemplate) &&\n  /**\n   * If we're outputting values to onUpdate then we can't use WAAPI as there's\n   * no way to read the value from WAAPI every frame.\n   */\n  !onUpdate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n}\n\nexport { supportsBrowserAnimation };","map":{"version":3,"mappings":";AAMA;;AAEG;;AACH,MAAMA,iBAAiB,GAAG,IAAIC,GAAJ,CAAgB,CACtC,SADsC,EAEtC,UAFsC,EAGtC,QAHsC,EAItC,WAJsC;;AAAA,CAAhB,CAA1B;AASA,MAAMC,aAAa,gBAAiBC,IAAI,CAAC,MACrCC,MAAM,CAACC,cAAP,CAAsBC,IAAtB,CAA2BC,OAAO,CAACC,SAAnC,EAA8C,SAA9C,CADoC,CAAxC;;AAIM,SAAUC,wBAAV,CACFC,OADE,EACgD;EAElD,MAAM;IAAEC,WAAF;IAAeC,IAAf;IAAqBC,WAArB;IAAkCC,UAAlC;IAA8CC,OAA9C;IAAuDC;EAAvD,IACFN,OADJ;EAGA,MAAMO,OAAO,GAAGN,WAAW,EAAEO,KAAb,EAAoBC,OAApC;EAEA;;;;;AAKG;;EACH,IAAI,EAAEF,OAAO,YAAYG,WAArB,CAAJ,EAAuC;IACnC,OAAO,KAAP;EACH;;EAED,MAAM;IAAEC,QAAF;IAAYC;EAAZ,IAAkCX,WAAY,CAACO,KAAb,CAAoBK,QAApB,EAAxC;EAEA,OACIrB,aAAa,MACbU,IADA,IAEAZ,iBAAiB,CAACwB,GAAlB,CAAsBZ,IAAtB,CAFA,KAGCA,IAAI,KAAK,WAAT,IAAwB,CAACU,iBAH1B;EAIA;;;AAGG;EACH,CAACD,QARD,IASA,CAACR,WATD,IAUAC,UAAU,KAAK,QAVf,IAWAC,OAAO,KAAK,CAXZ,IAYAC,IAAI,KAAK,SAbb;AAeJ","names":["acceleratedValues","Set","supportsWaapi","memo","Object","hasOwnProperty","call","Element","prototype","supportsBrowserAnimation","options","motionValue","name","repeatDelay","repeatType","damping","type","subject","owner","current","HTMLElement","onUpdate","transformTemplate","getProps","has"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\animation\\waapi\\supports\\waapi.ts"],"sourcesContent":["import { memo } from \"motion-utils\"\nimport {\n    AnyResolvedKeyframe,\n    ValueAnimationOptionsWithRenderContext,\n} from \"../../types\"\n\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set<string>([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\",\n    // TODO: Could be re-enabled now we have support for linear() easing\n    // \"background-color\"\n])\n\nconst supportsWaapi = /*@__PURE__*/ memo(() =>\n    Object.hasOwnProperty.call(Element.prototype, \"animate\")\n)\n\nexport function supportsBrowserAnimation<T extends AnyResolvedKeyframe>(\n    options: ValueAnimationOptionsWithRenderContext<T>\n) {\n    const { motionValue, name, repeatDelay, repeatType, damping, type } =\n        options\n\n    const subject = motionValue?.owner?.current\n\n    /**\n     * We use this check instead of isHTMLElement() because we explicitly\n     * **don't** want elements in different timing contexts (i.e. popups)\n     * to be accelerated, as it's not possible to sync these animations\n     * properly with those driven from the main window frameloop.\n     */\n    if (!(subject instanceof HTMLElement)) {\n        return false\n    }\n\n    const { onUpdate, transformTemplate } = motionValue!.owner!.getProps()\n\n    return (\n        supportsWaapi() &&\n        name &&\n        acceleratedValues.has(name) &&\n        (name !== \"transform\" || !transformTemplate) &&\n        /**\n         * If we're outputting values to onUpdate then we can't use WAAPI as there's\n         * no way to read the value from WAAPI every frame.\n         */\n        !onUpdate &&\n        !repeatDelay &&\n        repeatType !== \"mirror\" &&\n        damping !== 0 &&\n        type !== \"inertia\"\n    )\n}\n"]},"metadata":{},"sourceType":"module"}