{"ast":null,"code":"import { Feature } from 'motion-dom';\nimport { observeIntersection } from './observers.mjs';\nconst thresholdNames = {\n  some: 0,\n  all: 1\n};\n\nclass InViewFeature extends Feature {\n  constructor() {\n    super(...arguments);\n    this.hasEnteredView = false;\n    this.isInView = false;\n  }\n\n  startObserver() {\n    this.unmount();\n    const {\n      viewport = {}\n    } = this.node.getProps();\n    const {\n      root,\n      margin: rootMargin,\n      amount = \"some\",\n      once\n    } = viewport;\n    const options = {\n      root: root ? root.current : undefined,\n      rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n\n    const onIntersectionUpdate = entry => {\n      const {\n        isIntersecting\n      } = entry;\n      /**\n       * If there's been no change in the viewport state, early return.\n       */\n\n      if (this.isInView === isIntersecting) return;\n      this.isInView = isIntersecting;\n      /**\n       * Handle hasEnteredView. If this is only meant to run once, and\n       * element isn't visible, early return. Otherwise set hasEnteredView to true.\n       */\n\n      if (once && !isIntersecting && this.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        this.hasEnteredView = true;\n      }\n\n      if (this.node.animationState) {\n        this.node.animationState.setActive(\"whileInView\", isIntersecting);\n      }\n      /**\n       * Use the latest committed props rather than the ones in scope\n       * when this observer is created\n       */\n\n\n      const {\n        onViewportEnter,\n        onViewportLeave\n      } = this.node.getProps();\n      const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n      callback && callback(entry);\n    };\n\n    return observeIntersection(this.node.current, options, onIntersectionUpdate);\n  }\n\n  mount() {\n    this.startObserver();\n  }\n\n  update() {\n    if (typeof IntersectionObserver === \"undefined\") return;\n    const {\n      props,\n      prevProps\n    } = this.node;\n    const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n\n    if (hasOptionsChanged) {\n      this.startObserver();\n    }\n  }\n\n  unmount() {}\n\n}\n\nfunction hasViewportOptionChanged(_ref) {\n  let {\n    viewport = {}\n  } = _ref;\n  let {\n    viewport: prevViewport = {}\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return name => viewport[name] !== prevViewport[name];\n}\n\nexport { InViewFeature };","map":{"version":3,"mappings":";;AAIA,MAAMA,cAAc,GAAG;EACnBC,IAAI,EAAE,CADa;EAEnBC,GAAG,EAAE;AAFc,CAAvB;;AAKM,MAAOC,aAAP,SAA6BC,OAA7B,CAA6C;EAAnDC;;IACY,KAAcC,cAAd,GAAiB,KAAjB;IAEA,KAAQC,QAAR,GAAW,KAAX;EA4EX;;EA1EWC,aAAa;IACjB,KAAKC,OAAL;IAEA,MAAM;MAAEC,QAAQ,GAAG;IAAb,IAAoB,KAAKC,IAAL,CAAUC,QAAV,EAA1B;IACA,MAAM;MAAEC,IAAF;MAAQC,MAAM,EAAEC,UAAhB;MAA4BC,MAAM,GAAG,MAArC;MAA6CC;IAA7C,IAAsDP,QAA5D;IAEA,MAAMQ,OAAO,GAAG;MACZL,IAAI,EAAEA,IAAI,GAAGA,IAAI,CAACM,OAAR,GAAkBC,SADhB;MAEZL,UAFY;MAGZM,SAAS,EACL,OAAOL,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsChB,cAAc,CAACgB,MAAD;IAJ5C,CAAhB;;IAOA,MAAMM,oBAAoB,GAAIC,KAAD,IAAqC;MAC9D,MAAM;QAAEC;MAAF,IAAqBD,KAA3B;MAEA;;AAEG;;MACH,IAAI,KAAKhB,QAAL,KAAkBiB,cAAtB,EAAsC;MAEtC,KAAKjB,QAAL,GAAgBiB,cAAhB;MAEA;;;AAGG;;MACH,IAAIP,IAAI,IAAI,CAACO,cAAT,IAA2B,KAAKlB,cAApC,EAAoD;QAChD;MACH,CAFD,MAEO,IAAIkB,cAAJ,EAAoB;QACvB,KAAKlB,cAAL,GAAsB,IAAtB;MACH;;MAED,IAAI,KAAKK,IAAL,CAAUc,cAAd,EAA8B;QAC1B,KAAKd,IAAL,CAAUc,cAAV,CAAyBC,SAAzB,CACI,aADJ,EAEIF,cAFJ;MAIH;MAED;;;AAGG;;;MACH,MAAM;QAAEG,eAAF;QAAmBC;MAAnB,IAAuC,KAAKjB,IAAL,CAAUC,QAAV,EAA7C;MACA,MAAMiB,QAAQ,GAAGL,cAAc,GAAGG,eAAH,GAAqBC,eAApD;MACAC,QAAQ,IAAIA,QAAQ,CAACN,KAAD,CAApB;IACH,CAlCD;;IAoCA,OAAOO,mBAAmB,CACtB,KAAKnB,IAAL,CAAUQ,OADY,EAEtBD,OAFsB,EAGtBI,oBAHsB,CAA1B;EAKH;;EAEDS,KAAK;IACD,KAAKvB,aAAL;EACH;;EAEDwB,MAAM;IACF,IAAI,OAAOC,oBAAP,KAAgC,WAApC,EAAiD;IAEjD,MAAM;MAAEC,KAAF;MAASC;IAAT,IAAuB,KAAKxB,IAAlC;IACA,MAAMyB,iBAAiB,GAAG,CAAC,QAAD,EAAW,QAAX,EAAqB,MAArB,EAA6BnC,IAA7B,CACtBoC,wBAAwB,CAACH,KAAD,EAAQC,SAAR,CADF,CAA1B;;IAIA,IAAIC,iBAAJ,EAAuB;MACnB,KAAK5B,aAAL;IACH;EACJ;;EAEDC,OAAO,IAAK;;AA9EmC;;AAiFnD,SAAS4B,wBAAT,OAEqD;EAAA,IADjD;IAAE3B,QAAQ,GAAG;EAAb,CACiD;EAAA,IAAjD;IAAEA,QAAQ,EAAE4B,YAAY,GAAG;EAA3B,CAAiD,uEAAF,EAAE;EAEjD,OAAQC,IAAD,IACH7B,QAAQ,CAAC6B,IAAD,CAAR,KAAmBD,YAAY,CAACC,IAAD,CADnC;AAEJ","names":["thresholdNames","some","all","InViewFeature","Feature","constructor","hasEnteredView","isInView","startObserver","unmount","viewport","node","getProps","root","margin","rootMargin","amount","once","options","current","undefined","threshold","onIntersectionUpdate","entry","isIntersecting","animationState","setActive","onViewportEnter","onViewportLeave","callback","observeIntersection","mount","update","IntersectionObserver","props","prevProps","hasOptionsChanged","hasViewportOptionChanged","prevViewport","name"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\motion\\features\\viewport\\index.ts"],"sourcesContent":["import { Feature } from \"motion-dom\"\nimport { MotionProps } from \"../../types\"\nimport { observeIntersection } from \"./observers\"\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n}\n\nexport class InViewFeature extends Feature<Element> {\n    private hasEnteredView = false\n\n    private isInView = false\n\n    private startObserver() {\n        this.unmount()\n\n        const { viewport = {} } = this.node.getProps()\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport\n\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold:\n                typeof amount === \"number\" ? amount : thresholdNames[amount],\n        }\n\n        const onIntersectionUpdate = (entry: IntersectionObserverEntry) => {\n            const { isIntersecting } = entry\n\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting) return\n\n            this.isInView = isIntersecting\n\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return\n            } else if (isIntersecting) {\n                this.hasEnteredView = true\n            }\n\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\n                    \"whileInView\",\n                    isIntersecting\n                )\n            }\n\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps()\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave\n            callback && callback(entry)\n        }\n\n        return observeIntersection(\n            this.node.current!,\n            options,\n            onIntersectionUpdate\n        )\n    }\n\n    mount() {\n        this.startObserver()\n    }\n\n    update() {\n        if (typeof IntersectionObserver === \"undefined\") return\n\n        const { props, prevProps } = this.node\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(\n            hasViewportOptionChanged(props, prevProps)\n        )\n\n        if (hasOptionsChanged) {\n            this.startObserver()\n        }\n    }\n\n    unmount() {}\n}\n\nfunction hasViewportOptionChanged(\n    { viewport = {} }: MotionProps,\n    { viewport: prevViewport = {} }: MotionProps = {}\n) {\n    return (name: keyof typeof viewport) =>\n        viewport[name] !== prevViewport[name]\n}\n"]},"metadata":{},"sourceType":"module"}