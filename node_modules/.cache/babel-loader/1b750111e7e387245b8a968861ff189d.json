{"ast":null,"code":"\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport { useId, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\n\nconst PresenceChild = _ref => {\n  let {\n    children,\n    initial,\n    isPresent,\n    onExitComplete,\n    custom,\n    presenceAffectsLayout,\n    mode,\n    anchorX,\n    anchorY,\n    root\n  } = _ref;\n  const presenceChildren = useConstant(newChildrenMap);\n  const id = useId();\n  let isReusedContext = true;\n  let context = useMemo(() => {\n    isReusedContext = false;\n    return {\n      id,\n      initial,\n      isPresent,\n      custom,\n      onExitComplete: childId => {\n        presenceChildren.set(childId, true);\n\n        for (const isComplete of presenceChildren.values()) {\n          if (!isComplete) return; // can stop searching when any is incomplete\n        }\n\n        onExitComplete && onExitComplete();\n      },\n      register: childId => {\n        presenceChildren.set(childId, false);\n        return () => presenceChildren.delete(childId);\n      }\n    };\n  }, [isPresent, presenceChildren, onExitComplete]);\n  /**\n   * If the presence of a child affects the layout of the components around it,\n   * we want to make a new context value to ensure they get re-rendered\n   * so they can detect that layout change.\n   */\n\n  if (presenceAffectsLayout && isReusedContext) {\n    context = { ...context\n    };\n  }\n\n  useMemo(() => {\n    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n  }, [isPresent]);\n  /**\n   * If there's no `motion` components to fire exit animations, we want to remove this\n   * component immediately.\n   */\n\n  React.useEffect(() => {\n    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();\n  }, [isPresent]);\n  children = jsx(PopChild, {\n    pop: mode === \"popLayout\",\n    isPresent: isPresent,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    root: root,\n    children: children\n  });\n  return jsx(PresenceContext.Provider, {\n    value: context,\n    children: children\n  });\n};\n\nfunction newChildrenMap() {\n  return new Map();\n}\n\nexport { PresenceChild };","map":{"version":3,"mappings":";;;;;;;;;AAyBa;EAAA;IAAAA;IAAAC;IAAAC;IAAAC;IAAAC;IAAAC;IAAAC;IAAAC;IAAAC;IAAAC;EAAA;EAYT;EACA;;EAGA;;;;;;;MAOQN;QACIO;;;UAGI,iBAAiB;;;;;MAKzBC;QACID;;;;GAjBZ;EAuBA;;;;AAIG;;EACH;IACIE;IAAA;;;;IAIAF;EACJ;EAEA;;;AAGG;;EACHG;IACI,0DAGIV,gBAHJ;EAIJ,CALA,EAKA,WALA;EAOAH;IAAAc;IAAAZ;IAAAK;IAAAC;IAAAC;IAAAT;EAAA;EAMA;IAAAe;IAAAf;EAAA;AAKJ,CA1Ea;;AA4Eb;;AAEA","names":["children","initial","isPresent","onExitComplete","custom","presenceAffectsLayout","mode","anchorX","anchorY","root","presenceChildren","register","context","React","pop","value"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\components\\AnimatePresence\\PresenceChild.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport { useId, useMemo } from \"react\"\nimport {\n    PresenceContext,\n    type PresenceContextProps,\n} from \"../../context/PresenceContext\"\nimport { VariantLabels } from \"../../motion/types\"\nimport { useConstant } from \"../../utils/use-constant\"\nimport { PopChild } from \"./PopChild\"\n\ninterface PresenceChildProps {\n    children: React.ReactElement\n    isPresent: boolean\n    onExitComplete?: () => void\n    initial?: false | VariantLabels\n    custom?: any\n    presenceAffectsLayout: boolean\n    mode: \"sync\" | \"popLayout\" | \"wait\"\n    anchorX?: \"left\" | \"right\"\n    anchorY?: \"top\" | \"bottom\"\n    root?: HTMLElement | ShadowRoot\n}\n\nexport const PresenceChild = ({\n    children,\n    initial,\n    isPresent,\n    onExitComplete,\n    custom,\n    presenceAffectsLayout,\n    mode,\n    anchorX,\n    anchorY,\n    root\n}: PresenceChildProps) => {\n    const presenceChildren = useConstant(newChildrenMap)\n    const id = useId()\n\n    let isReusedContext = true\n    let context = useMemo((): PresenceContextProps => {\n        isReusedContext = false\n        return {\n            id,\n            initial,\n            isPresent,\n            custom,\n            onExitComplete: (childId: string) => {\n                presenceChildren.set(childId, true)\n\n                for (const isComplete of presenceChildren.values()) {\n                    if (!isComplete) return // can stop searching when any is incomplete\n                }\n\n                onExitComplete && onExitComplete()\n            },\n            register: (childId: string) => {\n                presenceChildren.set(childId, false)\n                return () => presenceChildren.delete(childId)\n            },\n        }\n    }, [isPresent, presenceChildren, onExitComplete])\n\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    if (presenceAffectsLayout && isReusedContext) {\n        context = { ...context }\n    }\n\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false))\n    }, [isPresent])\n\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete()\n    }, [isPresent])\n\n    children = (\n        <PopChild pop={mode === \"popLayout\"} isPresent={isPresent} anchorX={anchorX} anchorY={anchorY} root={root}>\n            {children}\n        </PopChild>\n    )\n\n    return (\n        <PresenceContext.Provider value={context}>\n            {children}\n        </PresenceContext.Provider>\n    )\n}\n\nfunction newChildrenMap(): Map<string, boolean> {\n    return new Map()\n}\n"]},"metadata":{},"sourceType":"module"}