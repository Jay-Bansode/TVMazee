{"ast":null,"code":"import { color } from '../color/index.mjs';\nimport { colorRegex } from '../utils/color-regex.mjs';\nimport { floatRegex } from '../utils/float-regex.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\n\nfunction test(v) {\n  return isNaN(v) && typeof v === \"string\" && (v.match(floatRegex)?.length || 0) + (v.match(colorRegex)?.length || 0) > 0;\n}\n\nconst NUMBER_TOKEN = \"number\";\nconst COLOR_TOKEN = \"color\";\nconst VAR_TOKEN = \"var\";\nconst VAR_FUNCTION_TOKEN = \"var(\";\nconst SPLIT_TOKEN = \"${}\"; // this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\n\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\n\nfunction analyseComplexValue(value) {\n  const originalValue = value.toString();\n  const values = [];\n  const indexes = {\n    color: [],\n    number: [],\n    var: []\n  };\n  const types = [];\n  let i = 0;\n  const tokenised = originalValue.replace(complexRegex, parsedValue => {\n    if (color.test(parsedValue)) {\n      indexes.color.push(i);\n      types.push(COLOR_TOKEN);\n      values.push(color.parse(parsedValue));\n    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n      indexes.var.push(i);\n      types.push(VAR_TOKEN);\n      values.push(parsedValue);\n    } else {\n      indexes.number.push(i);\n      types.push(NUMBER_TOKEN);\n      values.push(parseFloat(parsedValue));\n    }\n\n    ++i;\n    return SPLIT_TOKEN;\n  });\n  const split = tokenised.split(SPLIT_TOKEN);\n  return {\n    values,\n    split,\n    indexes,\n    types\n  };\n}\n\nfunction parseComplexValue(v) {\n  return analyseComplexValue(v).values;\n}\n\nfunction createTransformer(source) {\n  const {\n    split,\n    types\n  } = analyseComplexValue(source);\n  const numSections = split.length;\n  return v => {\n    let output = \"\";\n\n    for (let i = 0; i < numSections; i++) {\n      output += split[i];\n\n      if (v[i] !== undefined) {\n        const type = types[i];\n\n        if (type === NUMBER_TOKEN) {\n          output += sanitize(v[i]);\n        } else if (type === COLOR_TOKEN) {\n          output += color.transform(v[i]);\n        } else {\n          output += v[i];\n        }\n      }\n    }\n\n    return output;\n  };\n}\n\nconst convertNumbersToZero = v => typeof v === \"number\" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;\n\nfunction getAnimatableNone(v) {\n  const parsed = parseComplexValue(v);\n  const transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\n\nconst complex = {\n  test,\n  parse: parseComplexValue,\n  createTransformer,\n  getAnimatableNone\n};\nexport { analyseComplexValue, complex };","map":{"version":3,"mappings":"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","names":["test","v","isNaN","match","floatRegex","length","colorRegex","NUMBER_TOKEN","COLOR_TOKEN","VAR_TOKEN","VAR_FUNCTION_TOKEN","SPLIT_TOKEN","complexRegex","analyseComplexValue","value","originalValue","toString","values","indexes","color","number","var","types","i","tokenised","replace","parsedValue","push","parse","startsWith","parseFloat","split","parseComplexValue","createTransformer","source","numSections","output","undefined","type","sanitize","transform","convertNumbersToZero","getAnimatableNone","parsed","transformer","map"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\value\\types\\complex\\index.ts"],"sourcesContent":["import { AnyResolvedKeyframe } from \"../../../animation/types\"\nimport { CSSVariableToken } from \"../../../animation/utils/is-css-variable\"\nimport { color } from \"../color\"\nimport { Color } from \"../types\"\nimport { colorRegex } from \"../utils/color-regex\"\nimport { floatRegex } from \"../utils/float-regex\"\nimport { sanitize } from \"../utils/sanitize\"\n\nfunction test(v: any) {\n    return (\n        isNaN(v) &&\n        typeof v === \"string\" &&\n        (v.match(floatRegex)?.length || 0) +\n            (v.match(colorRegex)?.length || 0) >\n            0\n    )\n}\n\nconst NUMBER_TOKEN = \"number\"\nconst COLOR_TOKEN = \"color\"\nconst VAR_TOKEN = \"var\"\nconst VAR_FUNCTION_TOKEN = \"var(\"\nconst SPLIT_TOKEN = \"${}\"\n\nexport type ComplexValues = Array<\n    CSSVariableToken | AnyResolvedKeyframe | Color\n>\n\nexport interface ValueIndexes {\n    color: number[]\n    number: number[]\n    var: number[]\n}\n\nexport interface ComplexValueInfo {\n    values: ComplexValues\n    split: string[]\n    indexes: ValueIndexes\n    types: Array<keyof ValueIndexes>\n}\n\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\nconst complexRegex =\n    /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu\n\nexport function analyseComplexValue(\n    value: AnyResolvedKeyframe\n): ComplexValueInfo {\n    const originalValue = value.toString()\n\n    const values: ComplexValues = []\n    const indexes: ValueIndexes = {\n        color: [],\n        number: [],\n        var: [],\n    }\n    const types: Array<keyof ValueIndexes> = []\n\n    let i = 0\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\n        if (color.test(parsedValue)) {\n            indexes.color.push(i)\n            types.push(COLOR_TOKEN)\n            values.push(color.parse(parsedValue))\n        } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n            indexes.var.push(i)\n            types.push(VAR_TOKEN)\n            values.push(parsedValue)\n        } else {\n            indexes.number.push(i)\n            types.push(NUMBER_TOKEN)\n            values.push(parseFloat(parsedValue))\n        }\n        ++i\n        return SPLIT_TOKEN\n    })\n    const split = tokenised.split(SPLIT_TOKEN)\n\n    return { values, split, indexes, types }\n}\n\nfunction parseComplexValue(v: AnyResolvedKeyframe) {\n    return analyseComplexValue(v).values\n}\n\nfunction createTransformer(source: AnyResolvedKeyframe) {\n    const { split, types } = analyseComplexValue(source)\n\n    const numSections = split.length\n    return (v: Array<CSSVariableToken | Color | number | string>) => {\n        let output = \"\"\n        for (let i = 0; i < numSections; i++) {\n            output += split[i]\n            if (v[i] !== undefined) {\n                const type = types[i]\n                if (type === NUMBER_TOKEN) {\n                    output += sanitize(v[i] as number)\n                } else if (type === COLOR_TOKEN) {\n                    output += color.transform(v[i] as Color)\n                } else {\n                    output += v[i]\n                }\n            }\n        }\n\n        return output\n    }\n}\n\nconst convertNumbersToZero = (v: number | string) =>\n    typeof v === \"number\" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v\n\nfunction getAnimatableNone(v: AnyResolvedKeyframe) {\n    const parsed = parseComplexValue(v)\n    const transformer = createTransformer(v)\n    return transformer(parsed.map(convertNumbersToZero))\n}\n\nexport const complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone,\n}\n"]},"metadata":{},"sourceType":"module"}