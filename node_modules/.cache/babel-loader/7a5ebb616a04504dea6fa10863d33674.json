{"ast":null,"code":"import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { setStyle } from '../render/dom/style-set.mjs';\nimport { supportsScrollTimeline } from '../utils/supports/scroll-timeline.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\n\nclass NativeAnimation extends WithPromise {\n  constructor(options) {\n    super();\n    this.finishedTime = null;\n    this.isStopped = false;\n    /**\n     * Tracks a manually-set start time that takes precedence over WAAPI's\n     * dynamic startTime. This is cleared when play() or time setter is called,\n     * allowing WAAPI to take over timing.\n     */\n\n    this.manualStartTime = null;\n    if (!options) return;\n    const {\n      element,\n      name,\n      keyframes,\n      pseudoElement,\n      allowFlatten = false,\n      finalKeyframe,\n      onComplete\n    } = options;\n    this.isPseudoElement = Boolean(pseudoElement);\n    this.allowFlatten = allowFlatten;\n    this.options = options;\n    invariant(typeof options.type !== \"string\", `Mini animate() doesn't support \"type\" as a string.`, \"mini-spring\");\n    const transition = applyGeneratorOptions(options);\n    this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n\n    if (transition.autoplay === false) {\n      this.animation.pause();\n    }\n\n    this.animation.onfinish = () => {\n      this.finishedTime = this.time;\n\n      if (!pseudoElement) {\n        const keyframe = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n\n        if (this.updateMotionValue) {\n          this.updateMotionValue(keyframe);\n        } else {\n          /**\n           * If we can, we want to commit the final style as set by the user,\n           * rather than the computed keyframe value supplied by the animation.\n           */\n          setStyle(element, name, keyframe);\n        }\n\n        this.animation.cancel();\n      }\n\n      onComplete?.();\n      this.notifyFinished();\n    };\n  }\n\n  play() {\n    if (this.isStopped) return;\n    this.manualStartTime = null;\n    this.animation.play();\n\n    if (this.state === \"finished\") {\n      this.updateFinished();\n    }\n  }\n\n  pause() {\n    this.animation.pause();\n  }\n\n  complete() {\n    this.animation.finish?.();\n  }\n\n  cancel() {\n    try {\n      this.animation.cancel();\n    } catch (e) {}\n  }\n\n  stop() {\n    if (this.isStopped) return;\n    this.isStopped = true;\n    const {\n      state\n    } = this;\n\n    if (state === \"idle\" || state === \"finished\") {\n      return;\n    }\n\n    if (this.updateMotionValue) {\n      this.updateMotionValue();\n    } else {\n      this.commitStyles();\n    }\n\n    if (!this.isPseudoElement) this.cancel();\n  }\n  /**\n   * WAAPI doesn't natively have any interruption capabilities.\n   *\n   * In this method, we commit styles back to the DOM before cancelling\n   * the animation.\n   *\n   * This is designed to be overridden by NativeAnimationExtended, which\n   * will create a renderless JS animation and sample it twice to calculate\n   * its current value, \"previous\" value, and therefore allow\n   * Motion to also correctly calculate velocity for any subsequent animation\n   * while deferring the commit until the next animation frame.\n   */\n\n\n  commitStyles() {\n    const element = this.options?.element;\n\n    if (!this.isPseudoElement && element?.isConnected) {\n      this.animation.commitStyles?.();\n    }\n  }\n\n  get duration() {\n    const duration = this.animation.effect?.getComputedTiming?.().duration || 0;\n    return millisecondsToSeconds(Number(duration));\n  }\n\n  get iterationDuration() {\n    const {\n      delay = 0\n    } = this.options || {};\n    return this.duration + millisecondsToSeconds(delay);\n  }\n\n  get time() {\n    return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n  }\n\n  set time(newTime) {\n    this.manualStartTime = null;\n    this.finishedTime = null;\n    this.animation.currentTime = secondsToMilliseconds(newTime);\n  }\n  /**\n   * The playback speed of the animation.\n   * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n   */\n\n\n  get speed() {\n    return this.animation.playbackRate;\n  }\n\n  set speed(newSpeed) {\n    // Allow backwards playback after finishing\n    if (newSpeed < 0) this.finishedTime = null;\n    this.animation.playbackRate = newSpeed;\n  }\n\n  get state() {\n    return this.finishedTime !== null ? \"finished\" : this.animation.playState;\n  }\n\n  get startTime() {\n    return this.manualStartTime ?? Number(this.animation.startTime);\n  }\n\n  set startTime(newStartTime) {\n    this.manualStartTime = this.animation.startTime = newStartTime;\n  }\n  /**\n   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n   */\n\n\n  attachTimeline(_ref) {\n    let {\n      timeline,\n      observe\n    } = _ref;\n\n    if (this.allowFlatten) {\n      this.animation.effect?.updateTiming({\n        easing: \"linear\"\n      });\n    }\n\n    this.animation.onfinish = null;\n\n    if (timeline && supportsScrollTimeline()) {\n      this.animation.timeline = timeline;\n      return noop;\n    } else {\n      return observe(this);\n    }\n  }\n\n}\n\nexport { NativeAnimation };","map":{"version":3,"mappings":"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","names":["NativeAnimation","WithPromise","constructor","options","finishedTime","isStopped","manualStartTime","element","name","keyframes","pseudoElement","allowFlatten","finalKeyframe","onComplete","isPseudoElement","Boolean","invariant","type","transition","applyGeneratorOptions","animation","startWaapiAnimation","autoplay","pause","onfinish","time","keyframe","getFinalKeyframe","speed","updateMotionValue","setStyle","cancel","notifyFinished","play","state","updateFinished","complete","finish","e","stop","commitStyles","isConnected","duration","effect","getComputedTiming","millisecondsToSeconds","Number","iterationDuration","delay","currentTime","newTime","secondsToMilliseconds","playbackRate","newSpeed","playState","startTime","newStartTime","attachTimeline","timeline","observe","updateTiming","easing","supportsScrollTimeline","noop"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\animation\\NativeAnimation.ts"],"sourcesContent":["import {\n    invariant,\n    millisecondsToSeconds,\n    noop,\n    secondsToMilliseconds,\n} from \"motion-utils\"\nimport { setStyle } from \"../render/dom/style-set\"\nimport { supportsScrollTimeline } from \"../utils/supports/scroll-timeline\"\nimport { getFinalKeyframe } from \"./keyframes/get-final\"\nimport {\n    AnimationPlaybackControlsWithThen,\n    AnyResolvedKeyframe,\n    DOMValueAnimationOptions,\n    TimelineWithFallback,\n} from \"./types\"\nimport { WithPromise } from \"./utils/WithPromise\"\nimport { startWaapiAnimation } from \"./waapi/start-waapi-animation\"\nimport { applyGeneratorOptions } from \"./waapi/utils/apply-generator\"\n\nexport interface NativeAnimationOptions<V extends AnyResolvedKeyframe = number>\n    extends DOMValueAnimationOptions<V> {\n    pseudoElement?: string\n    startTime?: number\n}\n\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\nexport class NativeAnimation<T extends AnyResolvedKeyframe>\n    extends WithPromise\n    implements AnimationPlaybackControlsWithThen\n{\n    /**\n     * The interfaced Web Animation API animation\n     */\n    protected animation: Animation\n\n    protected finishedTime: number | null = null\n\n    protected options: NativeAnimationOptions\n\n    private allowFlatten: boolean\n\n    private isStopped = false\n\n    private isPseudoElement: boolean\n\n    /**\n     * Tracks a manually-set start time that takes precedence over WAAPI's\n     * dynamic startTime. This is cleared when play() or time setter is called,\n     * allowing WAAPI to take over timing.\n     */\n    protected manualStartTime: number | null = null\n\n    constructor(options?: NativeAnimationOptions) {\n        super()\n\n        if (!options) return\n\n        const {\n            element,\n            name,\n            keyframes,\n            pseudoElement,\n            allowFlatten = false,\n            finalKeyframe,\n            onComplete,\n        } = options as any\n\n        this.isPseudoElement = Boolean(pseudoElement)\n\n        this.allowFlatten = allowFlatten\n        this.options = options\n\n        invariant(\n            typeof options.type !== \"string\",\n            `Mini animate() doesn't support \"type\" as a string.`,\n            \"mini-spring\"\n        )\n\n        const transition = applyGeneratorOptions(options)\n\n        this.animation = startWaapiAnimation(\n            element,\n            name,\n            keyframes,\n            transition,\n            pseudoElement\n        )\n\n        if (transition.autoplay === false) {\n            this.animation.pause()\n        }\n\n        this.animation.onfinish = () => {\n            this.finishedTime = this.time\n\n            if (!pseudoElement) {\n                const keyframe = getFinalKeyframe(\n                    keyframes as any,\n                    this.options as any,\n                    finalKeyframe,\n                    this.speed\n                )\n                if (this.updateMotionValue) {\n                    this.updateMotionValue(keyframe)\n                } else {\n                    /**\n                     * If we can, we want to commit the final style as set by the user,\n                     * rather than the computed keyframe value supplied by the animation.\n                     */\n                    setStyle(element, name, keyframe)\n                }\n\n                this.animation.cancel()\n            }\n\n            onComplete?.()\n            this.notifyFinished()\n        }\n    }\n\n    updateMotionValue?(value?: T): void\n\n    play() {\n        if (this.isStopped) return\n\n        this.manualStartTime = null\n        this.animation.play()\n\n        if (this.state === \"finished\") {\n            this.updateFinished()\n        }\n    }\n\n    pause() {\n        this.animation.pause()\n    }\n\n    complete() {\n        this.animation.finish?.()\n    }\n\n    cancel() {\n        try {\n            this.animation.cancel()\n        } catch (e) {}\n    }\n\n    stop() {\n        if (this.isStopped) return\n        this.isStopped = true\n        const { state } = this\n\n        if (state === \"idle\" || state === \"finished\") {\n            return\n        }\n\n        if (this.updateMotionValue) {\n            this.updateMotionValue()\n        } else {\n            this.commitStyles()\n        }\n\n        if (!this.isPseudoElement) this.cancel()\n    }\n\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * In this method, we commit styles back to the DOM before cancelling\n     * the animation.\n     *\n     * This is designed to be overridden by NativeAnimationExtended, which\n     * will create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to also correctly calculate velocity for any subsequent animation\n     * while deferring the commit until the next animation frame.\n     */\n    protected commitStyles() {\n        const element = this.options?.element\n        if (!this.isPseudoElement && element?.isConnected) {\n            this.animation.commitStyles?.()\n        }\n    }\n\n    get duration() {\n        const duration =\n            this.animation.effect?.getComputedTiming?.().duration || 0\n\n        return millisecondsToSeconds(Number(duration))\n    }\n\n    get iterationDuration() {\n        const { delay = 0 } = this.options || {}\n        return this.duration + millisecondsToSeconds(delay)\n    }\n\n    get time() {\n        return millisecondsToSeconds(Number(this.animation.currentTime) || 0)\n    }\n\n    set time(newTime: number) {\n        this.manualStartTime = null\n        this.finishedTime = null\n        this.animation.currentTime = secondsToMilliseconds(newTime)\n    }\n\n    /**\n     * The playback speed of the animation.\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n     */\n    get speed() {\n        return this.animation.playbackRate\n    }\n\n    set speed(newSpeed: number) {\n        // Allow backwards playback after finishing\n        if (newSpeed < 0) this.finishedTime = null\n\n        this.animation.playbackRate = newSpeed\n    }\n\n    get state() {\n        return this.finishedTime !== null\n            ? \"finished\"\n            : this.animation.playState\n    }\n\n    get startTime() {\n        return this.manualStartTime ?? Number(this.animation.startTime)\n    }\n\n    set startTime(newStartTime: number) {\n        this.manualStartTime = this.animation.startTime = newStartTime\n    }\n\n    /**\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n     */\n    attachTimeline({ timeline, observe }: TimelineWithFallback): VoidFunction {\n        if (this.allowFlatten) {\n            this.animation.effect?.updateTiming({ easing: \"linear\" })\n        }\n\n        this.animation.onfinish = null\n\n        if (timeline && supportsScrollTimeline()) {\n            this.animation.timeline = timeline as any\n\n            return noop<void>\n        } else {\n            return observe(this)\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}