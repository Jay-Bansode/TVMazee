{"ast":null,"code":"import { warning, secondsToMilliseconds, clamp, millisecondsToSeconds } from 'motion-utils';\nimport { springDefaults } from './defaults.mjs';\nconst safeMin = 0.001;\n\nfunction findSpring(_ref) {\n  let {\n    duration = springDefaults.duration,\n    bounce = springDefaults.bounce,\n    velocity = springDefaults.velocity,\n    mass = springDefaults.mass\n  } = _ref;\n  let envelope;\n  let derivative;\n  warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), \"Spring duration must be 10 seconds or less\", \"spring-duration-limit\");\n  let dampingRatio = 1 - bounce;\n  /**\n   * Restrict dampingRatio and duration to within acceptable ranges.\n   */\n\n  dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\n  duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));\n\n  if (dampingRatio < 1) {\n    /**\n     * Underdamped spring\n     */\n    envelope = undampedFreq => {\n      const exponentialDecay = undampedFreq * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const a = exponentialDecay - velocity;\n      const b = calcAngularFreq(undampedFreq, dampingRatio);\n      const c = Math.exp(-delta);\n      return safeMin - a / b * c;\n    };\n\n    derivative = undampedFreq => {\n      const exponentialDecay = undampedFreq * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const d = delta * velocity + velocity;\n      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n      const f = Math.exp(-delta);\n      const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n      const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n      return factor * ((d - e) * f) / g;\n    };\n  } else {\n    /**\n     * Critically-damped spring\n     */\n    envelope = undampedFreq => {\n      const a = Math.exp(-undampedFreq * duration);\n      const b = (undampedFreq - velocity) * duration + 1;\n      return -safeMin + a * b;\n    };\n\n    derivative = undampedFreq => {\n      const a = Math.exp(-undampedFreq * duration);\n      const b = (velocity - undampedFreq) * (duration * duration);\n      return a * b;\n    };\n  }\n\n  const initialGuess = 5 / duration;\n  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n  duration = secondsToMilliseconds(duration);\n\n  if (isNaN(undampedFreq)) {\n    return {\n      stiffness: springDefaults.stiffness,\n      damping: springDefaults.damping,\n      duration\n    };\n  } else {\n    const stiffness = Math.pow(undampedFreq, 2) * mass;\n    return {\n      stiffness,\n      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n      duration\n    };\n  }\n}\n\nconst rootIterations = 12;\n\nfunction approximateRoot(envelope, derivative, initialGuess) {\n  let result = initialGuess;\n\n  for (let i = 1; i < rootIterations; i++) {\n    result = result - envelope(result) / derivative(result);\n  }\n\n  return result;\n}\n\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nexport { calcAngularFreq, findSpring };","map":{"version":3,"mappings":"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","names":["safeMin","findSpring","duration","springDefaults","bounce","velocity","mass","envelope","derivative","warning","secondsToMilliseconds","maxDuration","dampingRatio","clamp","minDamping","maxDamping","minDuration","millisecondsToSeconds","undampedFreq","exponentialDecay","delta","a","b","calcAngularFreq","c","Math","exp","d","e","pow","f","g","factor","initialGuess","approximateRoot","isNaN","stiffness","damping","sqrt","rootIterations","result","i"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\animation\\generators\\spring\\find.ts"],"sourcesContent":["import {\n    clamp,\n    millisecondsToSeconds,\n    secondsToMilliseconds,\n    warning,\n} from \"motion-utils\"\nimport { SpringOptions } from \"../../types\"\nimport { springDefaults } from \"./defaults\"\n\n/**\n * This is ported from the Framer implementation of duration-based spring resolution.\n */\n\ntype Resolver = (num: number) => number\n\nconst safeMin = 0.001\n\nexport function findSpring({\n    duration = springDefaults.duration,\n    bounce = springDefaults.bounce,\n    velocity = springDefaults.velocity,\n    mass = springDefaults.mass,\n}: SpringOptions) {\n    let envelope: Resolver\n    let derivative: Resolver\n\n    warning(\n        duration <= secondsToMilliseconds(springDefaults.maxDuration),\n        \"Spring duration must be 10 seconds or less\",\n        \"spring-duration-limit\"\n    )\n\n    let dampingRatio = 1 - bounce\n\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(\n        springDefaults.minDamping,\n        springDefaults.maxDamping,\n        dampingRatio\n    )\n    duration = clamp(\n        springDefaults.minDuration,\n        springDefaults.maxDuration,\n        millisecondsToSeconds(duration)\n    )\n\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio\n            const delta = exponentialDecay * duration\n            const a = exponentialDecay - velocity\n            const b = calcAngularFreq(undampedFreq, dampingRatio)\n            const c = Math.exp(-delta)\n            return safeMin - (a / b) * c\n        }\n\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio\n            const delta = exponentialDecay * duration\n            const d = delta * velocity + velocity\n            const e =\n                Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration\n            const f = Math.exp(-delta)\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio)\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1\n            return (factor * ((d - e) * f)) / g\n        }\n    } else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration)\n            const b = (undampedFreq - velocity) * duration + 1\n            return -safeMin + a * b\n        }\n\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration)\n            const b = (velocity - undampedFreq) * (duration * duration)\n            return a * b\n        }\n    }\n\n    const initialGuess = 5 / duration\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess)\n\n    duration = secondsToMilliseconds(duration)\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: springDefaults.stiffness,\n            damping: springDefaults.damping,\n            duration,\n        }\n    } else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        }\n    }\n}\n\nconst rootIterations = 12\nfunction approximateRoot(\n    envelope: Resolver,\n    derivative: Resolver,\n    initialGuess: number\n): number {\n    let result = initialGuess\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result)\n    }\n    return result\n}\n\nexport function calcAngularFreq(undampedFreq: number, dampingRatio: number) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio)\n}\n"]},"metadata":{},"sourceType":"module"}