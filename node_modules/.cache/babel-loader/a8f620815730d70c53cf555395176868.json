{"ast":null,"code":"import { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';\nimport { AsyncMotionValueAnimation } from '../AsyncMotionValueAnimation.mjs';\nimport { JSAnimation } from '../JSAnimation.mjs';\nimport { getValueTransition } from '../utils/get-value-transition.mjs';\nimport { makeAnimationInstant } from '../utils/make-animation-instant.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { getFinalKeyframe } from '../utils/get-final-keyframe.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\nconst animateMotionValue = function (name, value, target) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let element = arguments.length > 4 ? arguments[4] : undefined;\n  let isHandoff = arguments.length > 5 ? arguments[5] : undefined;\n  return onComplete => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n\n    let {\n      elapsed = 0\n    } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    const options = {\n      keyframes: Array.isArray(target) ? target : [null, target],\n      ease: \"easeOut\",\n      velocity: value.getVelocity(),\n      ...valueTransition,\n      delay: -elapsed,\n      onUpdate: v => {\n        value.set(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: () => {\n        onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      },\n      name,\n      motionValue: value,\n      element: isHandoff ? undefined : element\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unique transition settings for this value.\n     */\n\n    if (!isTransitionDefined(valueTransition)) {\n      Object.assign(options, getDefaultTransition(name, options));\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n\n\n    options.duration && (options.duration = secondsToMilliseconds(options.duration));\n    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));\n    /**\n     * Support deprecated way to set initial value. Prefer keyframe syntax.\n     */\n\n    if (options.from !== undefined) {\n      options.keyframes[0] = options.from;\n    }\n\n    let shouldSkip = false;\n\n    if (options.type === false || options.duration === 0 && !options.repeatDelay) {\n      makeAnimationInstant(options);\n\n      if (options.delay === 0) {\n        shouldSkip = true;\n      }\n    }\n\n    if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations || element?.shouldSkipAnimations) {\n      shouldSkip = true;\n      makeAnimationInstant(options);\n      options.delay = 0;\n    }\n    /**\n     * If the transition type or easing has been explicitly set by the user\n     * then we don't want to allow flattening the animation.\n     */\n\n\n    options.allowFlatten = !valueTransition.type && !valueTransition.ease;\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n      const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n\n      if (finalKeyframe !== undefined) {\n        frame.update(() => {\n          options.onUpdate(finalKeyframe);\n          options.onComplete();\n        });\n        return;\n      }\n    }\n\n    return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);\n  };\n};\n\nexport { animateMotionValue };","map":{"version":3,"mappings":"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","names":["animateMotionValue","name","value","target","transition","element","isHandoff","onComplete","valueTransition","getValueTransition","delay","elapsed","secondsToMilliseconds","options","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","motionValue","undefined","isTransitionDefined","Object","assign","getDefaultTransition","duration","repeatDelay","from","shouldSkip","type","makeAnimationInstant","MotionGlobalConfig","instantAnimations","skipAnimations","shouldSkipAnimations","allowFlatten","get","finalKeyframe","getFinalKeyframe","frame","update","isSync","JSAnimation","AsyncMotionValueAnimation"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\animation\\interfaces\\motion-value.ts"],"sourcesContent":["import { MotionGlobalConfig, secondsToMilliseconds } from \"motion-utils\"\nimport { AsyncMotionValueAnimation } from \"../AsyncMotionValueAnimation\"\nimport { JSAnimation } from \"../JSAnimation\"\nimport type {\n    AnyResolvedKeyframe,\n    ValueAnimationOptions,\n    ValueTransition,\n} from \"../types\"\nimport type { UnresolvedKeyframes } from \"../keyframes/KeyframesResolver\"\nimport { getValueTransition } from \"../utils/get-value-transition\"\nimport { makeAnimationInstant } from \"../utils/make-animation-instant\"\nimport { getDefaultTransition } from \"../utils/default-transitions\"\nimport { getFinalKeyframe } from \"../utils/get-final-keyframe\"\nimport { isTransitionDefined } from \"../utils/is-transition-defined\"\nimport { frame } from \"../../frameloop\"\nimport type { MotionValue, StartAnimation } from \"../../value\"\nimport type { VisualElement } from \"../../render/VisualElement\"\n\nexport const animateMotionValue =\n    <V extends AnyResolvedKeyframe>(\n        name: string,\n        value: MotionValue<V>,\n        target: V | UnresolvedKeyframes<V>,\n        transition: ValueTransition & { elapsed?: number } = {},\n        element?: VisualElement<any>,\n        isHandoff?: boolean\n    ): StartAnimation =>\n    (onComplete) => {\n        const valueTransition = getValueTransition(transition, name) || {}\n\n        /**\n         * Most transition values are currently completely overwritten by value-specific\n         * transitions. In the future it'd be nicer to blend these transitions. But for now\n         * delay actually does inherit from the root transition if not value-specific.\n         */\n        const delay = valueTransition.delay || transition.delay || 0\n\n        /**\n         * Elapsed isn't a public transition option but can be passed through from\n         * optimized appear effects in milliseconds.\n         */\n        let { elapsed = 0 } = transition\n        elapsed = elapsed - secondsToMilliseconds(delay)\n\n        const options: ValueAnimationOptions = {\n            keyframes: Array.isArray(target) ? target : [null, target],\n            ease: \"easeOut\",\n            velocity: value.getVelocity(),\n            ...valueTransition,\n            delay: -elapsed,\n            onUpdate: (v) => {\n                value.set(v)\n                valueTransition.onUpdate && valueTransition.onUpdate(v)\n            },\n            onComplete: () => {\n                onComplete()\n                valueTransition.onComplete && valueTransition.onComplete()\n            },\n            name,\n            motionValue: value,\n            element: isHandoff ? undefined : element,\n        }\n\n        /**\n         * If there's no transition defined for this value, we can generate\n         * unique transition settings for this value.\n         */\n        if (!isTransitionDefined(valueTransition)) {\n            Object.assign(options, getDefaultTransition(name, options))\n        }\n\n        /**\n         * Both WAAPI and our internal animation functions use durations\n         * as defined by milliseconds, while our external API defines them\n         * as seconds.\n         */\n        options.duration &&= secondsToMilliseconds(options.duration)\n        options.repeatDelay &&= secondsToMilliseconds(options.repeatDelay)\n\n        /**\n         * Support deprecated way to set initial value. Prefer keyframe syntax.\n         */\n        if (options.from !== undefined) {\n            options.keyframes[0] = options.from as any\n        }\n\n        let shouldSkip = false\n\n        if (\n            (options as any).type === false ||\n            (options.duration === 0 && !options.repeatDelay)\n        ) {\n            makeAnimationInstant(options)\n\n            if (options.delay === 0) {\n                shouldSkip = true\n            }\n        }\n\n        if (\n            MotionGlobalConfig.instantAnimations ||\n            MotionGlobalConfig.skipAnimations ||\n            element?.shouldSkipAnimations\n        ) {\n            shouldSkip = true\n            makeAnimationInstant(options)\n            options.delay = 0\n        }\n\n        /**\n         * If the transition type or easing has been explicitly set by the user\n         * then we don't want to allow flattening the animation.\n         */\n        options.allowFlatten = !valueTransition.type && !valueTransition.ease\n\n        /**\n         * If we can or must skip creating the animation, and apply only\n         * the final keyframe, do so. We also check once keyframes are resolved but\n         * this early check prevents the need to create an animation at all.\n         */\n        if (shouldSkip && !isHandoff && value.get() !== undefined) {\n            const finalKeyframe = getFinalKeyframe<V>(\n                options.keyframes as V[],\n                valueTransition\n            )\n\n            if (finalKeyframe !== undefined) {\n                frame.update(() => {\n                    options.onUpdate!(finalKeyframe)\n                    options.onComplete!()\n                })\n\n                return\n            }\n        }\n\n        return valueTransition.isSync\n            ? new JSAnimation(options)\n            : new AsyncMotionValueAnimation(options)\n    }\n"]},"metadata":{},"sourceType":"module"}