{"ast":null,"code":"const threshold = 50;\nconst maxSpeed = 25;\nconst overflowStyles = new Set([\"auto\", \"scroll\"]); // Track initial scroll limits per scrollable element (Bug 1 fix)\n\nconst initialScrollLimits = new WeakMap();\nconst activeScrollEdge = new WeakMap(); // Track which group element is currently dragging to clear state on end\n\nlet currentGroupElement = null;\n\nfunction resetAutoScrollState() {\n  if (currentGroupElement) {\n    const scrollableAncestor = findScrollableAncestor(currentGroupElement, \"y\");\n\n    if (scrollableAncestor) {\n      activeScrollEdge.delete(scrollableAncestor);\n      initialScrollLimits.delete(scrollableAncestor);\n    } // Also try x axis\n\n\n    const scrollableAncestorX = findScrollableAncestor(currentGroupElement, \"x\");\n\n    if (scrollableAncestorX && scrollableAncestorX !== scrollableAncestor) {\n      activeScrollEdge.delete(scrollableAncestorX);\n      initialScrollLimits.delete(scrollableAncestorX);\n    }\n\n    currentGroupElement = null;\n  }\n}\n\nfunction isScrollableElement(element, axis) {\n  const style = getComputedStyle(element);\n  const overflow = axis === \"x\" ? style.overflowX : style.overflowY;\n  const isDocumentScroll = element === document.body || element === document.documentElement;\n  return overflowStyles.has(overflow) || isDocumentScroll;\n}\n\nfunction findScrollableAncestor(element, axis) {\n  let current = element?.parentElement;\n\n  while (current) {\n    if (isScrollableElement(current, axis)) {\n      return current;\n    }\n\n    current = current.parentElement;\n  }\n\n  return null;\n}\n\nfunction getScrollAmount(pointerPosition, scrollElement, axis) {\n  const rect = scrollElement.getBoundingClientRect();\n  const start = axis === \"x\" ? Math.max(0, rect.left) : Math.max(0, rect.top);\n  const end = axis === \"x\" ? Math.min(window.innerWidth, rect.right) : Math.min(window.innerHeight, rect.bottom);\n  const distanceFromStart = pointerPosition - start;\n  const distanceFromEnd = end - pointerPosition;\n\n  if (distanceFromStart < threshold) {\n    const intensity = 1 - distanceFromStart / threshold;\n    return {\n      amount: -maxSpeed * intensity * intensity,\n      edge: \"start\"\n    };\n  } else if (distanceFromEnd < threshold) {\n    const intensity = 1 - distanceFromEnd / threshold;\n    return {\n      amount: maxSpeed * intensity * intensity,\n      edge: \"end\"\n    };\n  }\n\n  return {\n    amount: 0,\n    edge: null\n  };\n}\n\nfunction autoScrollIfNeeded(groupElement, pointerPosition, axis, velocity) {\n  if (!groupElement) return; // Track the group element for cleanup\n\n  currentGroupElement = groupElement;\n  const scrollableAncestor = findScrollableAncestor(groupElement, axis);\n  if (!scrollableAncestor) return; // Convert pointer position from page coordinates to viewport coordinates.\n  // The gesture system uses pageX/pageY but getBoundingClientRect() returns\n  // viewport-relative coordinates, so we need to account for page scroll.\n\n  const viewportPointerPosition = pointerPosition - (axis === \"x\" ? window.scrollX : window.scrollY);\n  const {\n    amount: scrollAmount,\n    edge\n  } = getScrollAmount(viewportPointerPosition, scrollableAncestor, axis); // If not in any threshold zone, clear all state\n\n  if (edge === null) {\n    activeScrollEdge.delete(scrollableAncestor);\n    initialScrollLimits.delete(scrollableAncestor);\n    return;\n  }\n\n  const currentActiveEdge = activeScrollEdge.get(scrollableAncestor);\n  const isDocumentScroll = scrollableAncestor === document.body || scrollableAncestor === document.documentElement; // If not currently scrolling this edge, check velocity to see if we should start\n\n  if (currentActiveEdge !== edge) {\n    // Only start scrolling if velocity is towards the edge\n    const shouldStart = edge === \"start\" && velocity < 0 || edge === \"end\" && velocity > 0;\n    if (!shouldStart) return; // Activate this edge\n\n    activeScrollEdge.set(scrollableAncestor, edge); // Record initial scroll limit (prevents infinite scroll)\n\n    const maxScroll = axis === \"x\" ? scrollableAncestor.scrollWidth - (isDocumentScroll ? window.innerWidth : scrollableAncestor.clientWidth) : scrollableAncestor.scrollHeight - (isDocumentScroll ? window.innerHeight : scrollableAncestor.clientHeight);\n    initialScrollLimits.set(scrollableAncestor, maxScroll);\n  } // Cap scrolling at initial limit (prevents infinite scroll)\n\n\n  if (scrollAmount > 0) {\n    const initialLimit = initialScrollLimits.get(scrollableAncestor);\n    const currentScroll = axis === \"x\" ? isDocumentScroll ? window.scrollX : scrollableAncestor.scrollLeft : isDocumentScroll ? window.scrollY : scrollableAncestor.scrollTop;\n    if (currentScroll >= initialLimit) return;\n  } // Apply scroll\n\n\n  if (axis === \"x\") {\n    if (isDocumentScroll) {\n      window.scrollBy({\n        left: scrollAmount\n      });\n    } else {\n      scrollableAncestor.scrollLeft += scrollAmount;\n    }\n  } else {\n    if (isDocumentScroll) {\n      window.scrollBy({\n        top: scrollAmount\n      });\n    } else {\n      scrollableAncestor.scrollTop += scrollAmount;\n    }\n  }\n}\n\nexport { autoScrollIfNeeded, resetAutoScrollState };","map":{"version":3,"mappings":"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","names":["threshold","maxSpeed","overflowStyles","Set","initialScrollLimits","WeakMap","activeScrollEdge","currentGroupElement","resetAutoScrollState","scrollableAncestor","findScrollableAncestor","delete","scrollableAncestorX","isScrollableElement","element","axis","style","getComputedStyle","overflow","overflowX","overflowY","isDocumentScroll","document","body","documentElement","has","current","parentElement","getScrollAmount","pointerPosition","scrollElement","rect","getBoundingClientRect","start","Math","max","left","top","end","min","window","innerWidth","right","innerHeight","bottom","distanceFromStart","distanceFromEnd","intensity","amount","edge","autoScrollIfNeeded","groupElement","velocity","viewportPointerPosition","scrollX","scrollY","scrollAmount","currentActiveEdge","get","shouldStart","set","maxScroll","scrollWidth","clientWidth","scrollHeight","clientHeight","initialLimit","currentScroll","scrollLeft","scrollTop","scrollBy"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\components\\Reorder\\utils\\auto-scroll.ts"],"sourcesContent":["const threshold = 50\nconst maxSpeed = 25\n\nconst overflowStyles = new Set([\"auto\", \"scroll\"])\n\n// Track initial scroll limits per scrollable element (Bug 1 fix)\nconst initialScrollLimits = new WeakMap<HTMLElement, number>()\n\n// Track auto-scroll active state per edge: \"start\" (top/left) or \"end\" (bottom/right)\ntype ActiveEdge = \"start\" | \"end\" | null\nconst activeScrollEdge = new WeakMap<HTMLElement, ActiveEdge>()\n\n// Track which group element is currently dragging to clear state on end\nlet currentGroupElement: Element | null = null\n\nexport function resetAutoScrollState(): void {\n    if (currentGroupElement) {\n        const scrollableAncestor = findScrollableAncestor(\n            currentGroupElement,\n            \"y\"\n        )\n        if (scrollableAncestor) {\n            activeScrollEdge.delete(scrollableAncestor)\n            initialScrollLimits.delete(scrollableAncestor)\n        }\n        // Also try x axis\n        const scrollableAncestorX = findScrollableAncestor(\n            currentGroupElement,\n            \"x\"\n        )\n        if (scrollableAncestorX && scrollableAncestorX !== scrollableAncestor) {\n            activeScrollEdge.delete(scrollableAncestorX)\n            initialScrollLimits.delete(scrollableAncestorX)\n        }\n        currentGroupElement = null\n    }\n}\n\nfunction isScrollableElement(element: Element, axis: \"x\" | \"y\"): boolean {\n    const style = getComputedStyle(element)\n    const overflow = axis === \"x\" ? style.overflowX : style.overflowY\n\n    const isDocumentScroll =\n        element === document.body ||\n        element === document.documentElement\n\n    return overflowStyles.has(overflow) || isDocumentScroll\n}\n\nfunction findScrollableAncestor(\n    element: Element | null,\n    axis: \"x\" | \"y\"\n): HTMLElement | null {\n    let current = element?.parentElement\n    while (current) {\n        if (isScrollableElement(current, axis)) {\n            return current\n        }\n        current = current.parentElement\n    }\n    return null\n}\n\nfunction getScrollAmount(\n    pointerPosition: number,\n    scrollElement: HTMLElement,\n    axis: \"x\" | \"y\"\n): { amount: number; edge: ActiveEdge } {\n    const rect = scrollElement.getBoundingClientRect()\n\n    const start = axis === \"x\" ? Math.max(0, rect.left) : Math.max(0, rect.top)\n    const end = axis === \"x\" ? Math.min(window.innerWidth, rect.right) : Math.min(window.innerHeight, rect.bottom)\n\n    const distanceFromStart = pointerPosition - start\n    const distanceFromEnd = end - pointerPosition\n\n    if (distanceFromStart < threshold) {\n        const intensity = 1 - distanceFromStart / threshold\n        return { amount: -maxSpeed * intensity * intensity, edge: \"start\" }\n    } else if (distanceFromEnd < threshold) {\n        const intensity = 1 - distanceFromEnd / threshold\n        return { amount: maxSpeed * intensity * intensity, edge: \"end\" }\n    }\n\n    return { amount: 0, edge: null }\n}\n\nexport function autoScrollIfNeeded(\n    groupElement: Element | null,\n    pointerPosition: number,\n    axis: \"x\" | \"y\",\n    velocity: number\n): void {\n    if (!groupElement) return\n\n    // Track the group element for cleanup\n    currentGroupElement = groupElement\n\n    const scrollableAncestor = findScrollableAncestor(groupElement, axis)\n    if (!scrollableAncestor) return\n\n    // Convert pointer position from page coordinates to viewport coordinates.\n    // The gesture system uses pageX/pageY but getBoundingClientRect() returns\n    // viewport-relative coordinates, so we need to account for page scroll.\n    const viewportPointerPosition =\n        pointerPosition - (axis === \"x\" ? window.scrollX : window.scrollY)\n\n    const { amount: scrollAmount, edge } = getScrollAmount(\n        viewportPointerPosition,\n        scrollableAncestor,\n        axis\n    )\n\n    // If not in any threshold zone, clear all state\n    if (edge === null) {\n        activeScrollEdge.delete(scrollableAncestor)\n        initialScrollLimits.delete(scrollableAncestor)\n        return\n    }\n\n    const currentActiveEdge = activeScrollEdge.get(scrollableAncestor)\n\n    const isDocumentScroll =\n        scrollableAncestor === document.body ||\n        scrollableAncestor === document.documentElement\n\n    // If not currently scrolling this edge, check velocity to see if we should start\n    if (currentActiveEdge !== edge) {\n        // Only start scrolling if velocity is towards the edge\n        const shouldStart =\n            (edge === \"start\" && velocity < 0) ||\n            (edge === \"end\" && velocity > 0)\n        if (!shouldStart) return\n\n        // Activate this edge\n        activeScrollEdge.set(scrollableAncestor, edge)\n\n        // Record initial scroll limit (prevents infinite scroll)\n        const maxScroll =\n            axis === \"x\"\n                ? scrollableAncestor.scrollWidth - (isDocumentScroll ? window.innerWidth : scrollableAncestor.clientWidth)\n                : scrollableAncestor.scrollHeight - (isDocumentScroll ? window.innerHeight : scrollableAncestor.clientHeight)\n\n        initialScrollLimits.set(scrollableAncestor, maxScroll)\n    }\n\n    // Cap scrolling at initial limit (prevents infinite scroll)\n    if (scrollAmount > 0) {\n        const initialLimit = initialScrollLimits.get(scrollableAncestor)!\n        const currentScroll =\n            axis === \"x\"\n                ? (isDocumentScroll ? window.scrollX : scrollableAncestor.scrollLeft)\n                : (isDocumentScroll ? window.scrollY : scrollableAncestor.scrollTop)\n        if (currentScroll >= initialLimit) return\n    }\n\n    // Apply scroll\n    if (axis === \"x\") {\n        if (isDocumentScroll) {\n            window.scrollBy({ left: scrollAmount })\n        } else {\n            scrollableAncestor.scrollLeft += scrollAmount\n        }\n    } else {\n        if (isDocumentScroll) {\n            window.scrollBy({ top: scrollAmount })\n        } else {\n            scrollableAncestor.scrollTop += scrollAmount\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}