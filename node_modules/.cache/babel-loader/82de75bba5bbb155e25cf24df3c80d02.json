{"ast":null,"code":"import { getValueAsType } from '../../../value/types/utils/get-as-type.mjs';\nimport { numberValueTypes } from '../../../value/types/maps/number.mjs';\nimport { transformPropOrder } from '../../utils/keys-transform.mjs';\nconst translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\n\nfunction buildTransform(latestValues, transform, transformTemplate) {\n  // The transform string we're going to build into.\n  let transformString = \"\";\n  let transformIsDefault = true;\n  /**\n   * Loop over all possible transforms in order, adding the ones that\n   * are present to the transform string.\n   */\n\n  for (let i = 0; i < numTransforms; i++) {\n    const key = transformPropOrder[i];\n    const value = latestValues[key];\n    if (value === undefined) continue;\n    let valueIsDefault = true;\n\n    if (typeof value === \"number\") {\n      valueIsDefault = value === (key.startsWith(\"scale\") ? 1 : 0);\n    } else {\n      const parsed = parseFloat(value);\n      valueIsDefault = key.startsWith(\"scale\") ? parsed === 1 : parsed === 0;\n    }\n\n    if (!valueIsDefault || transformTemplate) {\n      const valueAsType = getValueAsType(value, numberValueTypes[key]);\n\n      if (!valueIsDefault) {\n        transformIsDefault = false;\n        const transformName = translateAlias[key] || key;\n        transformString += `${transformName}(${valueAsType}) `;\n      }\n\n      if (transformTemplate) {\n        transform[key] = valueAsType;\n      }\n    }\n  }\n\n  transformString = transformString.trim(); // If we have a custom `transform` template, pass our transform values and\n  // generated transformString to that before returning\n\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (transformIsDefault) {\n    transformString = \"none\";\n  }\n\n  return transformString;\n}\n\nexport { buildTransform };","map":{"version":3,"mappings":";;;AAOA,MAAMA,cAAc,GAAG;EACnBC,CAAC,EAAE,YADgB;EAEnBC,CAAC,EAAE,YAFgB;EAGnBC,CAAC,EAAE,YAHgB;EAInBC,oBAAoB,EAAE;AAJH,CAAvB;AAOA,MAAMC,aAAa,GAAGC,kBAAkB,CAACC,MAAzC;AAEA;;;;;AAKG;;SACaC,eACZC,cACAC,WACAC,mBAA0D;;EAG1D,IAAIC,eAAe,GAAG,EAAtB;EACA,IAAIC,kBAAkB,GAAG,IAAzB;EAEA;;;AAGG;;EACH,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,aAApB,EAAmCS,CAAC,EAApC,EAAwC;IACpC,MAAMC,GAAG,GAAGT,kBAAkB,CAACQ,CAAD,CAA9B;IACA,MAAME,KAAK,GAAGP,YAAY,CAACM,GAAD,CAA1B;IAEA,IAAIC,KAAK,KAAKC,SAAd,EAAyB;IAEzB,IAAIC,cAAc,GAAG,IAArB;;IACA,IAAI,OAAOF,KAAP,KAAiB,QAArB,EAA+B;MAC3BE,cAAc,GAAGF,KAAK,MAAMD,GAAG,CAACI,UAAJ,CAAe,OAAf,IAA0B,CAA1B,GAA8B,CAApC,CAAtB;IACH,CAFD,MAEO;MACH,MAAMC,MAAM,GAAGC,UAAU,CAACL,KAAD,CAAzB;MACAE,cAAc,GAAGH,GAAG,CAACI,UAAJ,CAAe,OAAf,IAA0BC,MAAM,KAAK,CAArC,GAAyCA,MAAM,KAAK,CAArE;IACH;;IAED,IAAI,CAACF,cAAD,IAAmBP,iBAAvB,EAA0C;MACtC,MAAMW,WAAW,GAAGC,cAAc,CAACP,KAAD,EAAQQ,gBAAgB,CAACT,GAAD,CAAxB,CAAlC;;MAEA,IAAI,CAACG,cAAL,EAAqB;QACjBL,kBAAkB,GAAG,KAArB;QACA,MAAMY,aAAa,GAAGzB,cAAc,CAACe,GAAD,CAAd,IAAuBA,GAA7C;QACAH,eAAe,IAAO,gBAAiB,eAAW,IAAlD;MACH;;MAED,IAAID,iBAAJ,EAAuB;QACnBD,SAAS,CAACK,GAAD,CAAT,GAAiBO,WAAjB;MACH;IACJ;EACJ;;EAEDV,eAAe,GAAGA,eAAe,CAACc,IAAhB,EAAlB,CAvC0D;;;EA2C1D,IAAIf,iBAAJ,EAAuB;IACnBC,eAAe,GAAGD,iBAAiB,CAC/BD,SAD+B,EAE/BG,kBAAkB,GAAG,EAAH,GAAQD,eAFK,CAAnC;EAIH,CALD,MAKO,IAAIC,kBAAJ,EAAwB;IAC3BD,eAAe,GAAG,MAAlB;EACH;;EAED,OAAOA,eAAP;AACJ","names":["translateAlias","x","y","z","transformPerspective","numTransforms","transformPropOrder","length","buildTransform","latestValues","transform","transformTemplate","transformString","transformIsDefault","i","key","value","undefined","valueIsDefault","startsWith","parsed","parseFloat","valueAsType","getValueAsType","numberValueTypes","transformName","trim"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\render\\html\\utils\\build-transform.ts"],"sourcesContent":["import { getValueAsType } from \"../../../value/types/utils/get-as-type\"\nimport { numberValueTypes } from \"../../../value/types/maps/number\"\nimport { transformPropOrder } from \"../../utils/keys-transform\"\nimport { ResolvedValues } from \"../../types\"\nimport { HTMLRenderState } from \"../types\"\nimport type { MotionNodeOptions } from \"../../../node/types\"\n\nconst translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n}\n\nconst numTransforms = transformPropOrder.length\n\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nexport function buildTransform(\n    latestValues: ResolvedValues,\n    transform: HTMLRenderState[\"transform\"],\n    transformTemplate?: MotionNodeOptions[\"transformTemplate\"]\n) {\n    // The transform string we're going to build into.\n    let transformString = \"\"\n    let transformIsDefault = true\n\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */\n    for (let i = 0; i < numTransforms; i++) {\n        const key = transformPropOrder[i] as keyof typeof translateAlias\n        const value = latestValues[key]\n\n        if (value === undefined) continue\n\n        let valueIsDefault = true\n        if (typeof value === \"number\") {\n            valueIsDefault = value === (key.startsWith(\"scale\") ? 1 : 0)\n        } else {\n            const parsed = parseFloat(value)\n            valueIsDefault = key.startsWith(\"scale\") ? parsed === 1 : parsed === 0\n        }\n\n        if (!valueIsDefault || transformTemplate) {\n            const valueAsType = getValueAsType(value, numberValueTypes[key])\n\n            if (!valueIsDefault) {\n                transformIsDefault = false\n                const transformName = translateAlias[key] || key\n                transformString += `${transformName}(${valueAsType}) `\n            }\n\n            if (transformTemplate) {\n                transform[key] = valueAsType\n            }\n        }\n    }\n\n    transformString = transformString.trim()\n\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(\n            transform,\n            transformIsDefault ? \"\" : transformString\n        )\n    } else if (transformIsDefault) {\n        transformString = \"none\"\n    }\n\n    return transformString\n}\n"]},"metadata":{},"sourceType":"module"}