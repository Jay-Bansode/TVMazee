{"ast":null,"code":"import { isDragActive } from './drag/state/is-active.mjs';\nimport { setupGesture } from './utils/setup.mjs';\n\nfunction isValidHover(event) {\n  return !(event.pointerType === \"touch\" || isDragActive());\n}\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\n\n\nfunction hover(elementOrSelector, onHoverStart) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\n  elements.forEach(element => {\n    let isPressed = false;\n    let deferredHoverEnd = false;\n    let hoverEndCallback;\n\n    const removePointerLeave = () => {\n      element.removeEventListener(\"pointerleave\", onPointerLeave);\n    };\n\n    const endHover = event => {\n      if (hoverEndCallback) {\n        hoverEndCallback(event);\n        hoverEndCallback = undefined;\n      }\n\n      removePointerLeave();\n    };\n\n    const onPointerUp = event => {\n      isPressed = false;\n      window.removeEventListener(\"pointerup\", onPointerUp);\n      window.removeEventListener(\"pointercancel\", onPointerUp);\n\n      if (deferredHoverEnd) {\n        deferredHoverEnd = false;\n        endHover(event);\n      }\n    };\n\n    const onPointerDown = () => {\n      isPressed = true;\n      window.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n      window.addEventListener(\"pointercancel\", onPointerUp, eventOptions);\n    };\n\n    const onPointerLeave = leaveEvent => {\n      if (leaveEvent.pointerType === \"touch\") return;\n\n      if (isPressed) {\n        deferredHoverEnd = true;\n        return;\n      }\n\n      endHover(leaveEvent);\n    };\n\n    const onPointerEnter = enterEvent => {\n      if (!isValidHover(enterEvent)) return;\n      deferredHoverEnd = false;\n      const onHoverEnd = onHoverStart(element, enterEvent);\n      if (typeof onHoverEnd !== \"function\") return;\n      hoverEndCallback = onHoverEnd;\n      element.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\n    };\n\n    element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\n    element.addEventListener(\"pointerdown\", onPointerDown, eventOptions);\n  });\n  return cancel;\n}\n\nexport { hover };","map":{"version":3,"mappings":";;;AAyBA,SAASA,YAAT,CAAsBC,KAAtB,EAAyC;EACrC,OAAO,EAAEA,KAAK,CAACC,WAAN,KAAsB,OAAtB,IAAiCC,YAAY,EAA/C,CAAP;AACH;AAED;;;;;;AAMG;;;AACG,SAAUC,KAAV,CACFC,iBADE,EAEFC,YAFE,EAGwB;EAAA,IAA1BC,OAA0B,uEAAF,EAAE;EAE1B,MAAM,CAACC,QAAD,EAAWC,YAAX,EAAyBC,MAAzB,IAAmCC,YAAY,CACjDN,iBADiD,EAEjDE,OAFiD,CAArD;EAKAC,QAAQ,CAACI,OAAT,CAAkBC,OAAD,IAAY;IACzB,IAAIC,SAAS,GAAG,KAAhB;IACA,IAAIC,gBAAgB,GAAG,KAAvB;IACA,IAAIC,gBAAJ;;IAEA,MAAMC,kBAAkB,GAAG,MAAK;MAC5BJ,OAAO,CAACK,mBAAR,CACI,cADJ,EAEIC,cAFJ;IAIH,CALD;;IAOA,MAAMC,QAAQ,GAAInB,KAAD,IAAwB;MACrC,IAAIe,gBAAJ,EAAsB;QAClBA,gBAAgB,CAACf,KAAD,CAAhB;QACAe,gBAAgB,GAAGK,SAAnB;MACH;;MACDJ,kBAAkB;IACrB,CAND;;IAQA,MAAMK,WAAW,GAAIrB,KAAD,IAAiB;MACjCa,SAAS,GAAG,KAAZ;MACAS,MAAM,CAACL,mBAAP,CACI,WADJ,EAEII,WAFJ;MAIAC,MAAM,CAACL,mBAAP,CACI,eADJ,EAEII,WAFJ;;MAKA,IAAIP,gBAAJ,EAAsB;QAClBA,gBAAgB,GAAG,KAAnB;QACAK,QAAQ,CAACnB,KAAD,CAAR;MACH;IACJ,CAfD;;IAiBA,MAAMuB,aAAa,GAAG,MAAK;MACvBV,SAAS,GAAG,IAAZ;MACAS,MAAM,CAACE,gBAAP,CACI,WADJ,EAEIH,WAFJ,EAGIb,YAHJ;MAKAc,MAAM,CAACE,gBAAP,CACI,eADJ,EAEIH,WAFJ,EAGIb,YAHJ;IAKH,CAZD;;IAcA,MAAMU,cAAc,GAAIO,UAAD,IAA6B;MAChD,IAAIA,UAAU,CAACxB,WAAX,KAA2B,OAA/B,EAAwC;;MAExC,IAAIY,SAAJ,EAAe;QACXC,gBAAgB,GAAG,IAAnB;QACA;MACH;;MAEDK,QAAQ,CAACM,UAAD,CAAR;IACH,CATD;;IAWA,MAAMC,cAAc,GAAIC,UAAD,IAA6B;MAChD,IAAI,CAAC5B,YAAY,CAAC4B,UAAD,CAAjB,EAA+B;MAE/Bb,gBAAgB,GAAG,KAAnB;MAEA,MAAMc,UAAU,GAAGvB,YAAY,CAC3BO,OAD2B,EAE3Be,UAF2B,CAA/B;MAKA,IAAI,OAAOC,UAAP,KAAsB,UAA1B,EAAsC;MAEtCb,gBAAgB,GAAGa,UAAnB;MAEAhB,OAAO,CAACY,gBAAR,CACI,cADJ,EAEIN,cAFJ,EAGIV,YAHJ;IAKH,CAnBD;;IAqBAI,OAAO,CAACY,gBAAR,CACI,cADJ,EAEIE,cAFJ,EAGIlB,YAHJ;IAKAI,OAAO,CAACY,gBAAR,CACI,aADJ,EAEID,aAFJ,EAGIf,YAHJ;EAKH,CA7FD;EA+FA,OAAOC,MAAP;AACJ","names":["isValidHover","event","pointerType","isDragActive","hover","elementOrSelector","onHoverStart","options","elements","eventOptions","cancel","setupGesture","forEach","element","isPressed","deferredHoverEnd","hoverEndCallback","removePointerLeave","removeEventListener","onPointerLeave","endHover","undefined","onPointerUp","window","onPointerDown","addEventListener","leaveEvent","onPointerEnter","enterEvent","onHoverEnd"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\gestures\\hover.ts"],"sourcesContent":["import { ElementOrSelector } from \"../utils/resolve-elements\"\nimport { isDragActive } from \"./drag/state/is-active\"\nimport { EventOptions } from \"./types\"\nimport { setupGesture } from \"./utils/setup\"\n\n/**\n * A function to be called when a hover gesture starts.\n *\n * This function can optionally return a function that will be called\n * when the hover gesture ends.\n *\n * @public\n */\nexport type OnHoverStartEvent = (\n    element: Element,\n    event: PointerEvent\n) => void | OnHoverEndEvent\n\n/**\n * A function to be called when a hover gesture ends.\n *\n * @public\n */\nexport type OnHoverEndEvent = (event: PointerEvent) => void\n\nfunction isValidHover(event: PointerEvent) {\n    return !(event.pointerType === \"touch\" || isDragActive())\n}\n\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nexport function hover(\n    elementOrSelector: ElementOrSelector,\n    onHoverStart: OnHoverStartEvent,\n    options: EventOptions = {}\n): VoidFunction {\n    const [elements, eventOptions, cancel] = setupGesture(\n        elementOrSelector,\n        options\n    )\n\n    elements.forEach((element) => {\n        let isPressed = false\n        let deferredHoverEnd = false\n        let hoverEndCallback: OnHoverEndEvent | undefined\n\n        const removePointerLeave = () => {\n            element.removeEventListener(\n                \"pointerleave\",\n                onPointerLeave as EventListener\n            )\n        }\n\n        const endHover = (event: PointerEvent) => {\n            if (hoverEndCallback) {\n                hoverEndCallback(event)\n                hoverEndCallback = undefined\n            }\n            removePointerLeave()\n        }\n\n        const onPointerUp = (event: Event) => {\n            isPressed = false\n            window.removeEventListener(\n                \"pointerup\",\n                onPointerUp as EventListener\n            )\n            window.removeEventListener(\n                \"pointercancel\",\n                onPointerUp as EventListener\n            )\n\n            if (deferredHoverEnd) {\n                deferredHoverEnd = false\n                endHover(event as PointerEvent)\n            }\n        }\n\n        const onPointerDown = () => {\n            isPressed = true\n            window.addEventListener(\n                \"pointerup\",\n                onPointerUp as EventListener,\n                eventOptions\n            )\n            window.addEventListener(\n                \"pointercancel\",\n                onPointerUp as EventListener,\n                eventOptions\n            )\n        }\n\n        const onPointerLeave = (leaveEvent: PointerEvent) => {\n            if (leaveEvent.pointerType === \"touch\") return\n\n            if (isPressed) {\n                deferredHoverEnd = true\n                return\n            }\n\n            endHover(leaveEvent)\n        }\n\n        const onPointerEnter = (enterEvent: PointerEvent) => {\n            if (!isValidHover(enterEvent)) return\n\n            deferredHoverEnd = false\n\n            const onHoverEnd = onHoverStart(\n                element as Element,\n                enterEvent\n            )\n\n            if (typeof onHoverEnd !== \"function\") return\n\n            hoverEndCallback = onHoverEnd\n\n            element.addEventListener(\n                \"pointerleave\",\n                onPointerLeave as EventListener,\n                eventOptions\n            )\n        }\n\n        element.addEventListener(\n            \"pointerenter\",\n            onPointerEnter as EventListener,\n            eventOptions\n        )\n        element.addEventListener(\n            \"pointerdown\",\n            onPointerDown as EventListener,\n            eventOptions\n        )\n    })\n\n    return cancel\n}\n"]},"metadata":{},"sourceType":"module"}