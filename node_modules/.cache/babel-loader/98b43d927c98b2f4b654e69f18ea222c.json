{"ast":null,"code":"import { parseValueFromTransform } from '../../../render/dom/parse-transform.mjs';\nimport { transformPropOrder } from '../../../render/utils/keys-transform.mjs';\nimport { number } from '../../../value/types/numbers/index.mjs';\nimport { px } from '../../../value/types/numbers/units.mjs';\n\nconst isNumOrPxType = v => v === number || v === px;\n\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter(key => !transformKeys.has(key));\n\nfunction removeNonTranslationalTransform(visualElement) {\n  const removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(key => {\n    const value = visualElement.getValue(key);\n\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  return removedTransforms;\n}\n\nconst positionalValues = {\n  // Dimensions\n  width: (_ref, _ref2) => {\n    let {\n      x\n    } = _ref;\n    let {\n      paddingLeft = \"0\",\n      paddingRight = \"0\"\n    } = _ref2;\n    return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\n  },\n  height: (_ref3, _ref4) => {\n    let {\n      y\n    } = _ref3;\n    let {\n      paddingTop = \"0\",\n      paddingBottom = \"0\"\n    } = _ref4;\n    return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\n  },\n  top: (_bbox, _ref5) => {\n    let {\n      top\n    } = _ref5;\n    return parseFloat(top);\n  },\n  left: (_bbox, _ref6) => {\n    let {\n      left\n    } = _ref6;\n    return parseFloat(left);\n  },\n  bottom: (_ref7, _ref8) => {\n    let {\n      y\n    } = _ref7;\n    let {\n      top\n    } = _ref8;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: (_ref9, _ref10) => {\n    let {\n      x\n    } = _ref9;\n    let {\n      left\n    } = _ref10;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: (_bbox, _ref11) => {\n    let {\n      transform\n    } = _ref11;\n    return parseValueFromTransform(transform, \"x\");\n  },\n  y: (_bbox, _ref12) => {\n    let {\n      transform\n    } = _ref12;\n    return parseValueFromTransform(transform, \"y\");\n  }\n}; // Alias translate longform names\n\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\nexport { isNumOrPxType, positionalValues, removeNonTranslationalTransform };","map":{"version":3,"mappings":";;;;;AAUa,mBAAa,GAAIA,CAAD,IACzBA,CAAC,KAAKC,MAAN,IAAgBD,CAAC,KAAKE,EADb;;AAQb,MAAMC,aAAa,GAAG,IAAIC,GAAJ,CAAQ,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAR,CAAtB;AACA,MAAMC,6BAA6B,GAAGC,kBAAkB,CAACC,MAAnB,CACjCC,GAAD,IAAS,CAACL,aAAa,CAACM,GAAd,CAAkBD,GAAlB,CADwB,CAAtC;;AAKM,SAAUE,+BAAV,CAA0CC,aAA1C,EAAmE;EACrE,MAAMC,iBAAiB,GAAsB,EAA7C;EAEAP,6BAA6B,CAACQ,OAA9B,CAAuCL,GAAD,IAAQ;IAC1C,MAAMM,KAAK,GACPH,aAAa,CAACI,QAAd,CAAuBP,GAAvB,CADJ;;IAEA,IAAIM,KAAK,KAAKE,SAAd,EAAyB;MACrBJ,iBAAiB,CAACK,IAAlB,CAAuB,CAACT,GAAD,EAAMM,KAAK,CAACI,GAAN,EAAN,CAAvB;MACAJ,KAAK,CAACK,GAAN,CAAUX,GAAG,CAACY,UAAJ,CAAe,OAAf,IAA0B,CAA1B,GAA8B,CAAxC;IACH;EACJ,CAPD;EASA,OAAOR,iBAAP;AACH;;AAEY,sBAAgB,GACzB;;EAEIS,KAAK,EAAE;IAAA,IAAC;MAAEC;IAAF,CAAD;IAAA,IAAQ;MAAEC,WAAW,GAAG,GAAhB;MAAqBC,YAAY,GAAG;IAApC,CAAR;IAAA,OACHF,CAAC,CAACG,GAAF,GAAQH,CAAC,CAACI,GAAV,GAAgBC,UAAU,CAACJ,WAAD,CAA1B,GAA0CI,UAAU,CAACH,YAAD,CADjD;EAAA,CAFX;EAIII,MAAM,EAAE;IAAA,IAAC;MAAEC;IAAF,CAAD;IAAA,IAAQ;MAAEC,UAAU,GAAG,GAAf;MAAoBC,aAAa,GAAG;IAApC,CAAR;IAAA,OACJF,CAAC,CAACJ,GAAF,GAAQI,CAAC,CAACH,GAAV,GAAgBC,UAAU,CAACG,UAAD,CAA1B,GAAyCH,UAAU,CAACI,aAAD,CAD/C;EAAA,CAJZ;EAOIC,GAAG,EAAE,CAACC,KAAD;IAAA,IAAQ;MAAED;IAAF,CAAR;IAAA,OAAoBL,UAAU,CAACK,GAAD,CAA9B;EAAA,CAPT;EAQIE,IAAI,EAAE,CAACD,KAAD;IAAA,IAAQ;MAAEC;IAAF,CAAR;IAAA,OAAqBP,UAAU,CAACO,IAAD,CAA/B;EAAA,CARV;EASIC,MAAM,EAAE;IAAA,IAAC;MAAEN;IAAF,CAAD;IAAA,IAAQ;MAAEG;IAAF,CAAR;IAAA,OAAoBL,UAAU,CAACK,GAAD,CAAV,IAA6BH,CAAC,CAACJ,GAAF,GAAQI,CAAC,CAACH,GAAvC,CAApB;EAAA,CATZ;EAUIU,KAAK,EAAE;IAAA,IAAC;MAAEd;IAAF,CAAD;IAAA,IAAQ;MAAEY;IAAF,CAAR;IAAA,OACHP,UAAU,CAACO,IAAD,CAAV,IAA8BZ,CAAC,CAACG,GAAF,GAAQH,CAAC,CAACI,GAAxC,CADG;EAAA,CAVX;;EAcIJ,CAAC,EAAE,CAACW,KAAD;IAAA,IAAQ;MAAEI;IAAF,CAAR;IAAA,OAA0BC,uBAAuB,CAACD,SAAD,EAAY,GAAZ,CAAjD;EAAA,CAdP;EAeIR,CAAC,EAAE,CAACI,KAAD;IAAA,IAAQ;MAAEI;IAAF,CAAR;IAAA,OAA0BC,uBAAuB,CAACD,SAAD,EAAY,GAAZ,CAAjD;EAAA;AAfP,CADS,C,CAmBb;;AACAE,gBAAgB,CAACC,UAAjB,GAA8BD,gBAAgB,CAACjB,CAA/C;AACAiB,gBAAgB,CAACE,UAAjB,GAA8BF,gBAAgB,CAACV,CAA/C","names":["v","number","px","transformKeys","Set","nonTranslationalTransformKeys","transformPropOrder","filter","key","has","removeNonTranslationalTransform","visualElement","removedTransforms","forEach","value","getValue","undefined","push","get","set","startsWith","width","x","paddingLeft","paddingRight","max","min","parseFloat","height","y","paddingTop","paddingBottom","top","_bbox","left","bottom","right","transform","parseValueFromTransform","positionalValues","translateX","translateY"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\animation\\keyframes\\utils\\unit-conversion.ts"],"sourcesContent":["import type { Box } from \"motion-utils\"\nimport { parseValueFromTransform } from \"../../../render/dom/parse-transform\"\nimport { transformPropOrder } from \"../../../render/utils/keys-transform\"\nimport { MotionValue } from \"../../../value\"\nimport { number } from \"../../../value/types/numbers\"\nimport { px } from \"../../../value/types/numbers/units\"\nimport { ValueType } from \"../../../value/types/types\"\nimport { AnyResolvedKeyframe } from \"../../types\"\nimport { WithRender } from \"../types\"\n\nexport const isNumOrPxType = (v?: ValueType): v is ValueType =>\n    v === number || v === px\n\ntype GetActualMeasurementInPixels = (\n    bbox: Box,\n    computedStyle: Partial<CSSStyleDeclaration>\n) => number\n\nconst transformKeys = new Set([\"x\", \"y\", \"z\"])\nconst nonTranslationalTransformKeys = transformPropOrder.filter(\n    (key) => !transformKeys.has(key)\n)\n\ntype RemovedTransforms = [string, AnyResolvedKeyframe][]\nexport function removeNonTranslationalTransform(visualElement: WithRender) {\n    const removedTransforms: RemovedTransforms = []\n\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value: MotionValue<AnyResolvedKeyframe> | undefined =\n            visualElement.getValue(key)\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()])\n            value.set(key.startsWith(\"scale\") ? 1 : 0)\n        }\n    })\n\n    return removedTransforms\n}\n\nexport const positionalValues: { [key: string]: GetActualMeasurementInPixels } =\n    {\n        // Dimensions\n        width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) =>\n            x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n        height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) =>\n            y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n\n        top: (_bbox, { top }) => parseFloat(top as string),\n        left: (_bbox, { left }) => parseFloat(left as string),\n        bottom: ({ y }, { top }) => parseFloat(top as string) + (y.max - y.min),\n        right: ({ x }, { left }) =>\n            parseFloat(left as string) + (x.max - x.min),\n\n        // Transform\n        x: (_bbox, { transform }) => parseValueFromTransform(transform, \"x\"),\n        y: (_bbox, { transform }) => parseValueFromTransform(transform, \"y\"),\n    }\n\n// Alias translate longform names\npositionalValues.translateX = positionalValues.x\npositionalValues.translateY = positionalValues.y\n"]},"metadata":{},"sourceType":"module"}