{"ast":null,"code":"import { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\nimport { calcChildStagger } from '../../animation/utils/calc-child-stagger.mjs';\nimport { getVariantContext } from './get-variant-context.mjs';\nimport { isAnimationControls } from './is-animation-controls.mjs';\nimport { isKeyframesTarget } from './is-keyframes-target.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { shallowCompare } from './shallow-compare.mjs';\nimport { variantPriorityOrder } from './variant-props.mjs';\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\n\nfunction createAnimateFunction(visualElement) {\n  return animations => {\n    return Promise.all(animations.map(_ref => {\n      let {\n        animation,\n        options\n      } = _ref;\n      return animateVisualElement(visualElement, animation, options);\n    }));\n  };\n}\n\nfunction createAnimationState(visualElement) {\n  let animate = createAnimateFunction(visualElement);\n  let state = createState();\n  let isInitialRender = true;\n  /**\n   * This function will be used to reduce the animation definitions for\n   * each active animation type into an object of resolved values for it.\n   */\n\n  const buildResolvedTypeValues = type => (acc, definition) => {\n    const resolved = resolveVariant(visualElement, definition, type === \"exit\" ? visualElement.presenceContext?.custom : undefined);\n\n    if (resolved) {\n      const {\n        transition,\n        transitionEnd,\n        ...target\n      } = resolved;\n      acc = { ...acc,\n        ...target,\n        ...transitionEnd\n      };\n    }\n\n    return acc;\n  };\n  /**\n   * This just allows us to inject mocked animation functions\n   * @internal\n   */\n\n\n  function setAnimateFunction(makeAnimator) {\n    animate = makeAnimator(visualElement);\n  }\n  /**\n   * When we receive new props, we need to:\n   * 1. Create a list of protected keys for each type. This is a directory of\n   *    value keys that are currently being \"handled\" by types of a higher priority\n   *    so that whenever an animation is played of a given type, these values are\n   *    protected from being animated.\n   * 2. Determine if an animation type needs animating.\n   * 3. Determine if any values have been removed from a type and figure out\n   *    what to animate those to.\n   */\n\n\n  function animateChanges(changedActiveType) {\n    const {\n      props\n    } = visualElement;\n    const context = getVariantContext(visualElement.parent) || {};\n    /**\n     * A list of animations that we'll build into as we iterate through the animation\n     * types. This will get executed at the end of the function.\n     */\n\n    const animations = [];\n    /**\n     * Keep track of which values have been removed. Then, as we hit lower priority\n     * animation types, we can check if they contain removed values and animate to that.\n     */\n\n    const removedKeys = new Set();\n    /**\n     * A dictionary of all encountered keys. This is an object to let us build into and\n     * copy it without iteration. Each time we hit an animation type we set its protected\n     * keys - the keys its not allowed to animate - to the latest version of this object.\n     */\n\n    let encounteredKeys = {};\n    /**\n     * If a variant has been removed at a given index, and this component is controlling\n     * variant animations, we want to ensure lower-priority variants are forced to animate.\n     */\n\n    let removedVariantIndex = Infinity;\n    /**\n     * Iterate through all animation types in reverse priority order. For each, we want to\n     * detect which values it's handling and whether or not they've changed (and therefore\n     * need to be animated). If any values have been removed, we want to detect those in\n     * lower priority props and flag for animation.\n     */\n\n    for (let i = 0; i < numAnimationTypes; i++) {\n      const type = reversePriorityOrder[i];\n      const typeState = state[type];\n      const prop = props[type] !== undefined ? props[type] : context[type];\n      const propIsVariant = isVariantLabel(prop);\n      /**\n       * If this type has *just* changed isActive status, set activeDelta\n       * to that status. Otherwise set to null.\n       */\n\n      const activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false) removedVariantIndex = i;\n      /**\n       * If this prop is an inherited variant, rather than been set directly on the\n       * component itself, we want to make sure we allow the parent to trigger animations.\n       *\n       * TODO: Can probably change this to a !isControllingVariants check\n       */\n\n      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      /**\n       * Set all encountered keys so far as the protected keys for this type. This will\n       * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n       */\n\n\n      typeState.protectedKeys = { ...encounteredKeys\n      }; // Check if we can skip analysing this prop early\n\n      if ( // If it isn't active and hasn't *just* been set as inactive\n      !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type\n      !prop && !typeState.prevProp || // Or if the prop doesn't define an animation\n      isAnimationControls(prop) || typeof prop === \"boolean\") {\n        continue;\n      }\n      /**\n       * If exit is already active and wasn't just activated, skip\n       * re-processing to prevent interrupting running exit animations.\n       * Re-resolving exit with a changed custom value can start new\n       * value animations that stop the originals, leaving the exit\n       * animation promise unresolved and the component stuck in the DOM.\n       */\n\n\n      if (type === \"exit\" && typeState.isActive && activeDelta !== true) {\n        if (typeState.prevResolvedValues) {\n          encounteredKeys = { ...encounteredKeys,\n            ...typeState.prevResolvedValues\n          };\n        }\n\n        continue;\n      }\n      /**\n       * As we go look through the values defined on this type, if we detect\n       * a changed value or a value that was removed in a higher priority, we set\n       * this to true and add this prop to the animation list.\n       */\n\n\n      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active\n      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)\n      i > removedVariantIndex && propIsVariant;\n      let handledRemovedValues = false;\n      /**\n       * As animations can be set as variant lists, variants or target objects, we\n       * coerce everything to an array if it isn't one already\n       */\n\n      const definitionList = Array.isArray(prop) ? prop : [prop];\n      /**\n       * Build an object of all the resolved values. We'll use this in the subsequent\n       * animateChanges calls to determine whether a value has changed.\n       */\n\n      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n      if (activeDelta === false) resolvedValues = {};\n      /**\n       * Now we need to loop through all the keys in the prev prop and this prop,\n       * and decide:\n       * 1. If the value has changed, and needs animating\n       * 2. If it has been removed, and needs adding to the removedKeys set\n       * 3. If it has been removed in a higher priority type and needs animating\n       * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n       *    needs adding to the type's protectedKeys list.\n       */\n\n      const {\n        prevResolvedValues = {}\n      } = typeState;\n      const allKeys = { ...prevResolvedValues,\n        ...resolvedValues\n      };\n\n      const markToAnimate = key => {\n        shouldAnimateType = true;\n\n        if (removedKeys.has(key)) {\n          handledRemovedValues = true;\n          removedKeys.delete(key);\n        }\n\n        typeState.needsAnimating[key] = true;\n        const motionValue = visualElement.getValue(key);\n        if (motionValue) motionValue.liveStyle = false;\n      };\n\n      for (const key in allKeys) {\n        const next = resolvedValues[key];\n        const prev = prevResolvedValues[key]; // If we've already handled this we can just skip ahead\n\n        if (encounteredKeys.hasOwnProperty(key)) continue;\n        /**\n         * If the value has changed, we probably want to animate it.\n         */\n\n        let valueHasChanged = false;\n\n        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n          valueHasChanged = !shallowCompare(next, prev);\n        } else {\n          valueHasChanged = next !== prev;\n        }\n\n        if (valueHasChanged) {\n          if (next !== undefined && next !== null) {\n            // If next is defined and doesn't equal prev, it needs animating\n            markToAnimate(key);\n          } else {\n            // If it's undefined, it's been removed.\n            removedKeys.add(key);\n          }\n        } else if (next !== undefined && removedKeys.has(key)) {\n          /**\n           * If next hasn't changed and it isn't undefined, we want to check if it's\n           * been removed by a higher priority\n           */\n          markToAnimate(key);\n        } else {\n          /**\n           * If it hasn't changed, we add it to the list of protected values\n           * to ensure it doesn't get animated.\n           */\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      /**\n       * Update the typeState so next time animateChanges is called we can compare the\n       * latest prop and resolvedValues to these.\n       */\n\n\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n\n      if (typeState.isActive) {\n        encounteredKeys = { ...encounteredKeys,\n          ...resolvedValues\n        };\n      }\n\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      /**\n       * If this is an inherited prop we want to skip this animation\n       * unless the inherited variants haven't changed on this render.\n       */\n\n\n      const willAnimateViaParent = isInherited && variantDidChange;\n      const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n\n      if (shouldAnimateType && needsAnimating) {\n        animations.push(...definitionList.map(animation => {\n          const options = {\n            type\n          };\n          /**\n           * If we're performing the initial animation, but we're not\n           * rendering at the same time as the variant-controlling parent,\n           * we want to use the parent's transition to calculate the stagger.\n           */\n\n          if (typeof animation === \"string\" && isInitialRender && !willAnimateViaParent && visualElement.manuallyAnimateOnMount && visualElement.parent) {\n            const {\n              parent\n            } = visualElement;\n            const parentVariant = resolveVariant(parent, animation);\n\n            if (parent.enteringChildren && parentVariant) {\n              const {\n                delayChildren\n              } = parentVariant.transition || {};\n              options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);\n            }\n          }\n\n          return {\n            animation: animation,\n            options\n          };\n        }));\n      }\n    }\n    /**\n     * If there are some removed value that haven't been dealt with,\n     * we need to create a new animation that falls back either to the value\n     * defined in the style prop, or the last read value.\n     */\n\n\n    if (removedKeys.size) {\n      const fallbackAnimation = {};\n      /**\n       * If the initial prop contains a transition we can use that, otherwise\n       * allow the animation function to use the visual element's default.\n       */\n\n      if (typeof props.initial !== \"boolean\") {\n        const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);\n\n        if (initialTransition && initialTransition.transition) {\n          fallbackAnimation.transition = initialTransition.transition;\n        }\n      }\n\n      removedKeys.forEach(key => {\n        const fallbackTarget = visualElement.getBaseTarget(key);\n        const motionValue = visualElement.getValue(key);\n        if (motionValue) motionValue.liveStyle = true; // @ts-expect-error - @mattgperry to figure if we should do something here\n\n        fallbackAnimation[key] = fallbackTarget ?? null;\n      });\n      animations.push({\n        animation: fallbackAnimation\n      });\n    }\n\n    let shouldAnimate = Boolean(animations.length);\n\n    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n\n    isInitialRender = false;\n    return shouldAnimate ? animate(animations) : Promise.resolve();\n  }\n  /**\n   * Change whether a certain animation type is active.\n   */\n\n\n  function setActive(type, isActive) {\n    // If the active state hasn't changed, we can safely do nothing here\n    if (state[type].isActive === isActive) return Promise.resolve(); // Propagate active change to children\n\n    visualElement.variantChildren?.forEach(child => child.animationState?.setActive(type, isActive));\n    state[type].isActive = isActive;\n    const animations = animateChanges(type);\n\n    for (const key in state) {\n      state[key].protectedKeys = {};\n    }\n\n    return animations;\n  }\n\n  return {\n    animateChanges,\n    setActive,\n    setAnimateFunction,\n    getState: () => state,\n    reset: () => {\n      state = createState();\n      /**\n       * Temporarily disabling resetting this flag as it prevents components\n       * with initial={false} from animating after being remounted, for instance\n       * as the child of an Activity component.\n       */\n      // isInitialRender = true\n    }\n  };\n}\n\nfunction checkVariantsDidChange(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (Array.isArray(next)) {\n    return !shallowCompare(next, prev);\n  }\n\n  return false;\n}\n\nfunction createTypeState() {\n  let isActive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return {\n    isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\n\nfunction createState() {\n  return {\n    animate: createTypeState(true),\n    whileInView: createTypeState(),\n    whileHover: createTypeState(),\n    whileTap: createTypeState(),\n    whileDrag: createTypeState(),\n    whileFocus: createTypeState(),\n    exit: createTypeState()\n  };\n}\n\nexport { checkVariantsDidChange, createAnimationState };","map":{"version":3,"mappings":"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","names":["reversePriorityOrder","variantPriorityOrder","reverse","numAnimationTypes","length","createAnimateFunction","visualElement","animations","Promise","all","map","animation","options","animateVisualElement","createAnimationState","animate","state","createState","isInitialRender","buildResolvedTypeValues","type","acc","definition","resolved","resolveVariant","presenceContext","custom","undefined","transition","transitionEnd","target","setAnimateFunction","makeAnimator","animateChanges","changedActiveType","props","context","getVariantContext","parent","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","i","typeState","prop","propIsVariant","isVariantLabel","activeDelta","isActive","isInherited","manuallyAnimateOnMount","protectedKeys","prevProp","isAnimationControls","prevResolvedValues","variantDidChange","checkVariantsDidChange","shouldAnimateType","handledRemovedValues","definitionList","Array","isArray","resolvedValues","reduce","allKeys","markToAnimate","key","has","delete","needsAnimating","motionValue","getValue","liveStyle","next","prev","hasOwnProperty","valueHasChanged","isKeyframesTarget","shallowCompare","add","blockInitialAnimation","willAnimateViaParent","push","parentVariant","enteringChildren","delayChildren","delay","calcChildStagger","size","fallbackAnimation","initial","initialTransition","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","resolve","setActive","variantChildren","child","animationState","getState","reset","createTypeState","whileInView","whileHover","whileTap","whileDrag","whileFocus","exit"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\render\\utils\\animation-state.ts"],"sourcesContent":["import type {\n    AnimationDefinition,\n    TargetAndTransition,\n    VariantLabels,\n} from \"../../node/types\"\nimport type { AnimationType } from \"../types\"\nimport type { VisualElementAnimationOptions } from \"../../animation/interfaces/types\"\nimport { animateVisualElement } from \"../../animation/interfaces/visual-element\"\nimport { calcChildStagger } from \"../../animation/utils/calc-child-stagger\"\nimport { getVariantContext } from \"./get-variant-context\"\nimport { isAnimationControls } from \"./is-animation-controls\"\nimport { isKeyframesTarget } from \"./is-keyframes-target\"\nimport { isVariantLabel } from \"./is-variant-label\"\nimport { resolveVariant } from \"./resolve-dynamic-variants\"\nimport { shallowCompare } from \"./shallow-compare\"\nimport { variantPriorityOrder } from \"./variant-props\"\n\nexport type { VisualElementAnimationOptions }\n\nexport interface AnimationState {\n    animateChanges: (type?: AnimationType) => Promise<any>\n    setActive: (\n        type: AnimationType,\n        isActive: boolean,\n        options?: VisualElementAnimationOptions\n    ) => Promise<any>\n    setAnimateFunction: (fn: any) => void\n    getState: () => { [key: string]: AnimationTypeState }\n    reset: () => void\n}\n\ninterface DefinitionAndOptions {\n    animation: AnimationDefinition\n    options?: VisualElementAnimationOptions\n}\n\nexport type AnimationList = string[] | TargetAndTransition[]\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse()\nconst numAnimationTypes = variantPriorityOrder.length\n\n/**\n * Type for the animate function that can be injected.\n * This allows the animation implementation to be provided by the framework layer.\n */\nexport type AnimateFunction = (animations: DefinitionAndOptions[]) => Promise<any>\n\nfunction createAnimateFunction(visualElement: any): AnimateFunction {\n    return (animations: DefinitionAndOptions[]) => {\n        return Promise.all(\n            animations.map(({ animation, options }) =>\n                animateVisualElement(visualElement, animation, options)\n            )\n        )\n    }\n}\n\nexport function createAnimationState(visualElement: any): AnimationState {\n    let animate = createAnimateFunction(visualElement)\n    let state = createState()\n    let isInitialRender = true\n\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues =\n        (type: AnimationType) =>\n        (\n            acc: { [key: string]: any },\n            definition: string | TargetAndTransition | undefined\n        ) => {\n            const resolved = resolveVariant(\n                visualElement,\n                definition,\n                type === \"exit\"\n                    ? visualElement.presenceContext?.custom\n                    : undefined\n            )\n\n            if (resolved) {\n                const { transition, transitionEnd, ...target } = resolved\n                acc = { ...acc, ...target, ...transitionEnd }\n            }\n\n            return acc\n        }\n\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(\n        makeAnimator: (visualElement: any) => AnimateFunction\n    ) {\n        animate = makeAnimator(visualElement)\n    }\n\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType?: AnimationType) {\n        const { props } = visualElement\n        const context = getVariantContext(visualElement.parent) || {}\n\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations: DefinitionAndOptions[] = []\n\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set<string>()\n\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys: { [key: string]: any } = {}\n\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity\n\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i]\n            const typeState = state[type]\n            const prop =\n                props[type] !== undefined\n                    ? props[type]\n                    : context[type as keyof typeof context]\n            const propIsVariant = isVariantLabel(prop)\n\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta =\n                type === changedActiveType ? typeState.isActive : null\n\n            if (activeDelta === false) removedVariantIndex = i\n\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited =\n                prop === context[type as keyof typeof context] &&\n                prop !== props[type] &&\n                propIsVariant\n\n            if (\n                isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount\n            ) {\n                isInherited = false\n            }\n\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys }\n\n            // Check if we can skip analysing this prop early\n            if (\n                // If it isn't active and hasn't *just* been set as inactive\n                (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\"\n            ) {\n                continue\n            }\n\n            /**\n             * If exit is already active and wasn't just activated, skip\n             * re-processing to prevent interrupting running exit animations.\n             * Re-resolving exit with a changed custom value can start new\n             * value animations that stop the originals, leaving the exit\n             * animation promise unresolved and the component stuck in the DOM.\n             */\n            if (type === \"exit\" && typeState.isActive && activeDelta !== true) {\n                if (typeState.prevResolvedValues) {\n                    encounteredKeys = {\n                        ...encounteredKeys,\n                        ...typeState.prevResolvedValues,\n                    }\n                }\n                continue\n            }\n\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(\n                typeState.prevProp,\n                prop\n            )\n\n            let shouldAnimateType =\n                variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant)\n\n            let handledRemovedValues = false\n\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop]\n\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(\n                buildResolvedTypeValues(type),\n                {}\n            )\n\n            if (activeDelta === false) resolvedValues = {}\n\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState\n\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            }\n            const markToAnimate = (key: string) => {\n                shouldAnimateType = true\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true\n                    removedKeys.delete(key)\n                }\n                typeState.needsAnimating[key] = true\n\n                const motionValue = visualElement.getValue(key)\n                if (motionValue) motionValue.liveStyle = false\n            }\n\n            for (const key in allKeys) {\n                const next = resolvedValues[key]\n                const prev = prevResolvedValues[key]\n\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key)) continue\n\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev)\n                } else {\n                    valueHasChanged = next !== prev\n                }\n\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key)\n                    } else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key)\n                    }\n                } else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key)\n                } else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true\n                }\n            }\n\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop\n            typeState.prevResolvedValues = resolvedValues\n\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues }\n            }\n\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false\n            }\n\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven't changed on this render.\n             */\n            const willAnimateViaParent = isInherited && variantDidChange\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(\n                    ...definitionList.map((animation) => {\n                        const options: VisualElementAnimationOptions = { type }\n\n                        /**\n                         * If we're performing the initial animation, but we're not\n                         * rendering at the same time as the variant-controlling parent,\n                         * we want to use the parent's transition to calculate the stagger.\n                         */\n                        if (\n                            typeof animation === \"string\" &&\n                            isInitialRender &&\n                            !willAnimateViaParent &&\n                            visualElement.manuallyAnimateOnMount &&\n                            visualElement.parent\n                        ) {\n                            const { parent } = visualElement\n                            const parentVariant = resolveVariant(\n                                parent,\n                                animation\n                            )\n\n                            if (parent.enteringChildren && parentVariant) {\n                                const { delayChildren } =\n                                    parentVariant.transition || {}\n                                options.delay = calcChildStagger(\n                                    parent.enteringChildren,\n                                    visualElement,\n                                    delayChildren\n                                )\n                            }\n                        }\n\n                        return {\n                            animation: animation as AnimationDefinition,\n                            options,\n                        }\n                    })\n                )\n            }\n        }\n\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation: TargetAndTransition = {}\n\n            /**\n             * If the initial prop contains a transition we can use that, otherwise\n             * allow the animation function to use the visual element's default.\n             */\n            if (typeof props.initial !== \"boolean\") {\n                const initialTransition = resolveVariant(\n                    visualElement,\n                    Array.isArray(props.initial)\n                        ? props.initial[0]\n                        : props.initial\n                )\n\n                if (initialTransition && initialTransition.transition) {\n                    fallbackAnimation.transition = initialTransition.transition\n                }\n            }\n\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key)\n\n                const motionValue = visualElement.getValue(key)\n                if (motionValue) motionValue.liveStyle = true\n\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget ?? null\n            })\n\n            animations.push({ animation: fallbackAnimation })\n        }\n\n        let shouldAnimate = Boolean(animations.length)\n\n        if (\n            isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount\n        ) {\n            shouldAnimate = false\n        }\n\n        isInitialRender = false\n        return shouldAnimate ? animate(animations) : Promise.resolve()\n    }\n\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type: AnimationType, isActive: boolean) {\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive) return Promise.resolve()\n\n        // Propagate active change to children\n        visualElement.variantChildren?.forEach((child: any) =>\n            child.animationState?.setActive(type, isActive)\n        )\n\n        state[type].isActive = isActive\n\n        const animations = animateChanges(type)\n\n        for (const key in state) {\n            state[key as keyof typeof state].protectedKeys = {}\n        }\n\n        return animations\n    }\n\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState()\n            /**\n             * Temporarily disabling resetting this flag as it prevents components\n             * with initial={false} from animating after being remounted, for instance\n             * as the child of an Activity component.\n             */\n            // isInitialRender = true\n        },\n    }\n}\n\nexport function checkVariantsDidChange(prev: any, next: any) {\n    if (typeof next === \"string\") {\n        return next !== prev\n    } else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev)\n    }\n\n    return false\n}\n\nexport interface AnimationTypeState {\n    isActive: boolean\n    protectedKeys: { [key: string]: true }\n    needsAnimating: { [key: string]: boolean }\n    prevResolvedValues: { [key: string]: any }\n    prevProp?: VariantLabels | TargetAndTransition\n}\n\nfunction createTypeState(isActive = false): AnimationTypeState {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    }\n}\n\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    }\n}\n"]},"metadata":{},"sourceType":"module"}