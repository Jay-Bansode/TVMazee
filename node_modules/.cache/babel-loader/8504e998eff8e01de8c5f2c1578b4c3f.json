{"ast":null,"code":"import { isHTMLElement } from 'motion-dom';\n\nfunction calcInset(element, container) {\n  const inset = {\n    x: 0,\n    y: 0\n  };\n  let current = element;\n\n  while (current && current !== container) {\n    if (isHTMLElement(current)) {\n      inset.x += current.offsetLeft;\n      inset.y += current.offsetTop;\n      current = current.offsetParent;\n    } else if (current.tagName === \"svg\") {\n      /**\n       * This isn't an ideal approach to measuring the offset of <svg /> tags.\n       * It would be preferable, given they behave like HTMLElements in most ways\n       * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n       * can't use .getBBox() like most SVG elements as these provide the offset\n       * relative to the SVG itself, which for <svg /> is usually 0x0.\n       */\n      const svgBoundingBox = current.getBoundingClientRect();\n      current = current.parentElement;\n      const parentBoundingBox = current.getBoundingClientRect();\n      inset.x += svgBoundingBox.left - parentBoundingBox.left;\n      inset.y += svgBoundingBox.top - parentBoundingBox.top;\n    } else if (current instanceof SVGGraphicsElement) {\n      const {\n        x,\n        y\n      } = current.getBBox();\n      inset.x += x;\n      inset.y += y;\n      let svg = null;\n      let parent = current.parentNode;\n\n      while (!svg) {\n        if (parent.tagName === \"svg\") {\n          svg = parent;\n        }\n\n        parent = current.parentNode;\n      }\n\n      current = svg;\n    } else {\n      break;\n    }\n  }\n\n  return inset;\n}\n\nexport { calcInset };","map":{"version":3,"mappings":";;AAEgB,mBAAUA,OAAV,EAA4BC,SAA5B,EAA8C;EAC1D,MAAMC,KAAK,GAAG;IAAEC,CAAC,EAAE,CAAL;IAAQC,CAAC,EAAE;EAAX,CAAd;EAEA,IAAIC,OAAO,GAAmBL,OAA9B;;EACA,OAAOK,OAAO,IAAIA,OAAO,KAAKJ,SAA9B,EAAyC;IACrC,IAAIK,aAAa,CAACD,OAAD,CAAjB,EAA4B;MACxBH,KAAK,CAACC,CAAN,IAAWE,OAAO,CAACE,UAAnB;MACAL,KAAK,CAACE,CAAN,IAAWC,OAAO,CAACG,SAAnB;MACAH,OAAO,GAAGA,OAAO,CAACI,YAAlB;IACH,CAJD,MAIO,IAAIJ,OAAO,CAACK,OAAR,KAAoB,KAAxB,EAA+B;MAClC;;;;;;AAMG;MACH,MAAMC,cAAc,GAAGN,OAAO,CAACO,qBAAR,EAAvB;MACAP,OAAO,GAAGA,OAAO,CAACQ,aAAlB;MACA,MAAMC,iBAAiB,GAAGT,OAAO,CAACO,qBAAR,EAA1B;MACAV,KAAK,CAACC,CAAN,IAAWQ,cAAc,CAACI,IAAf,GAAsBD,iBAAiB,CAACC,IAAnD;MACAb,KAAK,CAACE,CAAN,IAAWO,cAAc,CAACK,GAAf,GAAqBF,iBAAiB,CAACE,GAAlD;IACH,CAbM,MAaA,IAAIX,OAAO,YAAYY,kBAAvB,EAA2C;MAC9C,MAAM;QAAEd,CAAF;QAAKC;MAAL,IAAWC,OAAO,CAACa,OAAR,EAAjB;MACAhB,KAAK,CAACC,CAAN,IAAWA,CAAX;MACAD,KAAK,CAACE,CAAN,IAAWA,CAAX;MAEA,IAAIe,GAAG,GAAsB,IAA7B;MACA,IAAIC,MAAM,GAAef,OAAO,CAACgB,UAAjC;;MACA,OAAO,CAACF,GAAR,EAAa;QACT,IAAIC,MAAM,CAACV,OAAP,KAAmB,KAAvB,EAA8B;UAC1BS,GAAG,GAAGC,MAAN;QACH;;QACDA,MAAM,GAAGf,OAAO,CAACgB,UAAjB;MACH;;MACDhB,OAAO,GAAGc,GAAV;IACH,CAdM,MAcA;MACH;IACH;EACJ;;EAED,OAAOjB,KAAP;AACJ","names":["element","container","inset","x","y","current","isHTMLElement","offsetLeft","offsetTop","offsetParent","tagName","svgBoundingBox","getBoundingClientRect","parentElement","parentBoundingBox","left","top","SVGGraphicsElement","getBBox","svg","parent","parentNode"],"sources":["C:\\Projects\\TVMazee\\node_modules\\framer-motion\\src\\render\\dom\\scroll\\offsets\\inset.ts"],"sourcesContent":["import { isHTMLElement } from \"motion-dom\"\n\nexport function calcInset(element: Element, container: Element) {\n    const inset = { x: 0, y: 0 }\n\n    let current: Element | null = element\n    while (current && current !== container) {\n        if (isHTMLElement(current)) {\n            inset.x += current.offsetLeft\n            inset.y += current.offsetTop\n            current = current.offsetParent\n        } else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect()\n            current = current.parentElement!\n            const parentBoundingBox = current.getBoundingClientRect()\n            inset.x += svgBoundingBox.left - parentBoundingBox.left\n            inset.y += svgBoundingBox.top - parentBoundingBox.top\n        } else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox()\n            inset.x += x\n            inset.y += y\n\n            let svg: SVGElement | null = null\n            let parent: SVGElement = current.parentNode as SVGElement\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent\n                }\n                parent = current.parentNode as SVGElement\n            }\n            current = svg\n        } else {\n            break\n        }\n    }\n\n    return inset\n}\n"]},"metadata":{},"sourceType":"module"}