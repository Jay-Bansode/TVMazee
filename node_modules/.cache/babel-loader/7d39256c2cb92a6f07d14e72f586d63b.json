{"ast":null,"code":"import { mixNumber } from '../../utils/mix/number.mjs';\nimport { percent } from '../../value/types/numbers/units.mjs';\nimport { scalePoint } from './delta-apply.mjs';\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\n\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n  point -= translate;\n  point = scalePoint(point, 1 / scale, originPoint);\n\n  if (boxScale !== undefined) {\n    point = scalePoint(point, 1 / boxScale, originPoint);\n  }\n\n  return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\n\n\nfunction removeAxisDelta(axis) {\n  let translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let origin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;\n  let boxScale = arguments.length > 4 ? arguments[4] : undefined;\n  let originAxis = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : axis;\n  let sourceAxis = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : axis;\n\n  if (percent.test(translate)) {\n    translate = parseFloat(translate);\n    const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);\n    translate = relativeProgress - sourceAxis.min;\n  }\n\n  if (typeof translate !== \"number\") return;\n  let originPoint = mixNumber(originAxis.min, originAxis.max, origin);\n  if (axis === originAxis) originPoint -= translate;\n  axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\n\n\nfunction removeAxisTransforms(axis, transforms, _ref, origin, sourceAxis) {\n  let [key, scaleKey, originKey] = _ref;\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\n\n\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\n\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);\n  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);\n}\n\nexport { removeAxisDelta, removeAxisTransforms, removeBoxTransforms, removePointDelta };","map":{"version":3,"mappings":"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","names":["removePointDelta","point","translate","scale","originPoint","boxScale","scalePoint","undefined","removeAxisDelta","axis","origin","originAxis","sourceAxis","percent","test","parseFloat","relativeProgress","mixNumber","min","max","removeAxisTransforms","transforms","key","scaleKey","originKey","xKeys","yKeys","removeBoxTransforms","box","originBox","sourceBox","x","y"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\projection\\geometry\\delta-remove.ts"],"sourcesContent":["import { Axis, Box } from \"motion-utils\"\nimport { mixNumber } from \"../../utils/mix/number\"\nimport { percent } from \"../../value/types/numbers/units\"\nimport { ResolvedValues } from \"../../render/types\"\nimport { scalePoint } from \"./delta-apply\"\n\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nexport function removePointDelta(\n    point: number,\n    translate: number,\n    scale: number,\n    originPoint: number,\n    boxScale?: number\n): number {\n    point -= translate\n    point = scalePoint(point, 1 / scale, originPoint)\n\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint)\n    }\n\n    return point\n}\n\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nexport function removeAxisDelta(\n    axis: Axis,\n    translate: number | string = 0,\n    scale: number = 1,\n    origin: number = 0.5,\n    boxScale?: number,\n    originAxis: Axis = axis,\n    sourceAxis: Axis = axis\n): void {\n    if (percent.test(translate)) {\n        translate = parseFloat(translate as string)\n        const relativeProgress = mixNumber(\n            sourceAxis.min,\n            sourceAxis.max,\n            translate / 100\n        )\n        translate = relativeProgress - sourceAxis.min\n    }\n\n    if (typeof translate !== \"number\") return\n\n    let originPoint = mixNumber(originAxis.min, originAxis.max, origin)\n    if (axis === originAxis) originPoint -= translate\n\n    axis.min = removePointDelta(\n        axis.min,\n        translate,\n        scale,\n        originPoint,\n        boxScale\n    )\n\n    axis.max = removePointDelta(\n        axis.max,\n        translate,\n        scale,\n        originPoint,\n        boxScale\n    )\n}\n\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nexport function removeAxisTransforms(\n    axis: Axis,\n    transforms: ResolvedValues,\n    [key, scaleKey, originKey]: string[],\n    origin?: Axis,\n    sourceAxis?: Axis\n) {\n    removeAxisDelta(\n        axis,\n        transforms[key] as number,\n        transforms[scaleKey] as number,\n        transforms[originKey] as number,\n        transforms.scale as number,\n        origin,\n        sourceAxis\n    )\n}\n\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = [\"x\", \"scaleX\", \"originX\"]\nconst yKeys = [\"y\", \"scaleY\", \"originY\"]\n\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nexport function removeBoxTransforms(\n    box: Box,\n    transforms: ResolvedValues,\n    originBox?: Box,\n    sourceBox?: Box\n): void {\n    removeAxisTransforms(\n        box.x,\n        transforms,\n        xKeys,\n        originBox ? originBox.x : undefined,\n        sourceBox ? sourceBox.x : undefined\n    )\n    removeAxisTransforms(\n        box.y,\n        transforms,\n        yKeys,\n        originBox ? originBox.y : undefined,\n        sourceBox ? sourceBox.y : undefined\n    )\n}\n"]},"metadata":{},"sourceType":"module"}