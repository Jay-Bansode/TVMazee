{"ast":null,"code":"import { motionValue } from '../../value/index.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\n/**\n * Updates motion values from props changes.\n * Uses `any` type for element to avoid circular dependencies with VisualElement.\n */\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n  for (const key in next) {\n    const nextValue = next[key];\n    const prevValue = prev[key];\n\n    if (isMotionValue(nextValue)) {\n      /**\n       * If this is a motion value found in props or style, we want to add it\n       * to our visual element's motion value map.\n       */\n      element.addValue(key, nextValue);\n    } else if (isMotionValue(prevValue)) {\n      /**\n       * If we're swapping from a motion value to a static value,\n       * create a new motion value from that\n       */\n      element.addValue(key, motionValue(nextValue, {\n        owner: element\n      }));\n    } else if (prevValue !== nextValue) {\n      /**\n       * If this is a flat value that has changed, update the motion value\n       * or create one if it doesn't exist. We only want to do this if we're\n       * not handling the value with our animation state.\n       */\n      if (element.hasValue(key)) {\n        const existingValue = element.getValue(key);\n\n        if (existingValue.liveStyle === true) {\n          existingValue.jump(nextValue);\n        } else if (!existingValue.hasAnimated) {\n          existingValue.set(nextValue);\n        }\n      } else {\n        const latestValue = element.getStaticValue(key);\n        element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, {\n          owner: element\n        }));\n      }\n    }\n  } // Handle removed values\n\n\n  for (const key in prev) {\n    if (next[key] === undefined) element.removeValue(key);\n  }\n\n  return next;\n}\n\nexport { updateMotionValuesFromProps };","map":{"version":3,"mappings":";;AAKA;;;AAGG;;SACaA,4BACZC,SACAC,MACAC,MAAqB;EAErB,KAAK,MAAMC,GAAX,IAAkBF,IAAlB,EAAwB;IACpB,MAAMG,SAAS,GAAGH,IAAI,CAACE,GAAD,CAAtB;IACA,MAAME,SAAS,GAAGH,IAAI,CAACC,GAAD,CAAtB;;IAEA,IAAIG,aAAa,CAACF,SAAD,CAAjB,EAA8B;MAC1B;;;AAGG;MACHJ,OAAO,CAACO,QAAR,CAAiBJ,GAAjB,EAAsBC,SAAtB;IACH,CAND,MAMO,IAAIE,aAAa,CAACD,SAAD,CAAjB,EAA8B;MACjC;;;AAGG;MACHL,OAAO,CAACO,QAAR,CAAiBJ,GAAjB,EAAsBK,WAAW,CAACJ,SAAD,EAAY;QAAEK,KAAK,EAAET;MAAT,CAAZ,CAAjC;IACH,CANM,MAMA,IAAIK,SAAS,KAAKD,SAAlB,EAA6B;MAChC;;;;AAIG;MACH,IAAIJ,OAAO,CAACU,QAAR,CAAiBP,GAAjB,CAAJ,EAA2B;QACvB,MAAMQ,aAAa,GAAGX,OAAO,CAACY,QAAR,CAAiBT,GAAjB,CAAtB;;QAEA,IAAIQ,aAAa,CAACE,SAAd,KAA4B,IAAhC,EAAsC;UAClCF,aAAa,CAACG,IAAd,CAAmBV,SAAnB;QACH,CAFD,MAEO,IAAI,CAACO,aAAa,CAACI,WAAnB,EAAgC;UACnCJ,aAAa,CAACK,GAAd,CAAkBZ,SAAlB;QACH;MACJ,CARD,MAQO;QACH,MAAMa,WAAW,GAAGjB,OAAO,CAACkB,cAAR,CAAuBf,GAAvB,CAApB;QACAH,OAAO,CAACO,QAAR,CACIJ,GADJ,EAEIK,WAAW,CACPS,WAAW,KAAKE,SAAhB,GAA4BF,WAA5B,GAA0Cb,SADnC,EAEP;UAAEK,KAAK,EAAET;QAAT,CAFO,CAFf;MAOH;IACJ;EACJ,CA3CoB;;;EA8CrB,KAAK,MAAMG,GAAX,IAAkBD,IAAlB,EAAwB;IACpB,IAAID,IAAI,CAACE,GAAD,CAAJ,KAAcgB,SAAlB,EAA6BnB,OAAO,CAACoB,WAAR,CAAoBjB,GAApB;EAChC;;EAED,OAAOF,IAAP;AACJ","names":["updateMotionValuesFromProps","element","next","prev","key","nextValue","prevValue","isMotionValue","addValue","motionValue","owner","hasValue","existingValue","getValue","liveStyle","jump","hasAnimated","set","latestValue","getStaticValue","undefined","removeValue"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\render\\utils\\motion-values.ts"],"sourcesContent":["import { motionValue } from \"../../value\"\nimport { isMotionValue } from \"../../value/utils/is-motion-value\"\n\ntype MotionStyleLike = Record<string, any>\n\n/**\n * Updates motion values from props changes.\n * Uses `any` type for element to avoid circular dependencies with VisualElement.\n */\nexport function updateMotionValuesFromProps(\n    element: any,\n    next: MotionStyleLike,\n    prev: MotionStyleLike\n) {\n    for (const key in next) {\n        const nextValue = next[key]\n        const prevValue = prev[key]\n\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue)\n        } else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping from a motion value to a static value,\n             * create a new motion value from that\n             */\n            element.addValue(key, motionValue(nextValue, { owner: element }))\n        } else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                const existingValue = element.getValue(key)!\n\n                if (existingValue.liveStyle === true) {\n                    existingValue.jump(nextValue)\n                } else if (!existingValue.hasAnimated) {\n                    existingValue.set(nextValue)\n                }\n            } else {\n                const latestValue = element.getStaticValue(key)\n                element.addValue(\n                    key,\n                    motionValue(\n                        latestValue !== undefined ? latestValue : nextValue,\n                        { owner: element }\n                    )\n                )\n            }\n        }\n    }\n\n    // Handle removed values\n    for (const key in prev) {\n        if (next[key] === undefined) element.removeValue(key)\n    }\n\n    return next\n}\n"]},"metadata":{},"sourceType":"module"}