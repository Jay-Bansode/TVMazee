{"ast":null,"code":"import { isHTMLElement } from '../../utils/is-html-element.mjs';\nimport { isDragActive } from '../drag/state/is-active.mjs';\nimport { isNodeOrChild } from '../utils/is-node-or-child.mjs';\nimport { isPrimaryPointer } from '../utils/is-primary-pointer.mjs';\nimport { setupGesture } from '../utils/setup.mjs';\nimport { isElementKeyboardAccessible } from './utils/is-keyboard-accessible.mjs';\nimport { enableKeyboardPress } from './utils/keyboard.mjs';\nimport { isPressing } from './utils/state.mjs';\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\n\nfunction isValidPressEvent(event) {\n  return isPrimaryPointer(event) && !isDragActive();\n}\n\nconst claimedPointerDownEvents = new WeakSet();\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\n\nfunction press(targetOrSelector, onPressStart) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);\n\n  const startPress = startEvent => {\n    const target = startEvent.currentTarget;\n    if (!isValidPressEvent(startEvent)) return;\n    if (claimedPointerDownEvents.has(startEvent)) return;\n    isPressing.add(target);\n\n    if (options.stopPropagation) {\n      claimedPointerDownEvents.add(startEvent);\n    }\n\n    const onPressEnd = onPressStart(target, startEvent);\n\n    const onPointerEnd = (endEvent, success) => {\n      window.removeEventListener(\"pointerup\", onPointerUp);\n      window.removeEventListener(\"pointercancel\", onPointerCancel);\n\n      if (isPressing.has(target)) {\n        isPressing.delete(target);\n      }\n\n      if (!isValidPressEvent(endEvent)) {\n        return;\n      }\n\n      if (typeof onPressEnd === \"function\") {\n        onPressEnd(endEvent, {\n          success\n        });\n      }\n    };\n\n    const onPointerUp = upEvent => {\n      onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));\n    };\n\n    const onPointerCancel = cancelEvent => {\n      onPointerEnd(cancelEvent, false);\n    };\n\n    window.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n    window.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n  };\n\n  targets.forEach(target => {\n    const pointerDownTarget = options.useGlobalTarget ? window : target;\n    pointerDownTarget.addEventListener(\"pointerdown\", startPress, eventOptions);\n\n    if (isHTMLElement(target)) {\n      target.addEventListener(\"focus\", event => enableKeyboardPress(event, eventOptions));\n\n      if (!isElementKeyboardAccessible(target) && !target.hasAttribute(\"tabindex\")) {\n        target.tabIndex = 0;\n      }\n    }\n  });\n  return cancelEvents;\n}\n\nexport { press };","map":{"version":3,"mappings":"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","names":["isValidPressEvent","event","isPrimaryPointer","isDragActive","claimedPointerDownEvents","WeakSet","press","targetOrSelector","onPressStart","options","targets","eventOptions","cancelEvents","setupGesture","startPress","startEvent","target","currentTarget","has","isPressing","add","stopPropagation","onPressEnd","onPointerEnd","endEvent","success","window","removeEventListener","onPointerUp","onPointerCancel","delete","upEvent","document","useGlobalTarget","isNodeOrChild","cancelEvent","addEventListener","forEach","pointerDownTarget","isHTMLElement","enableKeyboardPress","isElementKeyboardAccessible","hasAttribute","tabIndex"],"sources":["C:\\Projects\\TVMazee\\node_modules\\motion-dom\\src\\gestures\\press\\index.ts"],"sourcesContent":["import { isHTMLElement } from \"../../utils/is-html-element\"\nimport { ElementOrSelector } from \"../../utils/resolve-elements\"\nimport { isDragActive } from \"../drag/state/is-active\"\nimport { EventOptions } from \"../types\"\nimport { isNodeOrChild } from \"../utils/is-node-or-child\"\nimport { isPrimaryPointer } from \"../utils/is-primary-pointer\"\nimport { setupGesture } from \"../utils/setup\"\nimport { OnPressStartEvent } from \"./types\"\nimport { isElementKeyboardAccessible } from \"./utils/is-keyboard-accessible\"\nimport { enableKeyboardPress } from \"./utils/keyboard\"\nimport { isPressing } from \"./utils/state\"\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event: PointerEvent) {\n    return isPrimaryPointer(event) && !isDragActive()\n}\n\nconst claimedPointerDownEvents = new WeakSet<Event>()\n\nexport interface PointerEventOptions extends EventOptions {\n    useGlobalTarget?: boolean\n    stopPropagation?: boolean\n}\n\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nexport function press(\n    targetOrSelector: ElementOrSelector,\n    onPressStart: OnPressStartEvent,\n    options: PointerEventOptions = {}\n): VoidFunction {\n    const [targets, eventOptions, cancelEvents] = setupGesture(\n        targetOrSelector,\n        options\n    )\n\n    const startPress = (startEvent: PointerEvent) => {\n        const target = startEvent.currentTarget as Element\n\n        if (!isValidPressEvent(startEvent)) return\n        if (claimedPointerDownEvents.has(startEvent)) return\n\n        isPressing.add(target)\n\n        if (options.stopPropagation) {\n            claimedPointerDownEvents.add(startEvent)\n        }\n\n        const onPressEnd = onPressStart(target, startEvent)\n\n        const onPointerEnd = (endEvent: PointerEvent, success: boolean) => {\n            window.removeEventListener(\"pointerup\", onPointerUp)\n            window.removeEventListener(\"pointercancel\", onPointerCancel)\n\n            if (isPressing.has(target)) {\n                isPressing.delete(target)\n            }\n\n            if (!isValidPressEvent(endEvent)) {\n                return\n            }\n\n            if (typeof onPressEnd === \"function\") {\n                onPressEnd(endEvent, { success })\n            }\n        }\n\n        const onPointerUp = (upEvent: PointerEvent) => {\n            onPointerEnd(\n                upEvent,\n                (target as any) === window ||\n                    (target as any) === document ||\n                    options.useGlobalTarget ||\n                    isNodeOrChild(target, upEvent.target as Element)\n            )\n        }\n\n        const onPointerCancel = (cancelEvent: PointerEvent) => {\n            onPointerEnd(cancelEvent, false)\n        }\n\n        window.addEventListener(\"pointerup\", onPointerUp, eventOptions)\n        window.addEventListener(\"pointercancel\", onPointerCancel, eventOptions)\n    }\n\n    targets.forEach((target: EventTarget) => {\n        const pointerDownTarget = options.useGlobalTarget ? window : target\n        pointerDownTarget.addEventListener(\n            \"pointerdown\",\n            startPress as EventListener,\n            eventOptions\n        )\n\n        if (isHTMLElement(target)) {\n            target.addEventListener(\"focus\", (event) =>\n                enableKeyboardPress(event as FocusEvent, eventOptions)\n            )\n\n            if (\n                !isElementKeyboardAccessible(target) &&\n                !target.hasAttribute(\"tabindex\")\n            ) {\n                target.tabIndex = 0\n            }\n        }\n    })\n\n    return cancelEvents\n}\n"]},"metadata":{},"sourceType":"module"}